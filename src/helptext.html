<!DOCTYPE HTML>
<html>
<header>
<title>Braid Functions</title>

<style>

                    body {
                        font-family: "Open Sans", Helvetica, Arial, Sans-Serif;
                    }
                    table {
                        border: 1px solid black;
                    }
                    th {
                        padding: 10px;
                        text-align: center;
                        background-color: #e0e0e0; 
                    }
                    td {
                        padding: 10px;
                        text-align: left;
                        vertical-align: top;
                    }
                    tr:nth-child(even) {background-color: #f2f2f2;}
            
</style>

</header>
<body>
<h2>Braid Function Documentation</h2>
<p>
                This page lists all of the Braid functions generally
                available to the user. Functions are either built into
                <br>
                the interpreter directly, defined in the file <b>autoload.tl</b>
                or loaded from other utility modules.
                <br>
                </p>

<table>
<tr>
<th>No</th> <th>Function</th> <th>Origin</th> <th>Description</th>
</tr>
 <tr>
<td>1</td> <td><b>-</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The subtraction function (-) allows you to subtract numbers or DateTime and TimeSpan objects. All .NET numeric formats are supported. If only a single argument is passed, a curried function is returned.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>2</td> <td><b>--</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;--&#39; function takes a single numeric argument value and returns that value decremented by one. In contrast, the &#39;decr&#39; function takes a symbol argument and increments the value the named variable.<pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>3</td> <td><b>!</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>4</td> <td><b>!!</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function is used for accessing or setting elements in indexable data structures like lists, vectors and dictionaries. The first two arguments specify the indexible collection and the index to access. If a third argument is provided, this argument is used as the value to set the indexed item to. (Note that strings are a special case - they are indexible but not mutable and which means the three argument syntax doesn&#39;t work).<br><br><pre>Examples:



</pre><br/></td>
</tr>
 <tr>
<td>5</td> <td><b>!=</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;!=&#39; function compares two objects to see if they are not equal.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>6</td> <td><b>!==</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This is the negative reference equals function (!==). If the arguments provided refer to the same object, the function will return false. If more than one pair of values is provided, they will all be compared pairwise.<br><br> <pre>Examples:





</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>7</td> <td><b>$</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;compose&#39; function takes a list of functions and returns a new function composed of the individual functions piped together.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>8</td> <td><b>%</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;%&#39; function computes the modulus of the its argument values. Syntax: (% &lt;numVal1&gt; &lt;numVal2&gt;) The function is only defined for numeric values.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>9</td> <td><b>*</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;*&#39; multiplication function computes the product of it&#39;s arguments if the arguments are numeric. If the first argument is a string or sequence, that sequence will be replicated the specified number of times. Syntax You can compute factorials using multiply, splatting and the range function as<br><br>  If only one argument is passed, then a curried function is returned<br><br><pre>Examples:





</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>10</td> <td><b>**</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The ** operator lets you compute the exponentiation of numbers.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>11</td> <td><b>.</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;.&#39; function is the member accessor operation allowing you to get and set properties and fields and call instance (by specifying an object instance) and static (by specifying a type) methods. In the case of a property or field, if only the member name is specified, the operation will be a get. If an additional argument is provided, the operation will be a set.<br><br><pre>Examples:


</pre><br/></td>
</tr>
 <tr>
<td>12</td> <td><b>/</b></td> <td>built-in</td> <td>Syntax<br/><br/>  The division function (/) divides its first operand by it&#39;s second. If the division is not perfect, the result will be returned as a ^double<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>13</td> <td><b>:</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;:&#39; function constructs a new list. It adds the arg value to the list, returning a new list.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>14</td> <td><b>\</b></td> <td></td> <td>Syntax:<br/><br/>  Macro for creating function literals of the form (\ &lt;args&gt; -&gt; &lt;body&gt;).<br><br><pre>Examples:




</pre><br/></td>
</tr>
 <tr>
<td>15</td> <td><b>+</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The addition function (+)  sums all of its arguments together. It works on numbers, strings and datetime objects. The type of the first argument (number, string or datetime) will determine the type of the overall operation.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>16</td> <td><b>++</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;++&#39; function takes a single numeric argument value and returns that value incremented by one. In contrast, the &#39;incr&#39; function takes a symbol argument and increments the value the named variable.<br><br><pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>17</td> <td><b><</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This is the polymorphic less than function (&lt;) which works on any types that support ordered comparisons.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>18</td> <td><b><=</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This is the polymorphic less than or equals function which works on any types that support ordered comparisons.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>19</td> <td><b>=</b></td> <td></td> <td>Syntax:<br/><br/>  A macro that parses and transforms infix arithmetic expressions with conventional operator precedence into prefix notation. The net effect is similar to the &#39;expr&#39; function in TCL but has no runtime impact.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>20</td> <td><b>==</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This is the polymorphic comparison function (==) which works on any types that support comparisons (IComparable). If more than one pair of values is provided, they will all be compared pairwise.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>21</td> <td><b>===</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This is the reference equals function (===). If the arguments provided refer to the same object, the function will return true. If more than one pair of values is provided, they will all be compared pairwise.<br><br> <pre>Examples:





</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>22</td> <td><b>></b></td> <td>built-in</td> <td>Syntax:<br/><br/>  With two arguments, the &#39;&gt;&#39; function returns true if arg1 is greater than arg2. If more than two arguments are specified, &#39;&gt;&#39; returns true if the arguments are in monotonically decreasing order. This function works for all comparable types.<br><br><pre>Examples:




</pre><br/></td>
</tr>
 <tr>
<td>23</td> <td><b>>:</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>24</td> <td><b>>=</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if all of its arguments are monotonically greater than or equal to the previous argument.<br><br><pre>Examples:




</pre><br/></td>
</tr>
 <tr>
<td>25</td> <td><b>->></b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function implements the logic for the form (a | b | c) which is translated at compile time into (-&gt;&gt; a (b) (c)) There&#39;s not a lot of reason to use this function directly.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>26</td> <td><b>>cons</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function is identical to &#39;cons&#39; except the arguments are reversed allowing it to be used in a pipeline. Like &#39;cons&#39;, it adds the arg value to the start of the list, returning a new list.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>27</td> <td><b>>def</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Like &#39;def&#39;, this function sets the value of a variable if that variable already exists or create a new variable in the current scope if it doesn&#39;t. The difference is that the order of the arguments is reversed. This allows &#39;&gt;def&#39; to be used in the pipeline.<br><br> Note: If the name takes the form of v1:v2:v3 then destructuring will be done and the parts assigned.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>28</td> <td><b>>let</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  This special form allows left-to right assignment.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>29</td> <td><b>abs</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Function to get the absolute value of its argument.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>30</td> <td><b>add</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>31</td> <td><b>add-watch</b></td> <td>powershell</td> <td>Syntax:<br/><br/>  This function sets up a file watcher that will cause a script module to be reloaded if it has changed since the last repl command was issued.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>32</td> <td><b>alert</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function prints a string to the console with emphasis.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>33</td> <td><b>all-members</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;all-members&#39; function is used by the &#39;completer&#39; function to do method completion. It returns a Vector of all of the members defined on the types that are currently &#39;in use&#39; i.e. there is an instance of that type stored in a Braid variable. These members are considered to be the &#39;interesting&#39; ones for the interactive user.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>34</td> <td><b>and</b></td> <td>built-in</td> <td>Syntax:<br/><br/> The &#39;and&#39; function returns the last argument if all of its other arguments evaluate to true. Lazy evaluation is used so the first argument that doesn&#39;t resolve to true terminates execution and false is returned.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>35</td> <td><b>and$</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;and$&#39; (&#39;and compose&#39;) function takes a list of functions and returns a new function composed of the individual functions with the results and&#39;ed together. The argument to the outer function is passed to each of the inner functions. The results of these functions are and&#39;ed together to produce a final result.<br><br> <br><br><pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>36</td> <td><b>Announce</b></td> <td>console.tl</td> <td>Syntax:<br/><br/>  Show an announcement in a box at the center of screen, surrounded by a box. The content will be broken up to fit the size of the box.<pre></pre><br/></td>
</tr>
 <tr>
<td>37</td> <td><b>append</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;append&#39; function appends it&#39;s arguments together to produce a new list. If an argument is a list, it is stiched into the result list rather than being added as a single member.<pre>
</pre><br/></td>
</tr>
 <tr>
<td>38</td> <td><b>apply</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The apply takes a function and a collection and applies the function using the collection as the arguments to that function. It is similar to splatting in that (apply + coll) returns the same result as (+ @coll).<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>39</td> <td><b>as</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  As converts it&#39;s first argument into the type specified by the second argument either returning an object of that type or null if the conversion was not successful.<pre>

</pre><br/></td>
</tr>
 <tr>
<td>40</td> <td><b>asarray</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;asarray&#39; function returns its argument wrapped in an instance of ^object[]. If the argument is already ^object[], it is simply returned. If the argument is an ^IEnumerable, an array of equivalent size is allocated and the elements copied in to this new array. It the argument is a scalar, it will be wrapped in a one-element array. An optional array type can be specified in which case the returned array will be of that type and the objects in the source enumerable will be converted to the target type<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>41</td> <td><b>asEventHandler</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Make an ^EventHandler delegate out of a Braid lambda. The lambda must take two parameters: the object invoking the event and the eventArgs object.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>42</td> <td><b>aslist</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;aslist&#39; function converts its argument enumerable into a Braid list.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>43</td> <td><b>assoc-in</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Update a dictionary given a list of keys and a value to assign/insert. The list of keys represents a path into the object. If any nodes don&#39;t exist or are not dictionaries, new dictionary nodes are assigned/added (like mkdir -p).<pre></pre><br/></td>
</tr>
 <tr>
<td>44</td> <td><b>async</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Starts a new background task using the .NET Task Parallel Library with the lambda as the ^Task procedure. An optional argument may be passed in though most things will be passed through the closure. Tasks can be composed with the subsequent task receiving the result of the previous task.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>45</td> <td><b>atom?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;atom?&#39; function returns true if its argument is not an enumerable type.<br><br><pre>Examples:


</pre><br/></td>
</tr>
 <tr>
<td>46</td> <td><b>average</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;average&#39; function computes the average of it&#39;s arguments, with an optional function to get the value to average.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>47</td> <td><b>await</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The await function waits for all argument tasks to complete and then returns a collection containing the values returned by the tasks. Note that even in the simple case of a single task, the result will still be returned as a collection of one element. &#39;resolve&#39; is an alias for &#39;await&#39;.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>48</td> <td><b>background</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Run an expression in the background using a .NET ^Task. This ^Task will be run in memory but on a seperate thread so it doesn&#39;t block the REPL thread.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>49</td> <td><b>band</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;band&#39; function performs a binary &#39;and&#39; on its arguments.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>50</td> <td><b>baseobject</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  If the argument object is a PowerShell PSObject, the &#39;baseobject&#39; function will return the base object from the PSObject. If the argument is not a PSObject, then it will just return the original object.<pre></pre><br/></td>
</tr>
 <tr>
<td>51</td> <td><b>base-of</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;base-of&#39; function returns the base type of its type argument.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>52</td> <td><b>bigger</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function returns the largest member of its argument list.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>53</td> <td><b>binary</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Function to take numeric arguments and turn them into binary strings. Normally the strings are prefixed with &#39;0b&#39; but if -noprefix is specified, then the &#39;0b&#39; prefix will be omitted.<pre></pre><br/></td>
</tr>
 <tr>
<td>54</td> <td><b>bind</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  (Re)Bind a lambda to either the current environment or a optional passed argument.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>55</td> <td><b>bindhelp</b></td> <td>helpsource.tl</td> <td>Syntax:<br/><br/>  Creates a :helptext association between one or more functions and their help text<pre></pre><br/></td>
</tr>
 <tr>
<td>56</td> <td><b>bnot</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;bnot&#39; function computes the bitwise complement of its argumen.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>57</td> <td><b>bor</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;bor&#39; function performs a binary &#39;or&#39; on its arguments.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>58</td> <td><b>bound?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  returns true if the symbol has a binding (an associated value or function.)<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>59</td> <td><b>breadth-search</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function will perform a breadth-first search through a set of data. The first parameter is the starting data item. The second parameter is either the target data item on a function of one argument returning a boolean value if it&#39;s argument is the target item. The final argument is the move generator function. This function is passed the current item and returns a list of &#39;next&#39; items to search.<br><br><pre>Examples:







</pre><br/></td>
</tr>
 <tr>
<td>60</td> <td><b>break</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;break&#39; function allows you to break out of a loop as shown in the examples An optional value can be specified in which case the value becomes the result (or part of the result) of the loop. It works for &#39;conventional&#39; loops like &#39;while&#39; and &#39;foreach&#39; as well as functions like &#39;map&#39;, &#39;filter&#39; and &#39;zip&#39;.<br><br> <pre>Examples:













</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>61</td> <td><b>bxor</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;bxor&#39; function performs a binary &#39;xor&#39; on its two arguments.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>62</td> <td><b>caddr</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Returns the third item in a sequence<pre></pre><br/></td>
</tr>
 <tr>
<td>63</td> <td><b>cadr</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Returns the second item in a sequence<pre></pre><br/></td>
</tr>
 <tr>
<td>64</td> <td><b>call</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Utility to call a function on a set of args; (Not sure this really needs to exist...).<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>65</td> <td><b>car</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;car&#39; function returns the first item from a sequence, or the item itself if it&#39;s an atom.  (head is an alias for car.) If the argument is a string, the first &#39;word&#39; is returned i.e. all of the text up to the first whitespace character.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>66</td> <td><b>case</b></td> <td></td> <td>Syntax:<br/><br/>  A macro for the &#39;case&#39; expression. A case expression looks like:   (case (+ 2 3) 1 &quot;One&quot; 2 &quot;Two&quot; 3 &quot;three&quot;) which will generate a cond statement that looks like:   (do   )<br><br><pre>





</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>67</td> <td><b>cd</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Directory stack aware &#39;cd&#39; change directory function.<pre></pre><br/></td>
</tr>
 <tr>
<td>68</td> <td><b>cddr</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Returns the cdr of the cdr of the sequence.<br><br><pre>Examples:



</pre><br/></td>
</tr>
 <tr>
<td>69</td> <td><b>cdr</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;cdr&#39; function skips the first item in a sequence and returns the rest, or it returns the item itself if it&#39;s an atom. Note that for sequences, cdr always returns an s_Expr regardless of the original type of the sequence. This is for performance reasons. Getting the cdr of a Vector is slow. Getting the cdr of an s_Expr, is very fast. (Commands tail and rest are aliases for cdr.)<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>70</td> <td><b>ceiling</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Compute the ceiling of a number.<pre></pre><br/></td>
</tr>
 <tr>
<td>71</td> <td><b>char</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns the ^char of the first character in a 1-element string.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>72</td> <td><b>chars</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;chars&#39; function converts is string argument to an array of characters.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>73</td> <td><b>Chomp</b></td> <td>console.tl</td> <td>Syntax:<br/><br/>  Split a string into &#39;num&#39; length segments. Splitting is done on whitespace.<pre></pre><br/></td>
</tr>
 <tr>
<td>74</td> <td><b>ChompAll</b></td> <td>console.tl</td> <td>Syntax:<br/><br/>  Split a string into specified length segments.<pre></pre><br/></td>
</tr>
 <tr>
<td>75</td> <td><b>choose</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Choose n elements from a sequence of items.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>76</td> <td><b>cls</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Clears the console screen.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>77</td> <td><b>collection?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if its argument is any of the sequence types (List, Vector, IEnumerable, ISeq etc.).<br><br><pre>Examples:



</pre><br/></td>
</tr>
 <tr>
<td>78</td> <td><b>combinations</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Calculate the number of combinations choosing k items from a set of n items.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>79</td> <td><b>combine</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Generate the all of the combinations of a sequence of items.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>80</td> <td><b>comment</b></td> <td></td> <td>Syntax:<br/><br/>  macro to comment out a list of forms (but that list must be well-formed).<pre></pre><br/></td>
</tr>
 <tr>
<td>81</td> <td><b>compare</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;compare&#39; function compares two value and returns -1 if the first value is smaller than the second, 0 if the values are the same and 1 if thesecond value is larger than the fitst value.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>82</td> <td><b>completer</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The tab-completion implementation for Braid. This function needs to be bound to the completer callback to work (see the function definition for how this is done.)<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>83</td> <td><b>compliment</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;compliment&#39; function is identical to &#39;partial&#39; except that a call to &#39;not&#39; is wrapped around the expression.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>84</td> <td><b>compose</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;compose&#39; function takes a list of functions and returns a new function composed of the individual functions piped together.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>85</td> <td><b>concat</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;concat&#39; function appends it&#39;s arguments together to produce a new vector (see also the &#39;append&#39; function with produces a list instead of a vector.) If an argument is a sequence, it is stiched into the result list rather than being added as a single member. Any null arguments are simply skipped.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>86</td> <td><b>cond</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;cond&#39; function evaluates each conditional expression and if it evaluates to true, execute the associated action. To specify the default action, make the condition &#39;true&#39; as shown in the example.<br><br> <pre>Examples:




</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>87</td> <td><b>cons</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;cons&#39; function constructs a new list. It adds the arg value to the list, returning a new list.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>88</td> <td><b>console/backcolor</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Sets the console background color.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>89</td> <td><b>console/clear</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Clears the console screen.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>90</td> <td><b>console/forecolor</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Sets the console foreground color.<br><br><pre>Examples:


</pre><br/></td>
</tr>
 <tr>
<td>91</td> <td><b>console/readkey</b></td> <td>console.tl</td> <td>Syntax:<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>92</td> <td><b>console/writeat</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The console/writeat function writes a message at a specified location on the console. You can optionally specify the fore- and background colors to use when writing the text.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>93</td> <td><b>console/writeline</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Print a string made out of the tostring&#39;s of each of the argument to the console adding a newline at the end. (This function is an alias for &#39;println&#39;.)<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>94</td> <td><b>const</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;const&#39; function reates a constant binding in the variable table at the current scope. Trying to set the value of a constant will result in an error. Constants can be removed with the &#39;undef&#39; function.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>95</td> <td><b>contains?</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Returns true if the argument list contains the specified value or matches the lambda. Does a shallow search.<pre></pre><br/></td>
</tr>
 <tr>
<td>96</td> <td><b>contains-key</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Recursively searches a structure to see if there are dictionary entries matching the specified key and optional value. A vector of all matching dictionaries are returned.<br><br><pre>Examples:


</pre><br/></td>
</tr>
 <tr>
<td>97</td> <td><b>contains-scalar</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Checks the argument tree to see if it contains specified scalar value Does a deep (recursive) search.<pre></pre><br/></td>
</tr>
 <tr>
<td>98</td> <td><b>continue</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Continues to the next iteration in a loop (while, foreach, forall) or in higher-order functions like map or filter.  <br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>99</td> <td><b>copy-vector</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Copy the argument collection into a new vector. It&#39;s always copied even if the argument was already a vector. Non-sequence types get wrapped into a single-element vector.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>100</td> <td><b>cos</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Compute the cosine of a number.<pre></pre><br/></td>
</tr>
 <tr>
<td>101</td> <td><b>count</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns the count of a collection. If the argument is a scalar, then it returns 1. If it&#39;s null, then the function returns 0. This is an alias for the &#39;count&#39; function.<br><br> <pre>Examples:




</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>102</td> <td><b>CreateDelegate</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Creates a delegate of the specified type out of a lambda.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>103</td> <td><b>create-scriptblock</b></td> <td></td> <td>Syntax:<br/><br/>  Create a PowerShell ScriptBlock object. This object can be used as a braid function simply by assigning it to a variable then invoking it like any other function.<br><br> Exmples:<pre>

</pre><br/></td>
</tr>
 <tr>
<td>104</td> <td><b>debug/breakPoint</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>105</td> <td><b>debug/pwatch</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;debug/pwatch&#39; (pipeline watch) function is a debugging utility that can be inserted into a pipeline to see what&#39;s passing through the pipeline. The output display will prefixed with the user specified tag to help correlate the output. An optional filter may be specified to reduce the ammount of output.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>106</td> <td><b>decr</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function decrements the value in the named variable, returning the new value. The value in the variable must be of an integral type.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>107</td> <td><b>def</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Set the value of the named variable if a variable with that name already exists or create a new variable in the current scope if it doesn&#39;t.<br><br> Note: If the name takes the form &#39;v1:v2:v3&#39; then destructuring will be done and the parts of the argument collection will be assigned to the variables.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>108</td> <td><b>def-dynamic</b></td> <td>built-in</td> <td><br/><br/> Establish a binding in the dynamic scope of the calling function.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>109</td> <td><b>defenum</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  A function for defining Braid enum types with a base type of integer. The enum members can be specified either as a simple list of names or using a single dictionary. If simple names are specified, they are automatically assigned values starting at 0, increasing by 1 for each member. If a dictionary is passed, member names names are taken from the keys and the dictionary values become the member values.<br><br> <pre>Examples:




</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>110</td> <td><b>definterface</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;definterface&#39; function allows you to define .NET interfaces in Braid. Data members can be specified by simply including their names. An optional type may also be specified for a data member. The &#39;:defm&#39; keyword is used to define method prototypes. The method body is specified as a lambda where the first parameter must be &#39;this&#39;. Any code in the member body is ignore as interfaces do not provide implementation.<br><br> <pre>Examples:





</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>111</td> <td><b>defmacro</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Define a new macro to be processed at compile time. The defined macro will receive its arguments unevaluated and should return a new S-Expression to replace the original structure.<pre></pre><br/></td>
</tr>
 <tr>
<td>112</td> <td><b>defmethod</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Add a method to an existing type definition. Methods require at least one parameter: the this pointer. This must be specified even if it is not used in the method body. Note that the method name must be a raw symbol, not a keyword i.e. it must be &quot;foo&quot; not &quot;:foo&quot;.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>113</td> <td><b>defn</b></td> <td></td> <td>Syntax:<br/><br/>  The &#39;defn&#39; function allows you to define custom functions. The body of the function being defined can either be a &#39;conventional&#39; function or a pattern function. A literal string specified after the function name but before the argument vector or first pattern is treated as the  documentation string for that function. You can also specify the return type for the function by placing a type literal after the doc string but before the start of the function body.<br><br> Arguments to a conventional function are enclosed in a vector literal and can take several forms: a simple name such as &#39;num&#39;, a type-constrained argument such as (^int num), an initialized name such as &#39;(num 0)&#39; and finally as an initialized type-constrained name: &#39;(^int num 0)&#39;. Uninitialized names are manadatory (must be specified). Initialized names are optional arguments. If they are passed an explicit value, that value is used. If there is no formal argument corresponding to the name then the initializer value is used.<br><br> BUGBUGBUG -add stuff about named parameters.<br><br> <pre>Examples:











</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>114</td> <td><b>defobject</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Create a PowerShell PSCustomObject.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>115</td> <td><b>defspecial</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Defines a &#39;special form&#39;. Special forms are functions that will receive their arguments unevaluated. Braid has many built-in special forms such as &#39;if&#39;, &#39;while&#39;, &#39;let&#39; and so on. Using &#39;defspecial&#39;, you can define your own control structures, as shown in the examples. Typically, defspecial functions also use the &#39;upvar&#39; and &#39;upDo&#39; functions to implement these control structures.<br><br> <pre>Examples:




















</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>116</td> <td><b>deftype</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;deftype&#39; function allows you to define types in Braid. Data members can be specified by simply including their names. An optional type may also be specified for a data member. The &#39;:defm&#39; keyword is used to define a method. The method body is specified as a lambda where the first parameter must be &#39;this&#39;. &#39;this&#39; contains a reference to the current instance so to access a member variable &#39;a&#39;, you must write &#39;(.a this)&#39;. Methods can also be defined independently of the type using the &#39;defmethod&#39; function. Re-executing a &#39;deftype&#39; call will redefine existing any existing types with the same name.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>117</td> <td><b>dict/accessor</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;dict/accessor&#39; function takes a dictionary key (typically a string) and generates a custom dictionary accessor function. This function can then be used to retrieve the value for that key from an arbitrary dictionary. If the key is not present, an error is thrown.  If the function is applied against an ^IEnumerable, then the designated member from each element in the collection is aggregated into a result vector. Note that in the enumerable case, if the element is not a dictionary, it is simply skipped.  Using a dictionary accessor for commonly retrieved keys can produce some signifinant performance improvements.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>118</td> <td><b>dict?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if the argument expression resolves to a dictionary.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>119</td> <td><b>dirs</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  function to list and navigate the directory stack<pre></pre><br/></td>
</tr>
 <tr>
<td>120</td> <td><b>distinct</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns only the distinct items in the argument collection. The result is returned as a vector. An optional accessor function can be supplied which extracts the property to compare.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>121</td> <td><b>div</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Performs the &#39;div&#39; operation on the arguments returning the integer part of the division.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>122</td> <td><b>do</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Executes a series of expressions, one at a time and in order returning the result of the last expression as the final value of the expression. Do is commonly used with the &#39;if&#39; function when you want to have multiple expressions in the &#39;if&#39; or &#39;else&#39; parts of the statemant. The &#39;when&#39; and &#39;unless&#39; macros use &#39;do&#39; for this purpose.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>123</td> <td><b>doc</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  A function to quickly get the documentation string for a function<pre></pre><br/></td>
</tr>
 <tr>
<td>124</td> <td><b>drain</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function ignores any non-enumerable arguments and returns null. Any enumerable arguments are run to completion i.e. they are drained. This is particularly important with lazy functions like range or lazy-map which must be specifically enumerated to have any effect. In contrast, if you used &#39;void&#39; instead of &#39;drain&#39;, the enumerables will not be run.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>125</td> <td><b>DrawBox</b></td> <td>console.tl</td> <td>Syntax:<br/><br/>  Draw a box on the screen.<pre></pre><br/></td>
</tr>
 <tr>
<td>126</td> <td><b>dump-error</b></td> <td>powershell</td> <td>Syntax:<br/><br/>  Dump the contents of the last PowerShell/.NET exception that occurred. This will give you the .NET stack trace for the error instead of the Braid stack trace. This is implemented using the PowerShell $error[0] variable.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>127</td> <td><b>each</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Like &#39;map&#39;, the &#39;each&#39; function is usually used in pipelines to process items from the input sequence. It takes a list of values and a function to apply to each value Functions can either be predefined functions, property functions or lambdas. However, unlike &#39;map&#39;, the &#39;each&#39; function always returns a singke null so its primary use case is in side effects.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>128</td> <td><b>echo</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;echo&#39; is the &#39;identity function&#39; and simply returns it&#39;s arguments unmodified. If multiple arguments are specified then a collection is returned. If only a single value is provided, then it will be returned as scalar.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>129</td> <td><b>edit</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Launch gvim on the argument file.<pre></pre><br/></td>
</tr>
 <tr>
<td>130</td> <td><b>edit-distance</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;edit-distance&#39; function computes the &quot;edit distance&quot; between the two argument strings using the Damerau-Levenshtein algorithm - a metric of similarity based on inserts, removes and replacements.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>131</td> <td><b>env</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Gets all of the defined environment variables. An optional pattern (regex) can be specified to filter the list. An option &#39;-scope:&#39; can be specified to choose whether to dump the process, user or machine environment variables.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>132</td> <td><b>environment</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns the active lexical environment.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>133</td> <td><b>eq?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This is the polymorphic equality comparison function (eq?) which works on any types that support comparisons (IComparable). (Note: eq? is actually an  alias for the &#39;==&#39; function.) Value semantics are used for the core braid types of vectors, dictionaries and lists.<br><br> <pre>Examples:




</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>134</td> <td><b>error</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function prints an error string to the console in red.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>135</td> <td><b>eval</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Evaluate an s-expression as a function in the current scope.<br><br><pre>Examples:


</pre><br/></td>
</tr>
 <tr>
<td>136</td> <td><b>eval-string</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Parses a string into an s-expression then evaluate it using &#39;eval&#39;.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>137</td> <td><b>even?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;even?&#39; function returns true if its argument is an even number.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>138</td> <td><b>except</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Computes the difference between two list. All of the items in list 1 that aren&#39;t in list 2 are returned.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>139</td> <td><b>extract-min</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Extract (remove and return) the n smallest items from a vector.<pre></pre><br/></td>
</tr>
 <tr>
<td>140</td> <td><b>fact</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Compute the factorial of the argument. Big integers are used.<pre></pre><br/></td>
</tr>
 <tr>
<td>141</td> <td><b>fastfib</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  A fast tail-recursive implementation of the &#39;fib&#39; function<pre></pre><br/></td>
</tr>
 <tr>
<td>142</td> <td><b>fgrep</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Utility to recursively find files containing the specified regular expression. By default only &#39;*.tl&#39; files are scanned.<pre></pre><br/></td>
</tr>
 <tr>
<td>143</td> <td><b>fib</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Compute the fibonocci number for the argument using the naive recursive algorithm and bigints.<pre></pre><br/></td>
</tr>
 <tr>
<td>144</td> <td><b>file/basename</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Gets the basename part of a file name<pre></pre><br/></td>
</tr>
 <tr>
<td>145</td> <td><b>file/dir-exists</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Test to see if a directory exists<pre></pre><br/></td>
</tr>
 <tr>
<td>146</td> <td><b>file/dirname</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Gets the directory part of a file name<pre></pre><br/></td>
</tr>
 <tr>
<td>147</td> <td><b>file/exists</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Test to see if a file exists<pre></pre><br/></td>
</tr>
 <tr>
<td>148</td> <td><b>file/extension</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Gets or sets the extension on a file name<pre></pre><br/></td>
</tr>
 <tr>
<td>149</td> <td><b>file/filename</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Gets the directory part of a file name<pre></pre><br/></td>
</tr>
 <tr>
<td>150</td> <td><b>file/isRooted</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Test to see if a pathname is absolute<pre></pre><br/></td>
</tr>
 <tr>
<td>151</td> <td><b>file/join-path</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Join path components into a single string using the system appropriate path separator.<pre></pre><br/></td>
</tr>
 <tr>
<td>152</td> <td><b>file/parse</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>153</td> <td><b>file/read-lines</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>154</td> <td><b>file/setWriteTime</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Sets the last write time on the file specified to the targetTime. If no time is specified, then the current time is used. (Similar to the &#39;touch&#39; utility.<pre></pre><br/></td>
</tr>
 <tr>
<td>155</td> <td><b>file/tempFileName</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Gets the name of a temporary file, optionally specifying the file extension. When specifying the extension, the leading dot may be omitted.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>156</td> <td><b>files</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Prints out the &#39;*.tl&#39; files in columns.<pre></pre><br/></td>
</tr>
 <tr>
<td>157</td> <td><b>filter</b></td> <td>built-in</td> <td>Syntax:<br/><br/> Filters the input collection based on the results of evaluating the predicate function on each item. The predicate can be a lambda literal, a named function, a member accessor, a type literal, a regular expression or a dictionary literal. If a dictionary literal is provided, &#39;filter&#39; will use property pattern matching as the filter criteria. The sense of the comparison can be changed with the &#39;-not&#39; flag. The &#39;lazy-&#39; variant returns an enumerable instead of a collection. Individual values can then be pulled from the enumerable as needed thus only evaluating as much as is necessary.  Either of the forms can use &#39;break&#39; in the predicate function to terminate the search at the current item. You can also use &#39;continue&#39; to skip over the current item in the list and keep searching.<br><br> <pre>Examples:








</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>158</td> <td><b>first</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;first&#39; function returns the first &lt;num&gt; items from the argument collection. If &lt;num&gt; is not specified, it defaults to 1. If the collection is a string, &#39;first&#39; returns the first &lt;num&gt; characters. If the argument is not a collection, then it is simply returned.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>159</td> <td><b>fixit</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Resets the screen colors to white on black.<pre></pre><br/></td>
</tr>
 <tr>
<td>160</td> <td><b>flatmap</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;flatmap&#39; function is usually used in pipelines to process items in the pipeline.It takes a list of values and a function to apply to each value as in: - (flatmap &lt;list&gt; &lt;function&gt;) or (&lt;list&gt; | flatmap &lt;function&gt;) Functions can either be predefined functions, property functions or lambdas. As opposed to the map function, &#39;flatmap&#39; flattens its result so if the function returns a list, that list will be stiched into the result list rather than appearing as a discrete list. The distinction between &#39;flatmap&#39; and &#39;lazy-flatmap&#39; is that &#39;flatmap&#39; returns the entire result collection whereas &#39;lazy-flatmap&#39; returns an enumerable immediately and te values can be pulled out as needed.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>161</td> <td><b>flatten</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;flatten&#39; function recursively flattens all of its arguments into a single collection.<br><br> Example:<br><br><pre>

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>162</td> <td><b>floor</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Compute the floor of a number.<pre></pre><br/></td>
</tr>
 <tr>
<td>163</td> <td><b>fmt</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Utility to format strings (using String.Format)<pre></pre><br/></td>
</tr>
 <tr>
<td>164</td> <td><b>fn</b></td> <td></td> <td>Syntax:<br/><br/>  Macro for creating function literals of the form (\ &lt;args&gt; -&gt; &lt;body&gt;).<br><br><pre>Examples:




</pre><br/></td>
</tr>
 <tr>
<td>165</td> <td><b>foldl</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function iterates through a list applying the function to each of the items and accumulating a result. An optional seed value can be provided.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>166</td> <td><b>foldr</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function iterates through a list applying the function to each pair of the items and accumulating a result. An optional seed value can be provided. Unlike reduce/foldl, which folds from left to right whereas &#39;foldr&#39; folds right-to-left. <br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>167</td> <td><b>for</b></td> <td></td> <td>Syntax:<br/><br/>  Macro implementing the for &quot;statement&quot; built on top of the while function.<br><br><pre>Examples:



</pre><br/></td>
</tr>
 <tr>
<td>168</td> <td><b>forall</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;forall&#39; function iterates over the argument list, binding each value to the supplied variable and then executes all of the body expressions. The &#39;forall&#39; function returns the value of evaluating the last body expression for all iterations.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>169</td> <td><b>foreach</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;foreach&#39; function iterates over the argument list, binding each value to the supplied variable and then executes all of the body expressions.  The &#39;var&#39; specification can be a simple variable e.g. &#39;foo&#39; or a pattern &#39;a:b:c&#39; in which case destructuring is performed on each item or finally, it can be a literal vector of variables in which case multiple items will be pulled from the list. Lite the pipeline &#39;each&#39; function, the standalone &#39;foreach&#39; function returns no value (null).<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>170</td> <td><b>from</b></td> <td></td> <td>Syntax:<br/><br/>  The &#39;from&#39; macro is a list comprehension operator that iterates over multiple lists. It is structurally similar to &#39;let&#39; in that the first argument is a vector composed of variable/list pairs and the remaining args represent the executable body of the &#39;statement&#39;. Implementation-wise, this macro uses &#39;forall -flatten&#39; to maintain a result depth of 1.<br><br>   (from [a [1 2 3] b (range 5) c [10 20 30]]   )<pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>171</td> <td><b>function?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if the argument expression resolves to a function.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>172</td> <td><b>functions</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Return a list of all defined functions, special forms and macros. An optional regex can be used to filter the names that are returned. Functions are returned as key/value pairs where the .key is the function name and the .value is the function definition.<pre></pre><br/></td>
</tr>
 <tr>
<td>173</td> <td><b>funcToCheck</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;group&#39; function groups members of a collection together in a dictionary by the value returned by the &lt;byFunction&gt;. Once the groups have been created, the &lt;processGroupFn&gt; is applied to each group. This function can be used to do things like rrplace the group with the count of group elements or compute the sum of a property on an element.<br><br><pre>Examples:




</pre><br/></td>
</tr>
 <tr>
<td>174</td> <td><b>gcd</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Compute the greatest common divisor for two numbers<pre></pre><br/></td>
</tr>
 <tr>
<td>175</td> <td><b>gdv</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function retrieves the ^BraidVariable object associated with the argument symbol looking up the dynamic (runtime) callstack. This is particularly useful in the debugger.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>176</td> <td><b>gen-symbol</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Generates and returns a new unique symbol. This is used in macros to create unique symbols for the generated code.<pre></pre><br/></td>
</tr>
 <tr>
<td>177</td> <td><b>get</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Retrieves the value of the symbol identified by the argument expression.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>178</td> <td><b>get-args</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Retrieves a vector containing the arguments to the current function. This is typically used when creating error messages in pattern defaults.<br><br><pre>Examples:






</pre><br/></td>
</tr>
 <tr>
<td>179</td> <td><b>Get-Assoc</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function allows you to retrieve tagged data from an arbitrary object. For example, if you tagged the number 1 with a message as follows: you could then retrieve it with<br><br><pre>

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>180</td> <td><b>get-dynamic</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function retrieves the ^BraidVariable object associated with the argument symbol looking up the dynamic (runtime) callstack. This is particularly useful in the debugger.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>181</td> <td><b>get-env</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  This function gets the named environment variable. The &#39;-scope:&#39; option allows variables to be retrieved at either machine or user scope as well at process scope (the default).<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>182</td> <td><b>Get-FileHash</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;Get-FileHash&#39; function computes the MD5 hash for the specified file and then returns a vector of the form:<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>183</td> <td><b>getfunc</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;getfunc&#39; function will return a function object corresponding to the object passed in. This includes returning function objects for regular expressions, dictionaries and vectors. If the optional &#39;-caller&#39; switch is specified, the function will be resolved in the caller&#39;s dynamic scope rather than the current scope.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>184</td> <td><b>get-help-text</b></td> <td>braidhelp.tl</td> <td>Syntax:<br/><br/>  Get the associated help text for this item<pre></pre><br/></td>
</tr>
 <tr>
<td>185</td> <td><b>getmacro</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Get the macro associated with the argument symbol. If the argument is null then the entire table is returned.<pre></pre><br/></td>
</tr>
 <tr>
<td>186</td> <td><b>Get-Method</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>187</td> <td><b>get-min</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Find and return the n smallest items from a list.<pre></pre><br/></td>
</tr>
 <tr>
<td>188</td> <td><b>get-prop</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Get the named property from each of the elements in the argument list. For exampple: which returns a list of the values of the &#39;length&#39; field.<br><br> (Note: probably don&#39;t need this since (... | map .prop | ...) works i.e. the member accessors can be used with map to get the same effect.<pre>
</pre><br/></td>
</tr>
 <tr>
<td>189</td> <td><b>get-symbol</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Gets the symbol associated with the argument string. This function is most useful in macros.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>190</td> <td><b>get-symbols</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns all of the symbols in the symbol table.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>191</td> <td><b>getvar</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Get the variable object corresponding to the argument symbol.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>192</td> <td><b>get-watch</b></td> <td>powershell</td> <td>Syntax:<br/><br/>  Returns a list of all of the watched scripts that were set up with &#39;add-watch&#39;.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>193</td> <td><b>gh</b></td> <td>powershell</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>194</td> <td><b>global</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Binds the variable identified by expression to the specified value in the global scope. Because the function takes an expression to evaluate rather than a symbol to look up, it can be used to do indirect lookups in the global variable table.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>195</td> <td><b>globalq</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Binds the variable identified by the symbol to the specified value in the global scope.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>196</td> <td><b>group</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;group&#39; function groups members of a collection together in a dictionary by the value returned by the &lt;byFunction&gt;. Once the groups have been created, the &lt;processGroupFn&gt; is applied to each group. This function can be used to do things like rrplace the group with the count of group elements or compute the sum of a property on an element.<br><br><pre>Examples:




</pre><br/></td>
</tr>
 <tr>
<td>197</td> <td><b>head</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;head&#39; function returns the first item from a sequence, or the item itself if it&#39;s an atom.  (head is an alias for car.) If the argument is a string, the first &#39;word&#39; is returned i.e. all of the text up to the first whitespace character.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>198</td> <td><b>help</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Gets help information about commands. The first argument is unevaluated.<pre></pre><br/></td>
</tr>
 <tr>
<td>199</td> <td><b>hex</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Function to take numeric arguments and turn them into hex strings. Normally the strings are prefixed with &#39;0x&#39; but if -noprefix is specified, then the &#39;0x&#39; prefix will be omitted. If a single value is converted, then it&#39;s returned a a string. If more than one value is converted, then the results are aggregated into a vector.<pre></pre><br/></td>
</tr>
 <tr>
<td>200</td> <td><b>html/b</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Bold tag<pre></pre><br/></td>
</tr>
 <tr>
<td>201</td> <td><b>html/doc</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Generate an HTML document<pre></pre><br/></td>
</tr>
 <tr>
<td>202</td> <td><b>html/em</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Emphasis tag<pre></pre><br/></td>
</tr>
 <tr>
<td>203</td> <td><b>html/encode</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>204</td> <td><b>html/extractLinks</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  A function to extract all of the links in a piece of HTML text. Currently it doesn&#39;t distinguish between &quot; and \&#39;. It also doesn&#39;t handle relative links because it doesn&#39;t have the original URL.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>205</td> <td><b>html/form</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Insert a form into the html document.<pre></pre><br/></td>
</tr>
 <tr>
<td>206</td> <td><b>html/h1</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Generate a header 1 tag.<pre></pre><br/></td>
</tr>
 <tr>
<td>207</td> <td><b>html/h2</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Generate a header 2 tag.<pre></pre><br/></td>
</tr>
 <tr>
<td>208</td> <td><b>html/h3</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Generate a header 3 tag.<pre></pre><br/></td>
</tr>
 <tr>
<td>209</td> <td><b>html/i</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Italics tag<pre></pre><br/></td>
</tr>
 <tr>
<td>210</td> <td><b>html/input</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Insert an input element into the document.<pre></pre><br/></td>
</tr>
 <tr>
<td>211</td> <td><b>html/p</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Generate a paragraph tag<pre></pre><br/></td>
</tr>
 <tr>
<td>212</td> <td><b>html/string</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Strong tag<pre></pre><br/></td>
</tr>
 <tr>
<td>213</td> <td><b>html/style</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Insert an HTML CSS style string.<pre></pre><br/></td>
</tr>
 <tr>
<td>214</td> <td><b>html/table</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Generate a table<pre></pre><br/></td>
</tr>
 <tr>
<td>215</td> <td><b>html/td</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Generate a table data element.<pre></pre><br/></td>
</tr>
 <tr>
<td>216</td> <td><b>html/th</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Generate a table header element<pre></pre><br/></td>
</tr>
 <tr>
<td>217</td> <td><b>html/title</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Insert the document title.<pre></pre><br/></td>
</tr>
 <tr>
<td>218</td> <td><b>html/tr</b></td> <td>htmlutils.tl</td> <td>Syntax:<br/><br/>  Generate a table row<pre></pre><br/></td>
</tr>
 <tr>
<td>219</td> <td><b>id</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;id&#39; is the &#39;identity function&#39; and simply returns it&#39;s arguments unmodified. If multiple arguments are specified then a collection is returned. If only a single value is provided, then it will be returned as scalar.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>220</td> <td><b>if</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;if&#39; function does branching, taking one (if clause) or two (if and else) clauses.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>221</td> <td><b>ifmap</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;ifmap&#39; special form can be used when processing data in a pipeline. The first argument must be a list to process. The second argument is the conditional expression. The third and optional fourth arguments are the &#39;if part&#39; and &#39;else part&#39; which will be evaluated based on the result of the conditional expression. To provide accesss to the current pipeline object, &#39;ifmap&#39; binds that value to the variable &#39;it&#39; in the current scope.<br><br>    (range 10 | ifmap (% it 2) &quot;odd&quot; &quot;even&quot;)<br><br><pre>Examples:</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>222</td> <td><b>if-not</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>223</td> <td><b>ilist?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if the argument is of type ^System.Collections.IList.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>224</td> <td><b>in?</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Returns true if the argument list contains the specified value or matches the lambda. Does a shallow search. The in? function is the same as the contains? function except the arguments are reversed.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>225</td> <td><b>incr</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Increment a variable by the desired amount and returns the result. If no increment is specified, then 1 is used. This function can only be used for variables containing integral values (e.g. ^int or ^long)<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>226</td> <td><b>info</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function prints an informational message to the console in yellow. All of the arguments are turned into strings then joined with a single space between each string.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>227</td> <td><b>insert-string</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Inserts a substring into a string at the specified location. If the specified location is negative, it will be treated as the offset from the end of the string instead of from the beginning.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>228</td> <td><b>intersect</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Computes the intersection of two collections and returns the result as a vector.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>229</td> <td><b>Invoke-Method</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>230</td> <td><b>is?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Checks to see if the argument object is of the specified type.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>231</td> <td><b>isnot?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Checks to see if the argument object is not of the specified type.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>232</td> <td><b>isPrime</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Simple function to determine if a number is prime.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>233</td> <td><b>iterator</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The iterator function is a way to produce a (possibly) infinite sequence of values. Each new value in the sequence is computed by taking the current value and passing it to the argument &lt;function&gt;. The result of evaluating that function becomes the new current value. Instead of an array or list, invoking iterator returns a .Net ^IEnumerable. Consumers can then get the enumerator and iterate over that enumerator. If no &#39;max&#39; is provided, the enumerator will produce new values forever on until the consumer stops requesting values. If &#39;max&#39; is specified, values will be produced until &#39;max&#39; is reached.<br><br> (Note: &#39;unfold&#39; is an alias for &#39;iterator&#39;.)<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>234</td> <td><b>iterfib</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Compute the nth element in the Fibonacci sequence. This is computed lazily using the &#39;unfold&#39; function.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>235</td> <td><b>join</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;join&#39; function stringizes the elements of the argument collection then joins them into a single string separated by an optional separator string. If no separator string is provided, &#39;join&#39; will use a single space.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>236</td> <td><b>keyword</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Gets or creates a keyword object using the name string. If the keyword already exists, the existing object is returned otherwise a new keyword is created atomically.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>237</td> <td><b>keyword?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;keyword?&#39; function returns true if its argument is a keyword literal.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>238</td> <td><b>lambda</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>239</td> <td><b>lambda?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  A predicate function that returns true if the argument object is a lambda function.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>240</td> <td><b>last</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;last&#39; function returns a number of items from the end of a list or vector. The number of items specified is optional and, if not specified, defaults to 1. If more items are request than are available in the collecion, as many items as available are returned. If the argument is not an enumerable (i.e. not a scalar), then &#39;last&#39; will simply return the iten as is. If a single item is to be returned, it is returned as a scalar rather than as a vector of 1 element.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>241</td> <td><b>last-node</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Returns the last node in a list. Not to be confused with the &#39;last&#39; function which returns the last *value* in a list. In otherwords, &#39;last-node&#39; returns the &#39;cdr&#39; of the last nde, instead of the last car.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>242</td> <td><b>lazy-each</b></td> <td></td> <td>Syntax:<br/><br/>  A macro to support &#39;lazy each&#39; functionality.<pre></pre><br/></td>
</tr>
 <tr>
<td>243</td> <td><b>lazy-filter</b></td> <td>built-in</td> <td>Syntax:<br/><br/> Filters the input collection based on the results of evaluating the predicate function on each item. The predicate can be a lambda literal, a named function, a member accessor, a type literal, a regular expression or a dictionary literal. If a dictionary literal is provided, &#39;lazy-filter&#39; will use property pattern matching as the filter criteria. The sense of the comparison can be changed with the &#39;-not&#39; flag. The &#39;lazy-&#39; variant returns an enumerable instead of a collection. Individual values can then be pulled from the enumerable as needed thus only evaluating as much as is necessary.  Either of the forms can use &#39;break&#39; in the predicate function to terminate the search at the current item. You can also use &#39;continue&#39; to skip over the current item in the list and keep searching.<br><br> <pre>Examples:








</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>244</td> <td><b>lazy-flatmap</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;lazy-flatmap&#39; function is usually used in pipelines to process items in the pipeline.It takes a list of values and a function to apply to each value as in: - (lazy-flatmap &lt;list&gt; &lt;function&gt;) or (&lt;list&gt; | lazy-flatmap &lt;function&gt;) Functions can either be predefined functions, property functions or lambdas. As opposed to the map function, &#39;lazy-flatmap&#39; flattens its result so if the function returns a list, that list will be stiched into the result list rather than appearing as a discrete list. The distinction between &#39;flatmap&#39; and &#39;lazy-flatmap&#39; is that &#39;flatmap&#39; returns the entire result collection whereas &#39;lazy-flatmap&#39; returns an enumerable immediately and te values can be pulled out as needed.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>245</td> <td><b>lazy-flatten</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;lazy-flatten&#39; function lazily flattens all of its arguments into a single collection. On execution, it returns an ^IEnumerable immediately. Individual values can then be read from that enumerable as needed.<br><br> Example:<br><br><pre>

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>246</td> <td><b>lazy-map</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;lazy-map&#39; function is usually used in pipelines to lazily process items in the pipeline. It takes a collection of values plus a transformation function to apply to each value in the input collection e.g. and returns a lazy enumerable which will compute result items one at a time (lazy evaluation). Transformation functions can either be predefined functions, member accessors or lambdas.<br><br> <pre>Examples:





</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>247</td> <td><b>lazy-sort</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function sorts a sequence of values. By default, it sorts in ascending order but the &#39;-descending&#39; flag changes this to descending order. You can also specify a &#39;keyFunction&#39; that will be used to select the value to sort on. You can use the &#39;lazy-sort&#39; varient to pull values as needed.<br><br><pre>Examples:



</pre><br/></td>
</tr>
 <tr>
<td>248</td> <td><b>lc</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Count the lines in the argument files.<pre></pre><br/></td>
</tr>
 <tr>
<td>249</td> <td><b>leap-year?</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  True if the passed argument is a leap year.<pre></pre><br/></td>
</tr>
 <tr>
<td>250</td> <td><b>length</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns the length of a collection. If the argument is a scalar, then it returns 1. If it&#39;s null, then the function returns 0. This is an alias for the &#39;count&#39; function.<br><br> <pre>Examples:




</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>251</td> <td><b>let</b></td> <td>stdin</td> <td>Syntax:<br/><br/>  Sets the value of a variable in the current scope if a variable with that name exists or creates a new variable in the current scope if it doesn&#39;t. If the name takes the form of v1:v2:v3 then destructuring will be done and the parts assigned.<br><br><pre>

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>252</td> <td><b>let?</b></td> <td></td> <td>Syntax:<br/><br/>  Returns true if a destructuring assignment was successful, false otherwise.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>253</td> <td><b>let=</b></td> <td></td> <td>Syntax:<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>254</td> <td><b>let-default</b></td> <td>autoload.tl</td> <td>Syntax<br/><br/>  This special form sets the value of the identified variable if the variable is unbound or empty or constrains it if it is bound.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>255</td> <td><b>list</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns a list composed of its evaluated arguments.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>256</td> <td><b>list/all</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Applies the argument function to each element of the list. If the function evaluates to true for all elements, then this function returns true.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>257</td> <td><b>list/any</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Applies the argument function to each element of the list. If the function evaluates to true for any of the elements, then this function returns true.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>258</td> <td><b>list/monotonic</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Returns true if the members of the argument collection increase monotonically in size, If the &#39;-descending&#39; flag is specified, it will return true if the list is decreasing monotonically in size. The expression (list/monotonic [1 2 3]) is effectively equivalent to (&lt;= 1 2 3).<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>259</td> <td><b>list/partition</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>260</td> <td><b>list/split</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;list/split&#39; function splits a list into two pieces based on a either a provided value or a predicate function. If a value is specified the list is split at the first occurance of that item in the list. Note that the value to split on is not included in either result list and subsequent instances are not treated specially. Also note that if the item is not found an empty second list is returned.<br><br> If a predicate function is specified, elements for which the function is true are placed in the first result list and the rest are placed in the second result list.<br><br><pre>Examples:


</pre><br/></td>
</tr>
 <tr>
<td>261</td> <td><b>list/wrapprint</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>262</td> <td><b>list?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if the argument object is a list.<br><br><pre>Examples:


</pre><br/></td>
</tr>
 <tr>
<td>263</td> <td><b>list-add</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>264</td> <td><b>load</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Loads a braid file into the current scope (like PowerShell&#39;s &#39;dot sourcing&#39;.)<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>265</td> <td><b>loaded-files</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Find all of the loaded source files.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>266</td> <td><b>loaded-functions</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Find the functions loaded from the file matching the argument pattern.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>267</td> <td><b>loaded-types</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Find all of the Braid-based types that have been loaded.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>268</td> <td><b>log</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Compute the log of two values e.g. (log n m)<pre></pre><br/></td>
</tr>
 <tr>
<td>269</td> <td><b>loop</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>270</td> <td><b>map</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;map&#39; function is usually used in pipelines to process items in the pipeline. It takes a collection of values and a function to apply to each value as in: (map &lt;collection&gt; &lt;function&gt;) or: (&lt;list&gt; | map &lt;function&gt;) Functions can either be predefined functions, property functions or lambdas. The function is applied to each inbound element, returning the new element to the output vector.<br><br> <pre>Examples:




</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>271</td> <td><b>mapcat</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  For each argument collection, map a function onto the elements of the collection then concatenate the results into a single flat collection.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>272</td> <td><b>map-parallel</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;map-parallel&#39; function is used in pipelines like &#39;map&#39; to the process items in the pipeline.  It takes a list of values and a function to apply to each value Functions can either be predefined functions, property functions or lambdas. The difference betweenthis function and regular &#39;map&#39; is that this function runs it&#39;s lambda as a Task. In otherwords,the work for all pipeline items is done concurrently (subject to processor limitations). As a consequence, the lambda is executed in an isolated space that starts with a snapshot of the caller&#39;s space but, because it&#39;s just a copy, changes the function makes are not reflected in the caller&#39;s environment. Using this function over &#39;map&#39; can make your program run faster but be aware that the operation of creating a task is fairly expensive so if your lambda is trivial, &#39;map-parallel&#39; is probably not the best choice.<br><br> <pre>Examples:




</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>273</td> <td><b>matchp</b></td> <td></td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>274</td> <td><b>max</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Return the max of two items.<pre></pre><br/></td>
</tr>
 <tr>
<td>275</td> <td><b>max-list</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;max-list&#39; function returns the maximum-valued element from a sequence. An optional &#39;accessor&#39; function can be specified which provides the value of the property to be compared. Note that &#39;max-list&#39; returns the original value from the list, not the value returned from the accessor function. The accessor function is only used in comparisons and is never returned. If a scalar value is passed instead of a sequence, that value will simply be returned and no error will be raised.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>276</td> <td><b>max-list-index</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Find the first index of the maximum element in a list.<pre></pre><br/></td>
</tr>
 <tr>
<td>277</td> <td><b>median</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Compute the median value of a list of numbers.<pre></pre><br/></td>
</tr>
 <tr>
<td>278</td> <td><b>members-of</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  By default, the &#39;members-of&#39; function displays all of the public members on a type. This function has one optional positional parameter: you can specify a regular expression used to filter the members. If &#39;members-of&#39; is applied to an instance rather than a type, it will get the type of the argument object and use that for the type to examine.<br><br> Switches:<br><br> -raw By default &#39;members-of&#39; returns the memberinfo as string &#39;signatures&#39; however if &#39;-raw&#39; is specified, the raw MemberInfo object will be returned.<br><br> -private If -private is specified, then all members, both public and private will be returned.<br><br> -all Normally the getter/setter methods for properties are filtered out however if -all is specified, no filtering is done.<br><br> <pre>Examples:




</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>279</td> <td><b>memoize</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  This function wraps a single argument function in a memoization closure by doing (let fib (memoize fib)) which replaces the current &#39;fib&#39; binding in the variable table with a memoized version.  A memoized function will remember each input/output pair and return the result if it has already been calculated. This makes the naive recursive fib function many time faster.<br><br><pre>Examples:</pre><br/></td>
</tr>
 <tr>
<td>280</td> <td><b>merge-list</b></td> <td>stdin</td> <td>Syntax:<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>281</td> <td><b>merge-sort</b></td> <td>stdin</td> <td>Syntax:<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>282</td> <td><b>min</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Return the smaller of two items.<pre></pre><br/></td>
</tr>
 <tr>
<td>283</td> <td><b>min-list</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;min-list&#39; function returns the minimum-valued element from a sequence. An optional &#39;accessor&#39; function can be specified which provides the value of the property to be compared. Note that &#39;min-list&#39; returns the original value from the list. The accessor function is only used in comparisons and is never returned. If a scalar value is passed instead of a sequence, that value will simply be returned and no error will be raised.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>284</td> <td><b>min-list-index</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Find the first index of the minimum element in a list.<pre></pre><br/></td>
</tr>
 <tr>
<td>285</td> <td><b>modified</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;modified&#39; function returns a list of the nanes of the modified files in the current Git workspace.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>286</td> <td><b>my</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Changes directory relative to the user&#39;s document directory<pre></pre><br/></td>
</tr>
 <tr>
<td>287</td> <td><b>nconc</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;nconc&#39; function adds its first argument to the end of the vector provided in the second argument then returns the modified vector. If the first argument is also a vector, it is added as a single element to the end of the second argument. If the second argument is null, then a new empty vector will be created first then the first argument will be added to that new vector.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>288</td> <td><b>neg</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Inverts the sign on a number.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>289</td> <td><b>neg?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if the argument number is negative.<br><br><pre>Examples:


</pre><br/></td>
</tr>
 <tr>
<td>290</td> <td><b>new</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Create a new instance of a class passing arguments as appropriate. If &#39;-properties:&#39; is specified along with a dictionary argument, the properties corresponding to each pair in the dictionary will be set to the dictionary value.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>291</td> <td><b>new-array</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;new-array&#39; function returns an initialized array with the specified type and size.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>292</td> <td><b>new-dict</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Create a new generic dictionary with the keys and values constrained to the specified types. The type can be followed by an optional list of keys and values that will be used to populate the dictionary.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>293</td> <td><b>new-stopwatch</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;new-stopwatch&#39; function returns a .NET ^System.Diagnostics.Stopwatch object which can be used to time operations. The returned object has members .start, .stop, .elapsed, .reset.<br><br> <pre>Examples:




</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>294</td> <td><b>new-vector</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;new-vector&#39; function constructs new vector objects. If no arguments are provided, an empty vector wil be constructed. If arguments are provided, they will be added to the new vector.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>295</td> <td><b>nil?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if the argument object is null. &#39;null?&#39; and &#39;nil?&#39; are aliases.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>296</td> <td><b>none?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;none?&#39; function returns true if its argument has a value i.e. it is not null, &quot;&quot; or [].<br><br> <pre>Examples:





</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>297</td> <td><b>normalize-string</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Concatenates all arguments into a string, reduces multiple whitespace chars to a single space then returns the result.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>298</td> <td><b>not</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Is the boolean complement function. If the argument object is interpreted as true, then the function returns false and vise versa. Since all objects have a boolean interpretation this function can be applied to anything.<pre></pre><br/></td>
</tr>
 <tr>
<td>299</td> <td><b>notnil?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if the argument object is not null. &#39;notnull?&#39; and &#39;notnil?&#39; are aliases.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>300</td> <td><b>notnull?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if the argument object is not null. &#39;notnull?&#39; and &#39;notnil?&#39; are aliases.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>301</td> <td><b>null?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if the argument object is null. &#39;null?&#39; and &#39;nil?&#39; are aliases.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>302</td> <td><b>number?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if the argument object is any of the numeric types.<br><br><pre>Examples:



</pre><br/></td>
</tr>
 <tr>
<td>303</td> <td><b>odd?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;odd?&#39; function returns true if its argument is an odd number.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>304</td> <td><b>or</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;or&#39; function returns a true value if any of its arguments evaluate to a true value. Lazy evaluation is used so the first argument that evaluates to true halts execution and that value is returned.<br><br>  AutoCurry: true<pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>305</td> <td><b>or$</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;or$&#39; (&#39;or compose&#39;) function takes a list of functions and returns a new function composed of the individual functions with the results or&#39;ed together. The argument to the outer function is passed to each of the inner functions. The results of these functions are or&#39;ed together to produce a final result.<br><br> <br><br><pre>Examples:






</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>306</td> <td><b>out-list</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  A function to format the argument object using PowerShell&#39;s Format-List. It returns a list of strings.<br><br><pre>Examples:


</pre><br/></td>
</tr>
 <tr>
<td>307</td> <td><b>pair?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if the argument is a list (dotted-pair).<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>308</td> <td><b>parse-file</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>309</td> <td><b>parse-text</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Parses a string into s-Expressions. This can be useful to see what a macro expands to.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>310</td> <td><b>partial</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;partial&#39; function takes a function of n-arguments and returns a new function of n-1 arguments. The signature of the function is: (partial function value &amp;args) The first argument is the function to be curried, the second and remaining arguments will be passed to that function by default when the new function is applied. For example, consider the following definition: (let +1 (partial + 1)) This takes the plus function which takes 2 arguments and returns a new function &#39;+1&#39; which takes 1 argument. This new function can be applied as follows.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>311</td> <td><b>path</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Get the current value of the PATH environment variable.<pre></pre><br/></td>
</tr>
 <tr>
<td>312</td> <td><b>pdecr</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function decrements the value in the named variable, returning the original value. The value in the variable must be of an integral type.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>313</td> <td><b>permute</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Generate the all of the permutations of a sequence of items.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>314</td> <td><b>PID</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>315</td> <td><b>pincr</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Increment a variable by the desired amount, returning the original un-incremented value. If no increment is specified, the 1 is used. This function can only be used for variables containing integral values (e.g. ^int or ^long)<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>316</td> <td><b>pipe</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function implements the logic for the form (a | b | c) which is translated at compile time into (pipe a (b) (c)) There&#39;s not a lot of reason to use this function directly.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>317</td> <td><b>pos?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if the argument number is positive.<br><br><pre>Examples:


</pre><br/></td>
</tr>
 <tr>
<td>318</td> <td><b>print</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Print a string made out of the tostring&#39;s of each of the argument to the console without adding a newline at the end.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>319</td> <td><b>printat</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Print a string at the specified location, optionally specifying the foreground and background colors.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>320</td> <td><b>println</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Print a string made out of the tostring&#39;s of each of the argument to the console adding a newline at the end.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>321</td> <td><b>println-color</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The first two arguments are treated as the colors to uese and the remaining arguments are contcatenated into a string to be displayed. Spaces are placed between each value in the resulting string. Cooersion on the color arguments is used so they can be specified as strings rather than ^System.ConsoleColor values.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>322</td> <td><b>prod</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Compute the product of the numbers in the argument list.<pre></pre><br/></td>
</tr>
 <tr>
<td>323</td> <td><b>project</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  This function &quot;projects&quot; a subset of the properties on an object (or elements of a dictionary) onto a new anonymously-typed object. The anonymous types are generated on an on-demand basis.<br><br> If the first object is a Dictionary, rather than enumerating the object, a new anonymously-typed object is returned where the object properties correspond to the dictionary keys.<br><br> Note: Anonymous types are unified based on the type&#39;s property names (but not types). A dictionary of the currently defined anonymous types is available in the variable *anonymous-types*. So they&#39;re not really anonymous.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>324</td> <td><b>psvar</b></td> <td>powershell</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>325</td> <td><b>pwd</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>326</td> <td><b>qsort</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Recursive &#39;quicksort&#39; (after the Haskell equivalent). Uses list/split to avoid double filtering.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>327</td> <td><b>qstr</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Concatenates all unevaluated arguments into a string. Unquoted elements are evaluated.<br><br> returns the string<br><br><pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>328</td> <td><b>quit</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Quits the current braid session. If in a nested (debug) session, this will return you to the parent session.<pre></pre><br/></td>
</tr>
 <tr>
<td>329</td> <td><b>quote?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;quote?&#39; function returns true if its argument is quoted.<br><br> <pre>Examples:</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>330</td> <td><b>random</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function generates a sequence of random numbers. If a single argument is specified, that argument is used as the number of numbers to generate, ranging from 0 to the number. If two arguments are specified, they represent the min and max of the range and the difference (max-min) is the number of numbers to generate. Finally if three numbers are specified, the first is the number of numbers to generate and the second and third represent the range into which the numbers should be generated.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>331</td> <td><b>range</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Generates a range of numbers. If omly one number is provided, the range will be from 1 to that number. If two numbers are provided, they represent the bounds of the range. If the first number is larger than the second, the range will be counted down.  You can also specify a third argument  the increment, which sets the step count.  Note - stepping is always done so the larger number will converge with the smaller.<br><br><pre>Examples:


</pre><br/></td>
</tr>
 <tr>
<td>332</td> <td><b>re/match</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Match a single string against a regular expression.<pre></pre><br/></td>
</tr>
 <tr>
<td>333</td> <td><b>re/match-all</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Return all of the elements from a list that match the argument regex.<pre></pre><br/></td>
</tr>
 <tr>
<td>334</td> <td><b>re/not-match</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Match a single string that doesn&#39;t match a regular expression.<pre></pre><br/></td>
</tr>
 <tr>
<td>335</td> <td><b>re/not-match-all</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Return all of the elements from a list that don&#39;t match the argument regex.<pre></pre><br/></td>
</tr>
 <tr>
<td>336</td> <td><b>re/replace</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Replace all occurances of a substring in a string with an optional replacement string. If the replacement string is not provided then the empty string will be used.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>337</td> <td><b>re/replace-all</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Process a list of strings, replacing all occurances of the target string in each list item with the provided replacement string. If no replacement string has been provided, the empty string will be used.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>338</td> <td><b>re/split</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;split&#39; function will split a string into a number of pieces based on a provided regular expression or using the default expression which is #&quot; +&quot;. If the pattern is empty i.e. #&quot;&quot;, the string will be split into individual 1-character strings.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>339</td> <td><b>re/split-all</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Splits each string in the argument list, flattens the result then returns the new vector containing all of the individual strings. An optional regular expression can be provided to use during the splits. The default split pattern is 1 or more whitespaces.<pre></pre><br/></td>
</tr>
 <tr>
<td>340</td> <td><b>read-data</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Read binary data from a file.<pre></pre><br/></td>
</tr>
 <tr>
<td>341</td> <td><b>read-file</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function reads files line by line, returning a vector of lines. If a regular expression is specified then only lines matching that regular expression will be returned. You can also specify a lambda which will be invoked on each matched item and the result of the invocation will be returned. The lambda receives 2-4 arguments which are, in order: - the text of the matching line - an array of the regex submatches in the line - the number of the matching line - the name of the current file The &#39;read-file&#39; function takes one named parameter &#39;-not&#39; which changes the regex processing from match to not match.<br><br> <pre>Examples:





</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>342</td> <td><b>read-lines</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function reads files line by line, returning a vector of lines. If a regular expression is specified then only lines matching that regular expression will be returned. You can also specify a lambda which will be invoked on each matched item and the result of the invocation will be returned. The lambda receives 2-4 arguments which are, in order: - the text of the matching line - an array of the regex submatches in the line - the number of the matching line - the name of the current file The &#39;read-file&#39; function takes one named parameter &#39;-not&#39; which changes the regex processing from match to not match.<br><br> <pre>Examples:





</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>343</td> <td><b>read-text</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  This function reads all of the text in a file and returns it as a single string.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>344</td> <td><b>recur</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;recur&#39; function allows you to write tail-recursive programs in braid. When invoked, it transfers control to the nearest function or loop context. You can pass arguments to &#39;recur&#39; which must match the arity of the enclosing function.<br><br><pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>345</td> <td><b>recur-to</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;recur-to&#39; function allows you to write tail-recursive programs in Braid when you need to recur to a specific function. When invoked, it transfers control to the identified function context. You must pass arguments to &#39;recur-to&#39; with the same arity of the target function. Note: the target function is identified by the functions value, not its name.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>346</td> <td><b>reduce</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function iterates through a list applying the function to each of the items and accumulating a result. An optional seed value can be provided.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>347</td> <td><b>reduce-with-seed</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function iterates through a list applying the function to each of the items and accumulating a result. The accumulator is initialized with the seed value.<br><br>    (ls &#39;*.tl | reduce-with-seed (fn x y -&gt; (+ x (.length y))) 0)<br><br><pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>348</td> <td><b>remove-watch</b></td> <td>powershell</td> <td>Syntax:<br/><br/>  Removes a script watch that was set up with &#39;add-watch&#39;.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>349</td> <td><b>repeat</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Evaluates each of the clause arguments in sequence, repeating the evaluation the specified number of times. This function always returns null.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>350</td> <td><b>repeat-all</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Evaluates each of the clause arguments in sequence, repeating the evaluation the specified number of times. This function a vector of the results of evaluating the last clause from each iteration.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>351</td> <td><b>resolve</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The resolve function waits for all argument tasks to complete and then returns a collection containing the values returned by the tasks. Note that even in the simple case of a single task, the result will still be returned as a collection of one element. &#39;resolve&#39; is an alias for &#39;await&#39;.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>352</td> <td><b>rest</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;rest&#39; function skips the first item in a sequence and returns the rest, or it returns the item itself if it&#39;s an atom. Note that for sequences, cdr always returns an s_Expr regardless of the original type of the sequence. This is for performance reasons. Getting the cdr of a Vector is slow. Getting the cdr of an s_Expr, is very fast. (Commands tail and rest are aliases for cdr.)<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>353</td> <td><b>return</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns from a function returning a value. Null is returned if the value is not specified.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>354</td> <td><b>reverse</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Reverses a list or vector, returning a new reversed list.<br><br><pre>Examples:


</pre><br/></td>
</tr>
 <tr>
<td>355</td> <td><b>rfact</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Computes the factorial of the argument recursively. Big integers are used.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>356</td> <td><b>roll</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Roll the argument integer left by the specified number of bits<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>357</td> <td><b>rolr</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Roll the argument integer right by the specified number of bits<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>358</td> <td><b>round</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Round the argument value. An option number of places to round to can be specified. By default, the number is rounded with 0 decimal places.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>359</td> <td><b>scalarize</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  If the argument is a collection of 1 element, extract it and return it as a scalar<pre></pre><br/></td>
</tr>
 <tr>
<td>360</td> <td><b>scs</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>361</td> <td><b>second</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Returns the second item in a sequence<pre></pre><br/></td>
</tr>
 <tr>
<td>362</td> <td><b>Select-Type</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Look for types based on a regular expression.<pre></pre><br/></td>
</tr>
 <tr>
<td>363</td> <td><b>seq?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;seq?&#39; function returns true if it&#39;s argument is a sequence type (list or vector).<br><br><pre>Examples:


</pre><br/></td>
</tr>
 <tr>
<td>364</td> <td><b>set</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Sets the value of the variable named by the result of evaluating &lt;varNameExpression&gt;. This allows you to do indirect sets of variables.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>365</td> <td><b>Set-Assoc</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function allows you to associate tagged data with an arbitrary object. For example, you could tag the number 1 with a message as follows: and then retrieve it with<br><br><pre>

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>366</td> <td><b>set-env</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  This function sets an environment variable. The &#39;-scope:&#39; option allows variables to be set at either machine or user scope as well at process scope (the default).<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>367</td> <td><b>setq</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Set the value of the named variable if a variable with that name already exists or create a new variable in the current scope if it doesn&#39;t.<br><br> Note: If the name takes the form &#39;v1:v2:v3&#39; then destructuring will be done and the parts of the argument collection will be assigned to the variables.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>368</td> <td><b>shell</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;shell&#39; function concatenates its arguments and then runs the resulting string as a PowerShell script.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>369</td> <td><b>shiftl</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Shifts a value the specified number of bits to the left.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>370</td> <td><b>shiftr</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Shifts a value the specified number of bits to the right.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>371</td> <td><b>show-callstack</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function dumps all of the current bindings in the variable table across all of the dynamic scopes. It takes no arguments and any provided arguments will be ignored. &#39;scs&#39; is an alias for show-callstack.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>372</td> <td><b>show-symbols</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function returns all of the symbols currently in the symbol table. It takes no arguments and any provided arguments will be ignored.<pre></pre><br/></td>
</tr>
 <tr>
<td>373</td> <td><b>sieve</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Find all primes in the range 1 to n using a &#39;Sieve of Eratosthenes&#39;-like algorithm.<pre></pre><br/></td>
</tr>
 <tr>
<td>374</td> <td><b>sign</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;sign&#39; function returns the &#39;sign&#39; of its argument: -1 if negative; 1 if it&#39;s positive. An error will be returned if the argument is not numeric.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>375</td> <td><b>sin</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Compute the sine of a number<pre></pre><br/></td>
</tr>
 <tr>
<td>376</td> <td><b>skip</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function skips the first &lt;number&gt; items in collection &lt;coll&gt;. If the collection is too short, then an empty collection will be returned. If &lt;coll&gt; is an ^IList, skip will return an immutable ^Slice addressing the remainder of &lt;coll&gt;. If &lt;coll&gt; is an ^IEnumerable, skip will return a lazy enumerable for the rest of &lt;coll&gt;.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>377</td> <td><b>skip-while</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;skip-while&#39; function skips items in a list while the provided predicate evaluates to true. For example &#39;(range 100 | skip-while (fn n -&gt; (&lt; n 90)))&#39; will skip the numbers 1-89 returning 90-100.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>378</td> <td><b>sleep</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  This function sleeps for the specified number of milliseconds. Note that it sleeps in chunks so it can be interrupted with ctrl-C.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>379</td> <td><b>slice</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;slice&#39; function returns a ^Slice of an indexable collection (e.g a ^Vector or ^Array). A ^Slice object is essentially a &quot;window&quot; into the underlying collection. Slice takes two arguments - the offset into the collection to index from and the length of the collection. Note that slices are immutable which means that you can&#39;t change the underlying collection using the slice object. On the other hand, changes to the underlying collection will be reflected in the slice.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>380</td> <td><b>sls</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  A function to print directory lstings in columns<pre></pre><br/></td>
</tr>
 <tr>
<td>381</td> <td><b>smaller</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function returns the smallest member of its argument list.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>382</td> <td><b>some?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;some?&#39; function returns true if its argument has a value i.e. it is not null, &quot;&quot; or [].<br><br> <pre>Examples:





</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>383</td> <td><b>sort</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function sorts a sequence of values. By default, it sorts in ascending order but the &#39;-descending&#39; flag changes this to descending order. You can also specify a &#39;keyFunction&#39; that will be used to select the value to sort on. You can use the &#39;lazy-sort&#39; varient to pull values as needed.<br><br><pre>Examples:



</pre><br/></td>
</tr>
 <tr>
<td>384</td> <td><b>splice</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Splices two lists together so that list2 becomes the &#39;cdr&#39; of list1, mutating list 1.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>385</td> <td><b>sqr</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Squares a number.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>386</td> <td><b>sqrt</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Computes the sqrt of the argument value.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>387</td> <td><b>str</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;str&#39; function converts its arguments to strings the concatenates the individual strings with no intervening spaces. This function is similar to join but is varargs and doesn&#39;t allow a seperator.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>388</td> <td><b>str/reverse</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Turns it&#39;s argument into a string then reverses that string.<pre></pre><br/></td>
</tr>
 <tr>
<td>389</td> <td><b>str/startsWith</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The &#39;str/startswith&#39; function returns true if that argument string starts with the string fragment in the second argument. The comparison is done case-insensitively by default. Use -case to specify case-sensitive comparisons.<br><br><pre>Examples:



</pre><br/></td>
</tr>
 <tr>
<td>390</td> <td><b>str/truncate</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Truncate a string for printing to the console or a file. This function returns a single string that will fit on one line on the console.<pre></pre><br/></td>
</tr>
 <tr>
<td>391</td> <td><b>string?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;string?&#39; function returns true if it&#39;s argument is a string.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>392</td> <td><b>Str-To-Lower</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Makes the first character in a string a lowercase letter.<pre></pre><br/></td>
</tr>
 <tr>
<td>393</td> <td><b>Str-To-Lower-All</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Make all the characters in a string uppercase.<pre></pre><br/></td>
</tr>
 <tr>
<td>394</td> <td><b>Str-To-Upper</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Make the first character in a string into an uppercase letter.<pre></pre><br/></td>
</tr>
 <tr>
<td>395</td> <td><b>Str-To-Upper-All</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Make all the characters in a string uppercase.<pre></pre><br/></td>
</tr>
 <tr>
<td>396</td> <td><b>subseq</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Return a subsequence of a Seq. The sequence starts at &#39;start&#39;. If &#39;end&#39; is not specified, the rest of the sequence is returned. If &#39;end&#39; is provided, the sequence that is returned includes the item at the &#39;end&#39; position.<pre></pre><br/></td>
</tr>
 <tr>
<td>397</td> <td><b>sum</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Sum all of the values in the argument list. An optional accessor function can be provided to select the property on the input objects to sum.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>398</td> <td><b>swap</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function swaps the values in variables or alternately, the values of vectors stored in variables. In both cases, a comparer function can be provided. This function is evaluated with the two values and the result is true, the values are swapped.<br><br><pre>Examples:




</pre><br/></td>
</tr>
 <tr>
<td>399</td> <td><b>symbol</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Gets or creates the named symbol. If the symbol exists, it is simply returned otherwise a new symbol is created atomically.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>400</td> <td><b>symbol?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if the argument object is a symbol.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>401</td> <td><b>tail</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;tail&#39; function skips the first item in a sequence and returns the rest, or it returns the item itself if it&#39;s an atom. Note that for sequences, cdr always returns an s_Expr regardless of the original type of the sequence. This is for performance reasons. Getting the cdr of a Vector is slow. Getting the cdr of an s_Expr, is very fast. (Commands tail and rest are aliases for cdr.)<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>402</td> <td><b>take</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Takes &lt;count&gt; objects from the front of the argument list. If the count specified is larger than the number of items in the list, the entire list is returned. Negative indexing is also supported. For example &#39;(take lst -1)&#39; returns all but the last element from &#39;lst&#39;. (Note: while negative indexing will work on an ^IEnumerable, it can be slow as it must count the number of elements to determine how many to take.) If an ^IList is passed, an immutable ^Slice of that ^IList will be returned.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>403</td> <td><b>take-after</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Takes items from a list after the specified item is found or the specified function returns true.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>404</td> <td><b>take-until</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Takes items from a list untils the specified item is found or the specified function returns true.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>405</td> <td><b>tan</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Compute the tangent of a number.<pre></pre><br/></td>
</tr>
 <tr>
<td>406</td> <td><b>task</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Starts a new background task using the .NET Task Parallel Library with the lambda as the ^Task procedure. An optional argument may be passed in though most things will be passed through the closure. Tasks can be composed with the subsequent task receiving the result of the previous task.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>407</td> <td><b>taskid</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Get the current Task id. In the main context, this will be null.<pre></pre><br/></td>
</tr>
 <tr>
<td>408</td> <td><b>thenSort</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function performs a secondary sort on the enumerator returned by &#39;sort&#39;. It can be applied multiple times to perform very complex sortings. Note that this is a lazy function and returns an IEnumerable.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>409</td> <td><b>third</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Returns the third item in a sequence<pre></pre><br/></td>
</tr>
 <tr>
<td>410</td> <td><b>throw</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Throws a generic exception with a custom message.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>411</td> <td><b>tid</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Get the managed thread ID of the current thread.<pre></pre><br/></td>
</tr>
 <tr>
<td>412</td> <td><b>time</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Times the duration of the execution of an expression. If the optional count is specified then the expression will be executed that number of times, then printing both the total and average times for all runs.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>413</td> <td><b>ToHash</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Convert a list of items into a dictionary where the keys are the items and the values are item counts. By default, case-insensitive string comparisons are used but you can specify case-sensitive comparisons with the &#39;-case&#39; flag.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>414</td> <td><b>tokenize-file</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Parses the contents of a file and returns the tokens it contains<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>415</td> <td><b>tokenize-text</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>416</td> <td><b>toSourceString</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Convert an object to a source-formatted string (i.e. escapes are included in the strings, etc.)<br><br><pre>Examples:


</pre><br/></td>
</tr>
 <tr>
<td>417</td> <td><b>tostring</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Converts its argument into a string.<br><br>  ee also: str<pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>418</td> <td><b>tostring-all</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Turn all of the elements in a list into individual strings.<pre></pre><br/></td>
</tr>
 <tr>
<td>419</td> <td><b>to-vector</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;to-vector&#39; function takes an enumerable value as an argument. If the argument is already a vector, it will be returned unchainged. All other types will be copied into a new vector.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>420</td> <td><b>trace</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Trace the execution of the interpreter. Tracing can be enabled globaly with (trace true) disable with (trace false). You can also trace the evaluation of an expression. If the &#39;-exceptions&#39; flag is specified, then runtime exceptions will trop you into a nested listener level (repl) where you can example and mutate the state of the system with functions like &#39;show-callstack&#39; and &#39;get-dynamic&#39;.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>421</td> <td><b>trampoline</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  A &#39;trampoline&#39; function for Braid. This takes a function of one argument that will either return a new function of no arguments or a value. If a function is returned, it&#39;s called it with no arguments. This is repeated until a non-function value is returned.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>422</td> <td><b>truncate-number</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Truncate a floating-point number returning an integer (^int).<pre></pre><br/></td>
</tr>
 <tr>
<td>423</td> <td><b>try</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function implements try/catch semantics. It executes all of the body expressions in order. If any of thoese expressions raises an exception, transfer is made to the -catch: expression where the exception is available as %0. Finally, before leaving the control of the function, if there was a -catch: expressions specified, it will be executed.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>424</td> <td><b>tuple</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Create and return an immutable tuple using the values of the arguments. A maximum of 5 arguments is supported.<br><br><pre>Examples:

</pre><br/></td>
</tr>
 <tr>
<td>425</td> <td><b>type-alias</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  If no arguments are provided, returns the current list of type aliases. If just the alias is provided the existing alias binding will be deleted. If both an alias and type are provided then the type alias will be created or updated if it already exists.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>426</td> <td><b>type-of</b></td> <td>built-in</td> <td>Syntax:<br/><br/> Returns the type of the argument object.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>427</td> <td><b>undef</b></td> <td>built-in</td> <td>Syntax:<br/><br/> Removes the binding to the specified symbol from the variable table.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>428</td> <td><b>undeftype</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;undeftype&#39; removes a typename from the type lookup table.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>429</td> <td><b>unfold</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  The iterator function is a way to produce a (possibly) infinite sequence of values. Each new value in the sequence is computed by taking the current value and passing it to the argument &lt;function&gt;. The result of evaluating that function becomes the new current value. Instead of an array or list, invoking iterator returns a .Net ^IEnumerable. Consumers can then get the enumerator and iterate over that enumerator. If no &#39;max&#39; is provided, the enumerator will produce new values forever on until the consumer stops requesting values. If &#39;max&#39; is specified, values will be produced until &#39;max&#39; is reached.<br><br> (Note: &#39;unfold&#39; is an alias for &#39;iterator&#39;.)<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>430</td> <td><b>union</b></td> <td>built-in</td> <td>Syntax:<br/><br/> Computes the union of the two argument sets.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>431</td> <td><b>unless</b></td> <td></td> <td>Syntax:<br/><br/>  A control structure that evaluates all of the body exprs if the cond expr evaluates to false. This is a macro that is implemented in terms of the &#39;if&#39; and &#39;do&#39; functions.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>432</td> <td><b>upDo</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;upDo&#39; function is similar to the &#39;eval&#39; function except it evaluates its argument in the caller&#39;s (parent) context. This function is typically used in special forms created with defspecial.<br><br> <pre>Examples:




</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>433</td> <td><b>upvar</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;upvar&#39; function allows you to bind a variable from the caller&#39;s scope onto a variable in the current (local) scope i.e. it binds a variable &#39;up&#39; one level. Once this binding is established, setting the local variable actually sets the variable in the caller&#39;s scope. When the binding is being established, if there is no variable corresponding to &lt;parentSymbol&gt; in the caller&#39;s context, a new variable will be created in the caller&#39;s context. This function is usually used in special forms defined with &#39;defspecial&#39;.<br><br> <pre>Examples:







</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>434</td> <td><b>using-assembly</b></td> <td></td> <td>Syntax:<br/><br/>  A macro for loading a .NET assembly at compile time.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>435</td> <td><b>using-module</b></td> <td></td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>436</td> <td><b>vars</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Function to print out the variables in the current scope. An optional regular expression can be specified to filter the results.<pre></pre><br/></td>
</tr>
 <tr>
<td>437</td> <td><b>vcons</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Inserts the first argument at the start of the second argument vector and returns the updated vector. This is similar to &#39;cons&#39; but &#39;cons&#39; returns a new list and &#39;vcons&#39; returns a mutated vector. Note - if the second argument is null, then a new vector will be created that contains the first argument.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>438</td> <td><b>vector</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;vector&#39; function constructs new vector objects. If no arguments are provided, an empty vector wil be constructed. If arguments are provided, they will be added to the new vector.<br><br> <pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>439</td> <td><b>vector?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  Returns true if the argument object is a vector.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>440</td> <td><b>vlet</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Sets the value of a variable in the current scope if a variable with that name exists or creates a new variable in the current scope if it doesn&#39;t. If the name takes the form of v1:v2:v3 then destructuring will be done and the parts assigned. The only difference between &#39;let&#39; and &#39;vlet&#39; is that &#39;vlet&#39; always returns null instead of the assigned value. This function is primarily intebder fot interactive use.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>441</td> <td><b>void</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function ignores its arguments and simply returns null. Casting to ^void has a similar effect.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>442</td> <td><b>walk-tree</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Walks a parsed tree applying an action to each subtree.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>443</td> <td><b>warn</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  This function prints a warning string to the console in magenta. All of the arguments are converted to strings then joined to a single string seperated by spaces then printed.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>444</td> <td><b>wf/button</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>445</td> <td><b>wf/button-stack</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/>  A function to create a vertical stack of menu buttons. The form size is adjusted to fit the content. Actions should be zero-arity functions (callbacks). A &#39;Quit&#39; button is automatically added to the bottom of the button stack.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>446</td> <td><b>wf/control</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/>  This is a &#39;generic&#39; function for creating WinForm controls. It allows you to create the control, set all of the properties bind events as well as creating child controls in a &#39;DSL&#39;. A simple example is as follows:  This example creates a simple form object, sets the text and color and then shows it. A more complex example is: This creates a form object containing one child control - a button - that prints &quot;hi there&quot; to the console when pressed. To display this form you would do:<br><br><pre>















</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>447</td> <td><b>wf/datagrid</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/>  Show the source data in a grid.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>448</td> <td><b>wf/editor</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/>  Form to display or edit text.<pre></pre><br/></td>
</tr>
 <tr>
<td>449</td> <td><b>wf/font</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/>  Creates a font object from the specified family and size.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>450</td> <td><b>wf/form</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>451</td> <td><b>wf/highlightEditBox</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/>  A function to text do highlighting in a RichTextBox<pre></pre><br/></td>
</tr>
 <tr>
<td>452</td> <td><b>wf/listbox</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/>  Function that displays a listbox of options from which the user must select 1 (or more) items.    (wf/listbox &quot;Choose a file&quot; -source: #(ls &#39;*.tl) -selectaction: #(gvim %0))    ; select and stop a process    (wf/listbox &quot;Processes&quot;<pre>Examples:


</pre><br/></td>
</tr>
 <tr>
<td>453</td> <td><b>wf/Menu</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/>  Create a menu with a specific list of items.<br><br><pre>Examples:





</pre><br/></td>
</tr>
 <tr>
<td>454</td> <td><b>wf/MenuItem</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/>  Create an individual item to add to a menu. The first argument is the name of the menu item to create and the second is the lambda that acts as the event handler for the menu item. The result of this function should be added to the items on the menu itself.<br><br> <pre>Examples:
</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>455</td> <td><b>wf/menustrip</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/>  Create a menu strip for a Windows form. The first argument is the form to add the menu strip to. The second argument is a list of menus to add to the menu strip.<br><br> <pre>Examples:








</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>456</td> <td><b>wf/messagebox</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/>  Shows a message box on the screen. The default button is OK but can also be OK, OKCancel, AbortRetryIgnore, YesNoCancel, YesNo or RetryCancel<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>457</td> <td><b>wf/next-color</b></td> <td>winforms.tl</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>458</td> <td><b>wf/point</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/>  Creates a new WinForms point object.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>459</td> <td><b>wf/QuestionBox</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/>  This function displays a question dialog box containing the question text and an input field for the user to enter their answer. The last &quot;owner&quot; parameter is optional but can be used to specify the parent form for the question box.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>460</td> <td><b>wf/show</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/>  A utility function to display a form.<pre></pre><br/></td>
</tr>
 <tr>
<td>461</td> <td><b>wf/size</b></td> <td>winforms.tl</td> <td>Syntax:<br/><br/>  Creates a WinForms size object.<br><br><pre>Examples:
</pre><br/></td>
</tr>
 <tr>
<td>462</td> <td><b>when</b></td> <td></td> <td>Syntax:<br/><br/>  A control structure that evaluates all of the body exprs if the cond expr evaluates to true. This is a macro that is implemented in terms of the &#39;if&#39; and &#39;do&#39; functions.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>463</td> <td><b>where</b></td> <td>built-in</td> <td>Syntax:<br/><br/> Filters the input collection based on the results of evaluating the predicate function on each item. The predicate can be a lambda literal, a named function, a member accessor, a type literal, a regular expression or a dictionary literal. If a dictionary literal is provided, &#39;where&#39; will use property pattern matching as the filter criteria. The sense of the comparison can be changed with the &#39;-not&#39; flag. The &#39;lazy-&#39; variant returns an enumerable instead of a collection. Individual values can then be pulled from the enumerable as needed thus only evaluating as much as is necessary.  Either of the forms can use &#39;break&#39; in the predicate function to terminate the search at the current item. You can also use &#39;continue&#39; to skip over the current item in the list and keep searching.<br><br> <pre>Examples:








</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>464</td> <td><b>where-defined</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Function to figure out where a function was defined (i.e. what source file.)<pre></pre><br/></td>
</tr>
 <tr>
<td>465</td> <td><b>while</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The basic while loop. It loops evaluating the bodyExprs in sequence until the condExpre evaluates to false following Braid&#39;s truthiness rules.<br><br> <pre>Examples:









</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>466</td> <td><b>while-all</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>467</td> <td><b>with</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>468</td> <td><b>write-data</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Write binary data to a file.<pre></pre><br/></td>
</tr>
 <tr>
<td>469</td> <td><b>write-lines</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  write an array of strings to a file.<pre></pre><br/></td>
</tr>
 <tr>
<td>470</td> <td><b>write-source</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Write an object formatted as Braid/JSON source to a text file. This means embedded escapable characters in strings will be turned back into escapes.<br><br> If the object is already a string, no changes are made.<br><br><pre></pre><br/><i>See</i></td>
</tr>
 <tr>
<td>471</td> <td><b>write-text</b></td> <td>autoload.tl</td> <td>Syntax:<br/><br/>  Write an object to a text file. If the object is a string, just write it as is.<br><br> <pre>Examples:

</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>472</td> <td><b>xor</b></td> <td>built-in</td> <td>Syntax:<br/><br/> The &#39;xor&#39; function, which takes exactly 2 arguments, converts it&#39;s arguments into boolean values then computes the boolean xor of those values.<br><br> AutoCurry: true<pre>Examples:



</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>473</td> <td><b>zero?</b></td> <td>built-in</td> <td>Syntax:<br/><br/>  The &#39;zero?&#39; function returns true if its argument is zero.<br><br> <pre>Examples:


</pre><br/><i>See</i></td>
</tr>
 <tr>
<td>474</td> <td><b>zip</b></td> <td>built-in</td> <td>Syntax<br/><br/>  This function zips two lists together so returns An optional function can be used to compute the &#39;zip&#39; results. The examples section shows code that sums the zip&#39;ed elements using a lambda.<br><br> Note: the &#39;break&#39; and &#39;continue&#39; functions can be used in the lambda passed to &#39;zip&#39; to, for example, early terminate the &#39;zip&#39; process.<br><br> <pre>Examples:





</pre><br/><i>See</i></td>
</tr>

</table>

</body>
</html>
