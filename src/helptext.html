<!DOCTYPE HTML>
<html>
<header>
<title>Braid Functions</title>

<style>

                    body {
                        font-family: "Open Sans", Helvetica, Arial, Sans-Serif;
                    }
                    table {
                        border: 1px solid black;
                    }
                    th {
                        padding: 10px;
                        text-align: center;
                        background-color: #e0e0e0; 
                    }
                    td {
                        padding: 10px;
                        text-align: left;
                        vertical-align: top;
                    }
                    tr:nth-child(even) {background-color: #f2f2f2;}
            
</style>

</header>
<body>
<h2>Braid Function Documentation</h2>
<p>
                This page lists all of the Braid functions generally
                available to the user. Functions are either built into
                <br>
                the interpreter directly, defined in the file <b>autoload.tl</b>
                or loaded from other utility modules.
                <br>
                </p>

<table>
<tr>
<th>No</th> <th>Function</th> <th>Origin</th> <th>Description</th>
</tr>
 <tr>
<td>1</td> <td><b>-</b></td> <td>built-in</td> <td>Syntax: (- arg1 [arg2])<br/><br/>  The subtraction function (-) allows you to subtract numbers or DateTime and TimeSpan objects. All .NET numeric formats are supported. If only a single argument is passed, a curried function is returned.<br><br> <pre>Examples:
    (- 10 5)                ; returns 5
    (range 10 | map (- 2))  ; Subtract 2 from each member of the collection</pre><br/><i>See also: + * / % -- ++ incr decr</i></td>
</tr>
 <tr>
<td>2</td> <td><b>--</b></td> <td>built-in</td> <td>Syntax: (-- arg1)<br/><br/>  The &#39;--&#39; function takes a single numeric argument value and returns that value decremented by one. In contrast, the &#39;decr&#39; function takes a symbol argument and increments the value the named variable.<pre>Examples:
    (-- 10)              ; returns 9
    (let x 5) (-- x)     ; returns 4, the value in x is unchanged
    (++ (/ 25 5))        ; returnsn 46</pre><br/><i>See also: ++ + - incr pincr decr</i></td>
</tr>
 <tr>
<td>3</td> <td><b>!</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>4</td> <td><b>!!</b></td> <td>built-in</td> <td>Syntax: (!! indexible index [valueToSet])<br/><br/>  This function is used for accessing or setting elements in indexable data structures like lists, vectors and dictionaries. The first two arguments specify the indexible collection and the index to access. If a third argument is provided, this argument is used as the value to set the indexed item to. (Note that strings are a special case - they are indexible but not mutable and which means the three argument syntax doesn&#39;t work).<br><br><pre>Examples:
    (!! [0 1 2 3] 2)         ; result is 2
    (!! [0 1 2 3] 2 20)      ; sets the third element to 20.
    (!! {:a 1 :b 2 :c 3} :b) ; returns 2
    (!! &quot;hello&quot; 3)           ; returns &#39;l&#39;.</pre><br/></td>
</tr>
 <tr>
<td>5</td> <td><b>!=</b></td> <td>built-in</td> <td>Syntax: (!= arg1 arg2)<br/><br/>  The &#39;!=&#39; function compares two objects to see if they are not equal.<br><br> <pre>Examples:
    (!= 3 4)    ; returns true as the values are not equal
    (!= 3 3)    ; returns false as the values are equal.</pre><br/><i>See also: == === !==</i></td>
</tr>
 <tr>
<td>6</td> <td><b>!==</b></td> <td>built-in</td> <td>Syntax: (!== arg1 arg2 ...)<br/><br/>  This is the negative reference equals function (!==). If the arguments provided refer to the same object, the function will return false. If more than one pair of values is provided, they will all be compared pairwise.<br><br> <pre>Examples:
    (!== 5 5)                   ; returns false
    (!== 5 6)                   ; returns true
    (!== 1 2 3 4)               ; returns true
    (!== 3 3.0)                 ; returns true
    (!== &quot;foo&quot; &quot;foo&quot;)           ; returns true (different references)
    (let x &quot;foo&quot;) (=== x x)     ; returns false (same reference)</pre><br/><i>See also: === == !=</i></td>
</tr>
 <tr>
<td>7</td> <td><b>$</b></td> <td>autoload.tl</td> <td>Syntax: (compose [args])<br/><br/>  The &#39;compose&#39; function takes a list of functions and returns a new function composed of the individual functions piped together.<br><br> <pre>Examples:
    ; define a function that adds 1 to its argument, then 2 then multiplies by 3
    (let f (compose ++ (+ 2) (* 3)))
    (f 5)                                    ; returns 24
    (range 10 | filter (compose (% 2) not))  ; returns the even numbers</pre><br/><i>See also: partial compliment</i></td>
</tr>
 <tr>
<td>8</td> <td><b>%</b></td> <td>built-in</td> <td>Syntax: (% arg1 arg2)<br/><br/>  The &#39;%&#39; function computes the modulus of the its argument values. Syntax: (% &lt;numVal1&gt; &lt;numVal2&gt;) The function is only defined for numeric values.<br><br> <pre>Examples:
    (% 9 4)  ; returns 1</pre><br/><i>See also: + - * / -- ++ incr decr</i></td>
</tr>
 <tr>
<td>9</td> <td><b>*</b></td> <td>built-in</td> <td>Syntax: (* arg1 arg2 arg3 ... argn)<br/><br/>  The &#39;*&#39; multiplication function computes the product of it&#39;s arguments if the arguments are numeric. If the first argument is a string or sequence, that sequence will be replicated the specified number of times. Syntax You can compute factorials using multiply, splatting and the range function as<br><br> If only one argument is passed, then a curried function is returned<br><br><pre>Examples:
    (* &lt;arg1&gt; &lt;arg2&gt; &lt;argn&gt;
    (* @(range 10)) ; compute factorial of 10
    (* 1 2 3)       ; Compute the product of the argument values
    (* &quot;hi&quot; 10)     ; Repeat the string argument 10 times
    (* [1 2 3] 10)  : Repeat the sequence argument 10 times
    (range 10 | map (* 2)) ; return the numbers from 1-10 multiplied by 2</pre><br/><i>See also: + - / % -- ++ incr decr</i></td>
</tr>
 <tr>
<td>10</td> <td><b>**</b></td> <td>autoload.tl</td> <td>Syntax: (** ^double [(^double? x) (^double? y)])<br/><br/>  The ** operator lets you compute the exponentiation of numbers.<br><br><pre>Examples:
    (** v n)        ; Compute the nth exponent of v
    (** 2 10)       ; returns 1024</pre><br/></td>
</tr>
 <tr>
<td>11</td> <td><b>.</b></td> <td>built-in</td> <td>Syntax: (. object &#39;member [args...])<br/><br/>  The &#39;.&#39; function is the member accessor operation allowing you to get and set properties and fields and call instance (by specifying an object instance) and static (by specifying a type) methods. In the case of a property or field, if only the member name is specified, the operation will be a get. If an additional argument is provided, the operation will be a set.<br><br><pre>Examples:
    (. &quot;hello&quot; :length)       ; gets the &#39;length&#39; property from the string
    (. ^math :pi)               ; gets the value of the static member &#39;pi
    (. &quot;hello&quot; :substring 1 2) ; Applies the method &#39;substring with 2 arguments</pre><br/></td>
</tr>
 <tr>
<td>12</td> <td><b>/</b></td> <td>built-in</td> <td>Syntax (/ arg1 arg2)<br/><br/>  The division function (/) divides its first operand by it&#39;s second. If the division is not perfect, the result will be returned as a ^double<br><br> <pre>Examples:
    (/ 6 2) ; returns 3
    (/ 5 2) ; returns 2.5</pre><br/><i>See also: + - * % -- ++ incr decr</i></td>
</tr>
 <tr>
<td>13</td> <td><b>:</b></td> <td>built-in</td> <td>Syntax: (: arg list)<br/><br/>  The &#39;:&#39; function constructs a new list. It adds the arg value to the list, returning a new list.<br><br> <pre>Examples:
    (: 1 &#39;(2 3))         ; returns &#39;(1 2 3)
    (: 1 [2 3])          ; returns a new vector [1 2 3]
    (: 1 2)              ; returns a dotted pair (1 . 2)</pre><br/><i>See also: vcons &gt;cons</i></td>
</tr>
 <tr>
<td>14</td> <td><b>\</b></td> <td></td> <td>Syntax: (fn [args])<br/><br/>  Macro for creating function literals of the form (fn &lt;args&gt; -&gt; &lt;body&gt;).<br><br><pre>Examples:
    (fn a b c -&gt; (+ a b c))                         ; define a function literal that adds 3 values
    (range 10 | map (fn x -&gt; (* x x)) | sum)        ; use a function literal for squaring numbers
    (range 10 | map (fn x -&gt; (println x) (* x x)))  ; Multiple expressions are allowed
    (def sqr (fn x -&gt; (* x x))) (sqr 4)             ; define a &#39;sqr&#39; function then call it - returns 16
    (fn (^int a) (^int b 1) -&gt; (+ a b)              ; arguments can have type constraints and initializers</pre><br/></td>
</tr>
 <tr>
<td>15</td> <td><b>+</b></td> <td>built-in</td> <td>Syntax: (+ arg1 arg2 arg3 ... argn)<br/><br/>  The addition function (+)  sums all of its arguments together. It works on numbers, strings and datetime objects. The type of the first argument (number, string or datetime) will determine the type of the overall operation.<br><br> <pre>Examples:
    (+ 1 2 3)       ; Compute the sum of the argument values
    (+ &quot;ab&quot; &quot;cd&quot;)    ; Add &#39;ab&#39; and &#39;cd&#39; to get &#39;abcd&#39;</pre><br/><i>See also: - * / % -- ++ incr decr</i></td>
</tr>
 <tr>
<td>16</td> <td><b>++</b></td> <td>built-in</td> <td>Syntax: (++ arg1)<br/><br/>  The &#39;++&#39; function takes a single numeric argument value and returns that value incremented by one. In contrast, the &#39;incr&#39; function takes a symbol argument and increments the value the named variable.<br><br><pre>Examples:
    (++ 10)              ; returns 11
    (let x 5) (++ x)     ; returns 6, the value in x is unchanged
    (++ (/ 25 5))        ; returnsn 6</pre><br/><i>See also: -- + - incr pincr decr</i></td>
</tr>
 <tr>
<td>17</td> <td><b><</b></td> <td>built-in</td> <td>Syntax: (&lt; arg1 arg2)<br/><br/>  This is the polymorphic less than function (&lt;) which works on any types that support ordered comparisons.<br><br> <pre>Examples:
    (&lt; 1 5)               ; returns true
    (&lt; &quot;abc&quot; &quot;ab&quot;)    ; returns false</pre><br/><i>See also: &lt;= &gt; &gt;= == != === !==</i></td>
</tr>
 <tr>
<td>18</td> <td><b><=</b></td> <td>built-in</td> <td>Syntax: (&lt;= arg1 arg2)<br/><br/>  This is the polymorphic less than or equals function which works on any types that support ordered comparisons.<br><br> <pre>Examples:
    (&lt;= 5 5)    ; returns true</pre><br/><i>See also: &lt; &gt; &gt;= == != === !==</i></td>
</tr>
 <tr>
<td>19</td> <td><b>=</b></td> <td></td> <td>Syntax: (= [args])<br/><br/>  A macro that parses and transforms infix arithmetic expressions with conventional operator precedence into prefix notation. The net effect is similar to the &#39;expr&#39; function in TCL but has no runtime impact.<br><br><pre>Examples:
    (= 2+2)
    (= a * (b + 6))</pre><br/></td>
</tr>
 <tr>
<td>20</td> <td><b>==</b></td> <td>built-in</td> <td>Syntax: (== arg1 arg2 ...)<br/><br/>  This is the polymorphic comparison function (==) which works on any types that support comparisons (IComparable). If more than one pair of values is provided, they will all be compared pairwise.<br><br> <pre>Examples:
    (== 5 5)     ; returns true
    (== 5 6)     ; returns false
    (== 1 2 3 4) ; returns false
    (== :a :a 3 3.0) ; returns true</pre><br/><i>See also: != === !==</i></td>
</tr>
 <tr>
<td>21</td> <td><b>===</b></td> <td>built-in</td> <td>Syntax: (=== arg1 arg2 ...)<br/><br/>  This is the reference equals function (===). If the arguments provided refer to the same object, the function will return true. If more than one pair of values is provided, they will all be compared pairwise.<br><br> <pre>Examples:
    (=== 5 5)                   ; returns true
    (=== 5 6)                   ; returns false
    (=== 1 2 3 4)               ; returns false
    (=== 3 3.0)                 ; returns false
    (=== &quot;foo&quot; &quot;foo&quot;)           ; returns false (different references)
    (let x &quot;foo&quot;) (=== x x)     ; returns true (same reference)</pre><br/><i>See also: !== == !=</i></td>
</tr>
 <tr>
<td>22</td> <td><b>></b></td> <td>built-in</td> <td>Syntax: (&gt; arg1 arg2 ... argN)<br/><br/>  With two arguments, the &#39;&gt;&#39; function returns true if arg1 is greater than arg2. If more than two arguments are specified, &#39;&gt;&#39; returns true if the arguments are in monotonically decreasing order. This function works for all comparable types.<br><br><pre>Examples:
    (&gt; 3 2)                                 ; returns true
    (&gt; 2 3)                                 ; returns fakse
    (&gt; 3 2 1)                               ; returns true
    (&gt; 4 2 3)                               ; returns false (non-monotonic)
    (range 10 | filter (fn n -&gt; (&gt; 8 n 3))) ; returns [4 5 6 7]</pre><br/></td>
</tr>
 <tr>
<td>23</td> <td><b>>:</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>24</td> <td><b>>=</b></td> <td>built-in</td> <td>Syntax: (&gt;= arg1 arg2 ... argn)<br/><br/>  Returns true if all of its arguments are monotonically greater than or equal to the previous argument.<br><br><pre>Examples:
    (&gt;= 2 1)        ; returns true
    (&gt;= 1 2)        ; returns false
    (&gt;= 2 2)        ; returns true
    (&gt;= 3 2 2 1)    ; returns true
    (&gt;= 3 4 2 1)    ; returns false</pre><br/></td>
</tr>
 <tr>
<td>25</td> <td><b>->></b></td> <td>built-in</td> <td>Syntax: (-&gt;&gt; &lt;value&gt; (expr1) (expr2) ... (exprN))<br/><br/>  This function implements the logic for the form (a | b | c) which is translated at compile time into (-&gt;&gt; a (b) (c)) There&#39;s not a lot of reason to use this function directly.<br><br><pre>Examples:
    (-&gt;&gt; (range 10) (where (% 2)) (sum))   ; same as  (range 10 | where (% 2) | sum)</pre><br/></td>
</tr>
 <tr>
<td>26</td> <td><b>>cons</b></td> <td>built-in</td> <td>Syntax: (&gt;cons list arg)<br/><br/>  This function is identical to &#39;cons&#39; except the arguments are reversed allowing it to be used in a pipeline. Like &#39;cons&#39;, it adds the arg value to the start of the list, returning a new list.<br><br> <pre>Examples:
    (list 2 3 | &gt;cons 1)    ; returns &#39;(1 2 3)</pre><br/><i>See also: cons vcons</i></td>
</tr>
 <tr>
<td>27</td> <td><b>>def</b></td> <td>built-in</td> <td>Syntax: (&gt;def value name)<br/><br/>  Like &#39;def&#39;, this function sets the value of a variable if that variable already exists or create a new variable in the current scope if it doesn&#39;t. The difference is that the order of the arguments is reversed. This allows &#39;&gt;def&#39; to be used in the pipeline.<br><br> Note: If the name takes the form of v1:v2:v3 then destructuring will be done and the parts assigned.<br><br> <pre>Examples:
    (123 | &gt;def foo)            ; assign 123 to &#39;foo&#39;.
    ([1 2 3 4] | &gt;def foo)      ; assign the array to &#39;foo&#39;
    ([1 2 3 4 5] | &gt;def x:y:z)  ; assign 1 to &#39;x&#39;, 2 to &#39;y&#39; and the rest to &#39;z&#39;.</pre><br/><i>See also: let defn &gt;def</i></td>
</tr>
 <tr>
<td>28</td> <td><b>>let</b></td> <td>autoload.tl</td> <td>Syntax: (&gt;let [expression varsym])<br/><br/>  This special form allows left-to right assignment.<br><br><pre>Examples:
    (ls &#39;*.tl | map .length | sum | &gt;let total)         ; &#39;total&#39; contains the length of all of the files
    ([1 2 3] | &gt;let a:b:c:)                             ; multiple assignment works</pre><br/></td>
</tr>
 <tr>
<td>29</td> <td><b>abs</b></td> <td>autoload.tl</td> <td>Syntax: (abs [num])<br/><br/>  Function to get the absolute value of its argument.<br><br> <pre>Examples:
    (abs -1.5) ; returns 1.5 (double)
    (abs -5)   ; returns 5 (int)</pre><br/><i>See also: sign round ceiling floor</i></td>
</tr>
 <tr>
<td>30</td> <td><b>add-watch</b></td> <td>powershell</td> <td>Syntax: (add-watch &lt;filename&gt;)<br/><br/>  This function sets up a file watcher that will cause a script module to be reloaded if it has changed since the last repl command was issued.<br><br> <pre>Examples:
    (add-watch &#39;my-module.tl)</pre><br/><i>See also: get-watch remove-watch</i></td>
</tr>
 <tr>
<td>31</td> <td><b>alert</b></td> <td>built-in</td> <td>Syntax: (alert arg1 arg2 arg3 ... argn)<br/><br/>  This function prints a string to the console with emphasis.<br><br> <pre>Examples:
    (alert &quot;This is an alert&quot;)
    (alert &#39;this &#39;is &#39;an &#39;alert &#39;in &#39;pieces.)
    (alert &quot;The value of 2+2 is&quot; (+ 2 2))</pre><br/><i>See also: info warn error println</i></td>
</tr>
 <tr>
<td>32</td> <td><b>all-members</b></td> <td>autoload.tl</td> <td>Syntax: (all-members [(^regex? pattern &quot;.&quot;)])<br/><br/>  The &#39;all-members&#39; function is used by the &#39;completer&#39; function to do method completion. It returns a Vector of all of the members defined on the types that are currently &#39;in use&#39; i.e. there is an instance of that type stored in a Braid variable. These members are considered to be the &#39;interesting&#39; ones for the interactive user.<br><br> <pre>Examples:
    (all-members #&quot;sub&quot;)</pre><br/><i>See also: completer</i></td>
</tr>
 <tr>
<td>33</td> <td><b>and</b></td> <td>built-in</td> <td>Syntax: (and arg1 arg2 arg3 ... argn)<br/><br/> The &#39;and&#39; function returns the last argument if all of its other arguments evaluate to true. Lazy evaluation is used so the first argument that doesn&#39;t resolve to true terminates execution and false is returned.<br><br> <pre>Examples:
    (and true true true)    ; returns true
    (and true false true)   ; returns false
    (and 1 2)               ; returns 2
    (and 0 2)               ; returns false</pre><br/><i>See also: or not</i></td>
</tr>
 <tr>
<td>34</td> <td><b>and$</b></td> <td>autoload.tl</td> <td>Syntax: (and$ [args])<br/><br/>  The &#39;and$&#39; (&#39;and compose&#39;) function takes a list of functions and returns a new function composed of the individual functions with the results and&#39;ed together. The argument to the outer function is passed to each of the inner functions. The results of these functions are and&#39;ed together to produce a final result.<br><br> <br><br><pre>Examples:
    (let f (and$ (&lt; 10) (&gt; 5)))
    (f 12)                      ; returns false
    (f 7)                       ; returns true
    (f 3)                       ; returns false</pre><br/><i>See also: partial compliment compose</i></td>
</tr>
 <tr>
<td>35</td> <td><b>any-peg</b></td> <td>autoload.tl</td> <td>Syntax: (any-peg [(^string? targ) (^int offset) (^regex? set #&quot;&quot;)])<br/><br/>  Match any character recognized by the argument regex.<pre></pre><br/></td>
</tr>
 <tr>
<td>36</td> <td><b>append</b></td> <td>built-in</td> <td>Syntax: (append arg1 arg2 arg3 ... argn)<br/><br/>  The &#39;append&#39; function appends it&#39;s arguments together to produce a new list. If an argument is a list, it is stiched into the result list rather than being added as a single member.<pre>
    (append 1 &#39;(2 3) 4)     ; results in a new list &#39;(1 2 3 4)</pre><br/></td>
</tr>
 <tr>
<td>37</td> <td><b>apply</b></td> <td>built-in</td> <td>Syntax: (apply functionToApply collection)<br/><br/>  The apply takes a function and a collection and applies the function using the collection as the arguments to that function. It is similar to splatting in that (apply + coll) returns the same result as (+ @coll).<br><br> <pre>Examples:
    (apply + [1 2 3])                           ; returns 6
    (apply * &#39;(2 4 6))                          ; returns 48
    (apply (fn &amp;args -&gt; (length args)) [1 2 3]) ; returns 3</pre><br/><i>See also: call</i></td>
</tr>
 <tr>
<td>38</td> <td><b>as</b></td> <td>built-in</td> <td>Syntax: (as objectToConvert targetType)<br/><br/>  As converts it&#39;s first argument into the type specified by the second argument either returning an object of that type or null if the conversion was not successful.<pre>
    (as &quot;123&quot; ^int)   ; returns the integer value 123
    (as &quot;abc&quot; ^int)   ; returns null</pre><br/></td>
</tr>
 <tr>
<td>39</td> <td><b>asarray</b></td> <td>built-in</td> <td>Syntax: (asarray enumerableToConvert [arrayType])<br/><br/>  The &#39;asarray&#39; function returns its argument wrapped in an instance of ^object[]. If the argument is already ^object[], it is simply returned. If the argument is an ^IEnumerable, an array of equivalent size is allocated and the elements copied in to this new array. It the argument is a scalar, it will be wrapped in a one-element array. An optional array type can be specified in which case the returned array will be of that type and the objects in the source enumerable will be converted to the target type<br><br> <pre>Examples:
    (asarray &#39;(1 2 3))          ; returns an array 1,2,3.
    (asarray 13)                ; returns a 1 element array.
    (asarray [1 2 3] ^string)   ; returns an array of the specified type containing 3 strings</pre><br/><i>See Also: new-array</i></td>
</tr>
 <tr>
<td>40</td> <td><b>asEventHandler</b></td> <td>autoload.tl</td> <td>Syntax: (asEventHandler [callback])<br/><br/>  Make an ^EventHandler delegate out of a Braid lambda. The lambda must take two parameters: the object invoking the event and the eventArgs object.<br><br> <pre>Examples:
    (.Add_Shown MainForm (asEventHandler (fn o e -&gt; (.Activate MainForm))))</pre><br/><i>See also: CreateDelegate</i></td>
</tr>
 <tr>
<td>41</td> <td><b>aslist</b></td> <td>built-in</td> <td>Syntax: (aslist enumerableToConvert)<br/><br/>  The &#39;aslist&#39; function converts its argument enumerable into a Braid list.<br><br> <pre>Examples:
    (aslist [1 2 3]) ; returns (1 2 3)</pre><br/><i>See also: asarray</i></td>
</tr>
 <tr>
<td>42</td> <td><b>assoc-in</b></td> <td>autoload.tl</td> <td>Syntax: (assoc-in [(^IDictionary data) (^Vector path) value])<br/><br/>  Update a dictionary given a list of keys and a value to assign/insert. The list of keys represents a path into the object. If any nodes don&#39;t exist or are not dictionaries, new dictionary nodes are assigned/added (like mkdir -p).<pre></pre><br/></td>
</tr>
 <tr>
<td>43</td> <td><b>async</b></td> <td>built-in</td> <td>Syntax: (async &lt;lambda&gt; [&lt;argToLambda&gt;])<br/><br/>  Starts a new background task using the .NET Task Parallel Library with the lambda as the ^Task procedure. An optional argument may be passed in though most things will be passed through the closure. Tasks can be composed with the subsequent task receiving the result of the previous task.<br><br> <pre>Examples:
    (await (async (fn -&gt; (println &#39;hello))))           ; starts and then waits for a task that prints &#39;hello&#39;.
    (async (fn -&gt; 123) | await)                        ; returns [123]
    (async (fn -&gt; 2) | async (fn n -&gt; (* n 2)) | await) ; returns [4]</pre><br/><i>See also: resolve map-parallel await</i></td>
</tr>
 <tr>
<td>44</td> <td><b>atom?</b></td> <td>built-in</td> <td>Syntax: (atom? object)<br/><br/>  The &#39;atom?&#39; function returns true if its argument is not an enumerable type.<br><br><pre>Examples:
    (atom? 123)         ; returns true
    (atom? &quot;abc&quot;)       ; returns true
    (atom? [1 2 3])     ; false</pre><br/></td>
</tr>
 <tr>
<td>45</td> <td><b>average</b></td> <td>autoload.tl</td> <td>Syntax: [ %none? (func null) | lst (func null) ]<br/><br/>  The &#39;average&#39; function computes the average of it&#39;s arguments, with an optional function to get the value to average.<br><br><pre>Examples:
    (range 10 | average)         ; returns 5
    (ls -file | average .length) ; returns average length of the files</pre><br/></td>
</tr>
 <tr>
<td>46</td> <td><b>await</b></td> <td>built-in</td> <td>Syntax: (await &lt;listOfTasks&gt;)<br/><br/>  The await function waits for all argument tasks to complete and then returns a collection containing the values returned by the tasks. Note that even in the simple case of a single task, the result will still be returned as a collection of one element. &#39;resolve&#39; is an alias for &#39;await&#39;.<br><br><pre></pre><br/><i>See also: async task map-parallel</i></td>
</tr>
 <tr>
<td>47</td> <td><b>background</b></td> <td>autoload.tl</td> <td>Syntax: (background [expr])<br/><br/>  Run an expression in the background using a .NET ^Task. This ^Task will be run in memory but on a seperate thread so it doesn&#39;t block the REPL thread.<br><br><pre>Examples:
    (background (textedit &#39;autoload.tl))</pre><br/></td>
</tr>
 <tr>
<td>48</td> <td><b>band</b></td> <td>built-in</td> <td>Syntax: (band arg1 arg2 ...)<br/><br/>  The &#39;band&#39; function performs a binary &#39;and&#39; on its arguments.<br><br> <pre>Examples:
    (band 0xF 0x5)      ; returns 5
    (band 0xF 0x5 0x4)  ; returns 4</pre><br/><i>See also: shiftl shiftr bnot bor bxor</i></td>
</tr>
 <tr>
<td>49</td> <td><b>baseobject</b></td> <td>built-in</td> <td>Syntax: (baseobject object)<br/><br/>  If the argument object is a PowerShell PSObject, the &#39;baseobject&#39; function will return the base object from the PSObject. If the argument is not a PSObject, then it will just return the original object.<pre></pre><br/></td>
</tr>
 <tr>
<td>50</td> <td><b>base-of</b></td> <td>autoload.tl</td> <td>Syntax: (base-of [obj])<br/><br/>  The &#39;base-of&#39; function returns the base type of its type argument.<br><br> <pre>Examples:
    (base-of ^System.Reflection.MemberFilter)  ; returns System.MulticastDelegate</pre><br/><i>See also: members-of type-of</i></td>
</tr>
 <tr>
<td>51</td> <td><b>bigger</b></td> <td>built-in</td> <td>Syntax: (bigger args...)<br/><br/>  This function returns the largest member of its argument list.<br><br><pre>Examples:
    (bigger 3 1 4 2)   ; returns 4</pre><br/></td>
</tr>
 <tr>
<td>52</td> <td><b>binary</b></td> <td>autoload.tl</td> <td>Syntax: (binary [n])<br/><br/>  Function to take numeric arguments and turn them into binary strings. Normally the strings are prefixed with &#39;0b&#39; but if -noprefix is specified, then the &#39;0b&#39; prefix will be omitted.<pre></pre><br/></td>
</tr>
 <tr>
<td>53</td> <td><b>bind</b></td> <td>built-in</td> <td>Syntax: (bind lambda [environment])<br/><br/>  (Re)Bind a lambda to either the current environment or a optional passed argument.<br><br><pre></pre><br/><i>See also: environment</i></td>
</tr>
 <tr>
<td>54</td> <td><b>bindhelp</b></td> <td>helpsource.tl</td> <td>Syntax: (bindhelp [funcs text])<br/><br/>  Creates a :helptext association between one or more functions and their help text<pre></pre><br/></td>
</tr>
 <tr>
<td>55</td> <td><b>bnot</b></td> <td>built-in</td> <td>Syntax: (bnot arg)<br/><br/>  The &#39;bnot&#39; function computes the bitwise complement of its argumen.<br><br><pre></pre><br/><i>See also: shiftl shiftr band bor bxor</i></td>
</tr>
 <tr>
<td>56</td> <td><b>bor</b></td> <td>built-in</td> <td>Syntax: (bor arg1 arg2 ...)<br/><br/>  The &#39;bor&#39; function performs a binary &#39;or&#39; on its arguments.<br><br> <pre>Examples:
    (bor 0x4 0x1)           ; returns 5
    (bor 0x1 0x2 0x4 0x8)   ; returns 15 (0xF)</pre><br/><i>See also: shiftl shiftr band bxor</i></td>
</tr>
 <tr>
<td>57</td> <td><b>bound?</b></td> <td>built-in</td> <td>Syntax: (bound? symbol)<br/><br/>  returns true if the symbol has a binding (an associated value or function.)<br><br> <pre>Examples:
    (bound? &#39;x)              ; returns true
    (bound? &#39;nosuchvar)      ; returns false</pre><br/><i>See also: symbol?</i></td>
</tr>
 <tr>
<td>58</td> <td><b>breadth-search</b></td> <td>built-in</td> <td>Syntax: (breadth-search &lt;start&gt; &lt;goalValue|goalFn&gt; &lt;moveGeneratorFunction&gt;)<br/><br/>  This function will perform a breadth-first search through a set of data. The first parameter is the starting data item. The second parameter is either the target data item on a function of one argument returning a boolean value if it&#39;s argument is the target item. The final argument is the move generator function. This function is passed the current item and returns a list of &#39;next&#39; items to search.<br><br><pre>Examples:
    ; searching a binary tree
    (breadth-search
        tree
        (fn x -&gt; (.val x | == 15)) ; goal is 15
        (fn n -&gt; (filter [(.?left n) (.?right n)] some?)))
    ; Starting at 5, search for the number 35 using the next move fn.
    (breadth-search 5 35
        (fn x -&gt; [(+ x 3) (* x 2) (- x 7)]))</pre><br/></td>
</tr>
 <tr>
<td>59</td> <td><b>break</b></td> <td>built-in</td> <td>Syntax: (break [&lt;value&gt;])<br/><br/>  The &#39;break&#39; function allows you to break out of a loop as shown in the examples An optional value can be specified in which case the value becomes the result (or part of the result) of the loop. It works for &#39;conventional&#39; loops like &#39;while&#39; and &#39;foreach&#39; as well as functions like &#39;map&#39;, &#39;filter&#39; and &#39;zip&#39;.<br><br> <pre>Examples:
    ; executes the println function once then stops
    (while true
        (println &quot;I&#39;m done.&quot;)
        (break)
    )
    ; break can be called from zip function lambda to stop iterating early.
    ; the following returns [2 4 6]
    (zip (range 10) (range 10) (fn x y -&gt;
        (let r (+ x y))
        (if (&gt; r 6) (break))
        r)
    )
    ; break out of the &#39;map&#39; pipeline returning &quot;hello&quot;
    (range 10 | map (fn x -&gt; (if (== x 5) (break &quot;hello&quot;) x))</pre><br/><i>See also: foreach forall for while continue recur return map filter zip</i></td>
</tr>
 <tr>
<td>60</td> <td><b>bxor</b></td> <td>built-in</td> <td>Syntax: (bxor arg1 arg2)<br/><br/>  The &#39;bxor&#39; function performs a binary &#39;xor&#39; on its two arguments.<br><br> <pre>Examples:
    (bxor 0x1 0x4)          ; returns 0x5
    (bxor 0xF 0b1001)       ; returns 6</pre><br/><i>See also: shiftl shiftr band bor</i></td>
</tr>
 <tr>
<td>61</td> <td><b>c1</b></td> <td>stdin</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>62</td> <td><b>c2</b></td> <td>stdin</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>63</td> <td><b>caddr</b></td> <td>autoload.tl</td> <td>Syntax: (caddr [lst])<br/><br/>  Returns the third item in a sequence<pre></pre><br/></td>
</tr>
 <tr>
<td>64</td> <td><b>cadr</b></td> <td>autoload.tl</td> <td>Syntax: (cadr [lst])<br/><br/>  Returns the second item in a sequence<pre></pre><br/></td>
</tr>
 <tr>
<td>65</td> <td><b>call</b></td> <td>autoload.tl</td> <td>Syntax: (call [function args])<br/><br/>  Utility to call a function on a set of args; (Not sure this really needs to exist...).<br><br> <pre>Examples:
    (call &lt;function&gt; &lt;args...&gt;)</pre><br/><i>See also: apply</i></td>
</tr>
 <tr>
<td>66</td> <td><b>car</b></td> <td>built-in</td> <td>Syntax: (car listOfObjects)<br/><br/>  The &#39;car&#39; function returns the first item from a sequence, or the item itself if it&#39;s an atom.  (head is an alias for car.) If the argument is a string, the first &#39;word&#39; is returned i.e. all of the text up to the first whitespace character.<br><br> <pre>Examples:
    (car &#39;(1 2 3))         ; returns 1
    (car [4 5 6])          ; returns 4
    (car &quot;abc&quot;)          ; returns &quot;abc&quot;
    (car &quot;abc def ghi&quot;)  ; returns the first word &quot;abc&quot;</pre><br/><i>See also: cdr tail first last</i></td>
</tr>
 <tr>
<td>67</td> <td><b>case</b></td> <td></td> <td>Syntax: (case [args])<br/><br/>  A macro for the &#39;case&#39; expression. A case expression looks like:   (case (+ 2 3) 1 &quot;One&quot; 2 &quot;Two&quot; 3 &quot;three&quot;) which will generate a cond statement that looks like:   (do   )<br><br><pre>
    (def sym_140875202 (+ 2 3))
    (cond (== sym_140875202 1)
        &quot;One&quot; (== sym_140875202 2)
        &quot;Two&quot; (== sym_140875202 3)
        &quot;three&quot;
    )</pre><br/><i>See also: if cond matchp</i></td>
</tr>
 <tr>
<td>68</td> <td><b>cd</b></td> <td>autoload.tl</td> <td>Syntax: (cd [(path &quot;~&quot;)])<br/><br/>  Directory stack aware &#39;cd&#39; change directory function.<pre></pre><br/></td>
</tr>
 <tr>
<td>69</td> <td><b>cddr</b></td> <td>autoload.tl</td> <td>Syntax: (cddr [lst])<br/><br/>  Returns the cdr of the cdr of the sequence.<br><br><pre>Examples:
    (cddr &#39;(1 2 3 4)    ; returns (3 4)
    (cddr [1 2 3 4])    ; returns [3 4] (as a Slice)
    (cddr nil)          ; returns nil
    (cddr [])           ; returns nil</pre><br/></td>
</tr>
 <tr>
<td>70</td> <td><b>cdr</b></td> <td>built-in</td> <td>Syntax: (cdr listOfObjects)<br/><br/>  The &#39;cdr&#39; function skips the first item in a sequence and returns the rest, or it returns the item itself if it&#39;s an atom. Note that for sequences, cdr always returns an s_Expr regardless of the original type of the sequence. This is for performance reasons. Getting the cdr of a Vector is slow. Getting the cdr of an s_Expr, is very fast. (Commands tail and rest are aliases for cdr.)<br><br> <pre>Examples:
    (car &#39;(1 2 3))  ; returns &#39;(2 3)
    (car [4 5 6])   ; returns [5 6[
    (car &quot;abc&quot;)     ; returns &quot;abc&quot;</pre><br/><i>See also: car head first tail rest</i></td>
</tr>
 <tr>
<td>71</td> <td><b>ceiling</b></td> <td>autoload.tl</td> <td>Syntax: (ceiling [num])<br/><br/>  Compute the ceiling of a number.<pre></pre><br/></td>
</tr>
 <tr>
<td>72</td> <td><b>char</b></td> <td>built-in</td> <td>Syntax: (char stringValue)<br/><br/>  Returns the ^char of the first character in a 1-element string.<br><br><pre>Examples:
    (char &quot;a&quot;)    ; returns the char value &#39;a&#39;.</pre><br/></td>
</tr>
 <tr>
<td>73</td> <td><b>chars</b></td> <td>built-in</td> <td>Syntax: (chars stringValue)<br/><br/>  The &#39;chars&#39; function converts is string argument to an array of characters.<br><br> <pre>Examples:
    (chars &quot;hello&quot;)   ; returns [ \h  \l \l \o]</pre><br/><i>See also: char str join</i></td>
</tr>
 <tr>
<td>74</td> <td><b>choose</b></td> <td>autoload.tl</td> <td>Syntax: [ nil _ | xs 1 | x:xs n ]<br/><br/>  Choose n elements from a sequence of items.<br><br><pre></pre><br/><i>See also: combinations</i></td>
</tr>
 <tr>
<td>75</td> <td><b>cls</b></td> <td>built-in</td> <td>Syntax: (cls)<br/><br/>  Clears the console screen.<br><br> <pre>Examples:
    (cls)          ; clears the screen</pre><br/><i>See also:</i></td>
</tr>
 <tr>
<td>76</td> <td><b>collection?</b></td> <td>built-in</td> <td>Syntax: (collection? obj)<br/><br/>  Returns true if its argument is any of the sequence types (List, Vector, IEnumerable, ISeq etc.).<br><br><pre>Examples:
    (collection? [1 2 3]        ; returns true
    (collection? 5)             ; returns false
    (collection? &quot;hi&quot;)        ; returns false
    (collection? {:a 1})        ; returns true</pre><br/></td>
</tr>
 <tr>
<td>77</td> <td><b>combinations</b></td> <td>autoload.tl</td> <td>Syntax: (combinations [n k])<br/><br/>  Calculate the number of combinations choosing k items from a set of n items.<br><br> <pre>Examples:
    (combinations 52 5) ; returns 2_598_960</pre><br/><i>See also: choose fact</i></td>
</tr>
 <tr>
<td>78</td> <td><b>combine</b></td> <td>autoload.tl</td> <td>Syntax: [ x: | x:xs ]<br/><br/>  Generate the all of the combinations of a sequence of items.<br><br><pre></pre><br/><i>See also: choose combinations permute</i></td>
</tr>
 <tr>
<td>79</td> <td><b>comment</b></td> <td></td> <td>Syntax: (comment [args])<br/><br/>  macro to comment out a list of forms (but that list must be well-formed).<pre></pre><br/></td>
</tr>
 <tr>
<td>80</td> <td><b>compare</b></td> <td>built-in</td> <td>Syntax: (compare value1 value2)<br/><br/>  The &#39;compare&#39; function compares two value and returns -1 if the first value is smaller than the second, 0 if the values are the same and 1 if thesecond value is larger than the fitst value.<br><br> <pre>Examples:
    (compare 1 2)   ; returns -1
    (compare 5 5)   ; returns 0
    (compare 5 2)   ; returns 1</pre><br/><i>See also: == === &lt; &gt;</i></td>
</tr>
 <tr>
<td>81</td> <td><b>completer</b></td> <td>autoload.tl</td> <td>Syntax: [ prefix #&quot;^.*[|(] *(map|filter|where|map|each|lazy-map|lazy-filter) +([^ ]*)$&quot; after | prefix #&quot;^.*[|(] *(reduce|foldl|foldr) +([^ ]*)$&quot; after | prefix #&quot;^.*[|(] *(git) +([^ ]*)$&quot; after | prefix #&quot;^.*[|(] *(cd) +([^ ]*)$&quot; after | prefix #&quot;^.*[(|] *([a-z][^ ]*).* +(-[a-z]*)$&quot; after | prefix #&quot;[|(]? *(\.[a-z]*)&quot; #&quot; *([a-z]+)&quot; | #&quot;^(\(?)\.([a-z0-9.]+)/([a-z0-9]*)$&quot; before after | #&quot;^(\(?)\^([^ \t]+)&quot; before after | #&quot;^(\(?)\.([a-z0-9]+$)&quot; before after | #&quot;^\(?&#39;([^ \t]+$)&quot; before after | #&quot;^(\(?):([^ \t]+$)&quot; before after | #&quot;^\( *([^ \t]+$)&quot; before after | prefix before after ]<br/><br/>  The tab-completion implementation for Braid. This function needs to be bound to the completer callback to work (see the function definition for how this is done.)<br><br><pre>Examples:
    (completer &lt;prefixString&gt; &lt;beforeString&gt; &lt;suffixString&gt;)
    (completer &quot;&quot; &quot;(list/&quot; &quot;:foo&quot;)</pre><br/></td>
</tr>
 <tr>
<td>82</td> <td><b>compliment</b></td> <td>autoload.tl</td> <td>Syntax: (compliment [func-to-call value args])<br/><br/>  The &#39;compliment&#39; function is identical to &#39;partial&#39; except that a call to &#39;not&#39; is wrapped around the expression.<br><br> <pre>Examples:
    (let isNot2 (compliment == 2))
    (isnot2 3)                          ; returns true</pre><br/><i>See also: partial compose</i></td>
</tr>
 <tr>
<td>83</td> <td><b>compose</b></td> <td>autoload.tl</td> <td>Syntax: (compose [args])<br/><br/>  The &#39;compose&#39; function takes a list of functions and returns a new function composed of the individual functions piped together.<br><br> <pre>Examples:
    ; define a function that adds 1 to its argument, then 2 then multiplies by 3
    (let f (compose ++ (+ 2) (* 3)))
    (f 5)                                    ; returns 24
    (range 10 | filter (compose (% 2) not))  ; returns the even numbers</pre><br/><i>See also: partial compliment</i></td>
</tr>
 <tr>
<td>84</td> <td><b>concat</b></td> <td>built-in</td> <td>Syntax: (concat arg1 arg2 arg3 ... argn)<br/><br/>  The &#39;concat&#39; function appends it&#39;s arguments together to produce a new vector (see also the &#39;append&#39; function with produces a list instead of a vector.) If an argument is a sequence, it is stiched into the result list rather than being added as a single member. Any null arguments are simply skipped.<br><br> <pre>Examples:
    (concat 1 &#39;(2 3) 4)         ; results in a new vector [1 2 3 4]
    (concat [1 2] null 3 [4])   ; returns [1 2 3 4]</pre><br/><i>See also: nconc vcons append</i></td>
</tr>
 <tr>
<td>85</td> <td><b>cond</b></td> <td>built-in</td> <td>Syntax: (cond condExpr1 action1 ... condExprN actionN)<br/><br/>  The &#39;cond&#39; function evaluates each conditional expression and if it evaluates to true, execute the associated action. To specify the default action, make the condition &#39;true&#39; as shown in the example.<br><br> <pre>Examples:
    (cond
        (&lt; 1 x) &#39;less
        (&gt; 1 x) &#39;greater
        true &#39;equals
    )</pre><br/><i>See also: if case matchp</i></td>
</tr>
 <tr>
<td>86</td> <td><b>cons</b></td> <td>built-in</td> <td>Syntax: (cons arg list)<br/><br/>  The &#39;cons&#39; function constructs a new list. It adds the arg value to the list, returning a new list.<br><br> <pre>Examples:
    (cons 1 &#39;(2 3))         ; returns &#39;(1 2 3)
    (cons 1 [2 3])          ; returns a new vector [1 2 3]
    (cons 1 2)              ; returns a dotted pair (1 . 2)</pre><br/><i>See also: vcons &gt;cons</i></td>
</tr>
 <tr>
<td>87</td> <td><b>console/backcolor</b></td> <td>built-in</td> <td>Syntax: (console/backcolor color)<br/><br/>  Sets the console background color.<br><br> <pre>Examples:
    (console/backcolor &#39;black)</pre><br/><i>See also: cls console/cls console/forecolor</i></td>
</tr>
 <tr>
<td>88</td> <td><b>console/clear</b></td> <td>built-in</td> <td>Syntax: (console/clear)<br/><br/>  Clears the console screen.<br><br> <pre>Examples:
    (console/clear)          ; clears the screen</pre><br/><i>See also:</i></td>
</tr>
 <tr>
<td>89</td> <td><b>console/forecolor</b></td> <td>built-in</td> <td>Syntax: (console/forecolor color)<br/><br/>  Sets the console foreground color.<br><br><pre>Examples:
    (console/forecolor &quot;green&quot;) ; sets foreground color to green.
    ; using the ^ConsoleColor enum
    (console/forecolor .ConsoleColor/Yellow)</pre><br/></td>
</tr>
 <tr>
<td>90</td> <td><b>console/writeat</b></td> <td>built-in</td> <td>Syntax: (console/writeat [-foreground: color] [-background: color] xPos yPos &quot;Message&quot;)<br/><br/>  The console/writeat function writes a message at a specified location on the console. You can optionally specify the fore- and background colors to use when writing the text.<br><br><pre>Examples:
    (console/writeat -foreground: &quot;red&quot; -background: &quot;green&quot; 40 40 &quot;This is a message&quot;)</pre><br/></td>
</tr>
 <tr>
<td>91</td> <td><b>console/writeline</b></td> <td>built-in</td> <td>Syntax: (console/writeline arg1 arg2 arg3 ... argN)<br/><br/>  Print a string made out of the tostring&#39;s of each of the argument to the console adding a newline at the end. (This function is an alias for &#39;println&#39;.)<br><br><pre></pre><br/><i>See also: print println alert info erro</i></td>
</tr>
 <tr>
<td>92</td> <td><b>const</b></td> <td>built-in</td> <td>Syntax: (const symbol value)<br/><br/>  The &#39;const&#39; function reates a constant binding in the variable table at the current scope. Trying to set the value of a constant will result in an error. Constants can be removed with the &#39;undef&#39; function.<br><br><pre></pre><br/><i>See also: let def undef</i></td>
</tr>
 <tr>
<td>93</td> <td><b>contains?</b></td> <td>autoload.tl</td> <td>Syntax: [ (^BraidLang.RangeList rangeList) value | (^IDictionary dict) (^callable value) | (^IDictionary dict) value | (^HashSet hashset) (^callable value) | (^HashSet hashset) value | (^string str) (^callable value) | (^string str) value | (^IEnumerable lst) (^callable value) | (^IEnumerable lst) value ]<br/><br/>  Returns true if the argument list contains the specified value or matches the lambda. Does a shallow search.<pre></pre><br/></td>
</tr>
 <tr>
<td>94</td> <td><b>contains-key</b></td> <td>autoload.tl</td> <td>Syntax: (contains-key [structure key (valueOrFunc null)])<br/><br/>  Recursively searches a structure to see if there are dictionary entries matching the specified key and optional value. A vector of all matching dictionaries are returned.<br><br><pre>Examples:
    (let data {:a 1 :b {:aa 1 :bb 2} :c 3}
    (contains-key data :aa)     ; returns [ {:aa 1 :bb 2} ]
    (contains-key data :aa 5)   ; returns nothing because of value mismatch</pre><br/></td>
</tr>
 <tr>
<td>95</td> <td><b>contains-scalar</b></td> <td>autoload.tl</td> <td>Syntax: (contains-scalar [(^ISeq lst) value])<br/><br/>  Checks the argument tree to see if it contains specified scalar value Does a deep (recursive) search.<pre></pre><br/></td>
</tr>
 <tr>
<td>96</td> <td><b>continue</b></td> <td>built-in</td> <td>Syntax: (continue)<br/><br/>  Continues to the next iteration in a loop (while, foreach, forall) or in higher-order functions like map or filter.  <br><br> <pre>Examples:
    ; print numbers skipping the odd ones
    (foreach n [1 2 3 4] (if (% n 2) (continue)) (println n))
    ; same thing using &#39;map&#39;
    (range 10 | map (fn n -&gt; (if (% n 2) (continue) n)))</pre><br/><i>See also: foreach forall for while break recur return map filter zip</i></td>
</tr>
 <tr>
<td>97</td> <td><b>copy-vector</b></td> <td>autoload.tl</td> <td>Syntax: [ nil | lst ]<br/><br/>  Copy the argument collection into a new vector. It&#39;s always copied even if the argument was already a vector. Non-sequence types get wrapped into a single-element vector.<br><br><pre></pre><br/><i>See also: new-vector to-vector</i></td>
</tr>
 <tr>
<td>98</td> <td><b>cos</b></td> <td>autoload.tl</td> <td>Syntax: (cos [num])<br/><br/>  Compute the cosine of a number.<pre></pre><br/></td>
</tr>
 <tr>
<td>99</td> <td><b>count</b></td> <td>built-in</td> <td>Syntax: (count object)<br/><br/>  Returns the count of a collection. If the argument is a scalar, then it returns 1. If it&#39;s null, then the function returns 0. This is an alias for the &#39;count&#39; function.<br><br> <pre>Examples:
    (count &quot;abcdef&quot;)     ; returns 5
    (count [1 2 3])        ; returns 3
    (count &#39;(2 4 6 8)      ; returns 4
    (count 13              ; returns 1
    (count null)           ; returns 0</pre><br/><i>See also: count</i></td>
</tr>
 <tr>
<td>100</td> <td><b>CreateDelegate</b></td> <td>built-in</td> <td>Syntax: (CreateDelegate &lt;type&gt; &lt;lambda&gt;)<br/><br/>  Creates a delegate of the specified type out of a lambda.<br><br> <pre>Examples:
    ; create a delegate that takes one object argument and returns an object
    (createdelegate ^Func[object,object] (fn obj -&gt; (+ obj 1)))</pre><br/><i>See also: AsEventHandler</i></td>
</tr>
 <tr>
<td>101</td> <td><b>create-scriptblock</b></td> <td></td> <td>Syntax: (create-scriptblock [(^string bodyText)])<br/><br/>  Create a PowerShell ScriptBlock object. This object can be used as a braid function simply by assigning it to a variable then invoking it like any other function.<br><br> Exmples:<pre>
    (let sb (create-scriptblock &quot;param ($x) $x*2&quot;)) ; create the scriptblock and assign it to &#39;sb&#39;
    (sb 10)                                           ; returns 20</pre><br/></td>
</tr>
 <tr>
<td>102</td> <td><b>debug/breakPoint</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>103</td> <td><b>debug/pwatch</b></td> <td>autoload.tl</td> <td>Syntax: (debug/pwatch [input (^string tag) (outputFilter null)])<br/><br/>  The &#39;debug/pwatch&#39; (pipeline watch) function is a debugging utility that can be inserted into a pipeline to see what&#39;s passing through the pipeline. The output display will prefixed with the user specified tag to help correlate the output. An optional filter may be specified to reduce the ammount of output.<br><br><pre>Examples:
    (ls | pwatch &quot;files&quot; #&quot;.cs$&quot; | map .length)</pre><br/></td>
</tr>
 <tr>
<td>104</td> <td><b>decr</b></td> <td>built-in</td> <td>Syntax: (decr variableToDecrement)<br/><br/>  This function decrements the value in the named variable, returning the new value. The value in the variable must be of an integral type.<br><br><pre>Examples:
    (let a 5) (decr a) ; returns 4 and the value of &#39;a&#39; is now 4.</pre><br/></td>
</tr>
 <tr>
<td>105</td> <td><b>def</b></td> <td>built-in</td> <td>Syntax: (def name value)<br/><br/>  Set the value of the named variable if a variable with that name already exists or create a new variable in the current scope if it doesn&#39;t.<br><br> Note: If the name takes the form &#39;v1:v2:v3&#39; then destructuring will be done and the parts of the argument collection will be assigned to the variables.<br><br> <pre>Examples:
    (def foo 123)
    (def x:y:z [1 2 3 4 5])</pre><br/><i>See also: let defn &gt;def def setq</i></td>
</tr>
 <tr>
<td>106</td> <td><b>def-dynamic</b></td> <td>built-in</td> <td><br/><br/> Establish a binding in the dynamic scope of the calling function.<br><br><pre></pre><br/><i>See also: Get-Dynamic</i></td>
</tr>
 <tr>
<td>107</td> <td><b>defenum</b></td> <td>built-in</td> <td>Syntax: (defenum &lt;typeToCreate&gt; &lt;names...&gt;)<br/><br/>  A function for defining Braid enum types with a base type of integer. The enum members can be specified either as a simple list of names or using a single dictionary. If simple names are specified, they are automatically assigned values starting at 0, increasing by 1 for each member. If a dictionary is passed, member names names are taken from the keys and the dictionary values become the member values.<br><br> <pre>Examples:
    (defenum ^foo red blue green)               ; define an enum with 3 members with values 0, 1 and 2.
    (defenum ^foo {:red 10 :blue 20 :green 30}) ; define enum with values 10, 20 and 30.
    (defenum :foo a b c)                        ; use keyword for the typename instead of a type literal
    (defenum &quot;foo&quot; a b c)                     ; use a string for the typename instead of a type literal.
    (defenum &quot;${tn}&quot; a b c)                   ; use an expandable string for the typename instead of a type literal.</pre><br/><i>See also: deftype undeftype</i></td>
</tr>
 <tr>
<td>108</td> <td><b>definterface</b></td> <td>built-in</td> <td>Syntax: (definterface ^interfaceToDefine [[^type] &lt;memberVar&gt; ...]* [ :defm &lt;methodName&gt; (fn this &lt;vars..&gt; -&gt; &lt;actions...) ]*<br/><br/>  The &#39;definterface&#39; function allows you to define .NET interfaces in Braid. Data members can be specified by simply including their names. An optional type may also be specified for a data member. The &#39;:defm&#39; keyword is used to define method prototypes. The method body is specified as a lambda where the first parameter must be &#39;this&#39;. Any code in the member body is ignore as interfaces do not provide implementation.<br><br> <pre>Examples:
    (definterface ^foo a b c)            ; defines a type ^foo with 3 typeless data members
    (definterface ^bar ^int x ^int y)    ; defines a type ^foo with 2 int-typed data members
    ; define an interface with 2 data members + 1 method.
    (definterface ^bax x y :defm sum (fn this -&gt;))
    ; create a concrete type implementing that class.
    (deftype ^concretebax -implementsbax x y :defm sum (fn this -&gt; (+ (.this x) (.this y))))</pre><br/><i>See also: defmethod defobject definterface</i></td>
</tr>
 <tr>
<td>109</td> <td><b>defmacro</b></td> <td>built-in</td> <td>Syntax: (defmacro name body)<br/><br/>  Define a new macro to be processed at compile time. The defined macro will receive its arguments unevaluated and should return a new S-Expression to replace the original structure.<pre></pre><br/></td>
</tr>
 <tr>
<td>110</td> <td><b>defmethod</b></td> <td>built-in</td> <td>Syntax: (defmethod &lt;targetType&gt; &lt;methodName&gt; &lt;lambda&gt;)<br/><br/>  Add a method to an existing type definition. Methods require at least one parameter: the this pointer. This must be specified even if it is not used in the method body. Note that the method name must be a raw symbol, not a keyword i.e. it must be &quot;foo&quot; not &quot;:foo&quot;.<br><br> <pre>Examples:
    ; add a method to ^int
    (defmethod ^int hi (fn this name -&gt; (println &#39;Hi name &#39;its this)))
    (.hi 123 &#39;bob)</pre><br/><i>See also: deftype definterface</i></td>
</tr>
 <tr>
<td>111</td> <td><b>defn</b></td> <td></td> <td>Syntax: (defn funcName [ &quot;doc string&quot; ] [ ^returnType ] ( [args] functionBody | patternBody)<br/><br/>  The &#39;defn&#39; function allows you to define custom functions. The body of the function being defined can either be a &#39;conventional&#39; function or a pattern function. A literal string specified after the function name but before the argument vector or first pattern is treated as the  documentation string for that function. You can also specify the return type for the function by placing a type literal after the doc string but before the start of the function body.<br><br> Arguments to a conventional function are enclosed in a vector literal and can take several forms: a simple name such as &#39;num&#39;, a type-constrained argument such as (^int num), an initialized name such as &#39;(num 0)&#39; and finally as an initialized type-constrained name: &#39;(^int num 0)&#39;. Uninitialized names are manadatory (must be specified). Initialized names are optional arguments. If they are passed an explicit value, that value is used. If there is no formal argument corresponding to the name then the initializer value is used.<br><br> BUGBUGBUG -add stuff about named parameters.<br><br> <pre>Examples:
    (defn sqr &quot;compute the square root.&quot; [x] (* x x))
    (defn fact &quot;compute factorial&quot; [n] (if (n &lt; 1) 1 (* n (fact (- n 1)))))
    (defn fact ^int [(^int n)]
        (if (n &lt; 1)
            1 (* n (fact (- n 1)))
        )
    )
    (defn fib &quot;compute fib number&quot;
        | 0 -&gt; 1
        | 1 -&gt; 1
        | (+ (fib (- n 1)) (fib (- n 2)))
    )</pre><br/><i>See also: defmacro defspecial deftype</i></td>
</tr>
 <tr>
<td>112</td> <td><b>defobject</b></td> <td>built-in</td> <td>Syntax: (defobject val1 name2 val2 name3 val3 ... nameN valN)<br/><br/>  Create a PowerShell PSCustomObject.<br><br> <pre>Examples:
    (defobject :a 1 :b 2) ; returns a PSCustomObject with a=1 and b=2.</pre><br/><i>See also: deftype definterface project</i></td>
</tr>
 <tr>
<td>113</td> <td><b>defspecial</b></td> <td>built-in</td> <td>Syntax: (defspecial name [args] body<br/><br/>  Defines a &#39;special form&#39;. Special forms are functions that will receive their arguments unevaluated. Braid has many built-in special forms such as &#39;if&#39;, &#39;while&#39;, &#39;let&#39; and so on. Using &#39;defspecial&#39;, you can define your own control structures, as shown in the examples. Typically, defspecial functions also use the &#39;upvar&#39; and &#39;upDo&#39; functions to implement these control structures.<br><br> <pre>Examples:
    ; Define a &#39;forall&#39; variant that uses two variables - item and count
    (defspecial forall-with-count
        &quot;A forall loop with item and count variables.&quot;
        [(^symbol itemVar) (^symbol countVar) lst &amp;args]
        ; bind the loop variables in the caller&#39;s context
        (upvar itemVar  &#39;iv)
        (upvar countVar &#39;cv)
        ; wrap the body in a do expression
        (let body (cons &#39;do args))
        ; initilize the count variable
        (let cv 0)
        ; Now execute the loop
        (forall iv (upDo lst)
            (incr cv)
            (upDo body)
        )
    )
    ; try it out
    (forall-with-count i c [:a :b :c]
        [i c]
    )</pre><br/><i>See also: defn defmacro deftype</i></td>
</tr>
 <tr>
<td>114</td> <td><b>deftype</b></td> <td>built-in</td> <td>Syntax: (deftype ^typeToDefine [^type] &lt;memberVar&gt; ... [ :defm &lt;methodName&gt; (fn this &lt;vars..&gt; -&gt; &lt;actions...) ]<br/><br/>  The &#39;deftype&#39; function allows you to define types in Braid. Data members can be specified by simply including their names. An optional type may also be specified for a data member. The &#39;:defm&#39; keyword is used to define a method. The method body is specified as a lambda where the first parameter must be &#39;this&#39;. &#39;this&#39; contains a reference to the current instance so to access a member variable &#39;a&#39;, you must write &#39;(.a this)&#39;. Methods can also be defined independently of the type using the &#39;defmethod&#39; function. Re-executing a &#39;deftype&#39; call will redefine existing any existing types with the same name.<br><br> <pre>Examples:
    (deftype ^foo a b c)            ; defines a type ^foo with 3 typeless data members
    (deftype ^bar ^int x ^int y)    ; defines a type ^foo with 2 int-typed data members
    ; define a type with 2 data members + 1 method.
    (deftype ^bax x y :defm sum (fn this -&gt; (+ (.this x) (.this y))))</pre><br/><i>See also: defmethod defobject definterface</i></td>
</tr>
 <tr>
<td>115</td> <td><b>dict/accessor</b></td> <td>built-in</td> <td>Syntax: (dict/accessor dictKey)<br/><br/>  The &#39;dict/accessor&#39; function takes a dictionary key (typically a string) and generates a custom dictionary accessor function. This function can then be used to retrieve the value for that key from an arbitrary dictionary. If the key is not present, an error is thrown.  If the function is applied against an ^IEnumerable, then the designated member from each element in the collection is aggregated into a result vector. Note that in the enumerable case, if the element is not a dictionary, it is simply skipped.  Using a dictionary accessor for commonly retrieved keys can produce some signifinant performance improvements.<br><br> <pre>Examples:
    (let afunc (dict/accessor :foo))
    (afunc {:foo 1 :bar 2})             ; returns 1
    (afunc [{:foo 1} {:foo 2}])         ; returns [1 2]</pre><br/><i>See also: !!</i></td>
</tr>
 <tr>
<td>116</td> <td><b>dict?</b></td> <td>built-in</td> <td>Syntax: (dict? &lt;expression&gt;)<br/><br/>  Returns true if the argument expression resolves to a dictionary.<br><br> <pre>Examples:
    (dict? {:a 1 :b 2}      ; returns true
    (dict? 1)               ; returns false</pre><br/><i>See also: new-dict</i></td>
</tr>
 <tr>
<td>117</td> <td><b>dirs</b></td> <td>autoload.tl</td> <td>Syntax: (dirs [(^int? entry -1)])<br/><br/>  function to list and navigate the directory stack<pre></pre><br/></td>
</tr>
 <tr>
<td>118</td> <td><b>distinct</b></td> <td>built-in</td> <td>Syntax: (distinct &lt;collection&gt; [&lt;accessorFunction&gt;])<br/><br/>  Returns only the distinct items in the argument collection. The result is returned as a vector. An optional accessor function can be supplied which extracts the property to compare.<br><br> <pre>Examples:
    (distinct [1 2 2 3 4 4])    ; returns [1 2 3 4]
    (random 100 | distinct)     ; remove duplicates in the collection returned by &#39;random&#39;</pre><br/><i>See also: except unique union intersect</i></td>
</tr>
 <tr>
<td>119</td> <td><b>div</b></td> <td>autoload.tl</td> <td>Syntax: [ m n | m ]<br/><br/>  Performs the &#39;div&#39; operation on the arguments returning the integer part of the division.<br><br> <pre>Examples:
    (div 9 2) ; returns 4</pre><br/><i>See also: / %</i></td>
</tr>
 <tr>
<td>120</td> <td><b>do</b></td> <td>built-in</td> <td>Syntax: (do &lt;expr1&gt; &lt;expr2&gt; &lt;expr3&gt; ... &lt;exprn&gt;)<br/><br/>  Executes a series of expressions, one at a time and in order returning the result of the last expression as the final value of the expression. Do is commonly used with the &#39;if&#39; function when you want to have multiple expressions in the &#39;if&#39; or &#39;else&#39; parts of the statemant. The &#39;when&#39; and &#39;unless&#39; macros use &#39;do&#39; for this purpose.<br><br> <pre>Examples:
    (do 1 2 3 4)                            ; returns 4
    (if true (do (println 1) (println 2)))  ; prints 1 and then 2.</pre><br/><i>See also: if while when unless</i></td>
</tr>
 <tr>
<td>121</td> <td><b>doc</b></td> <td>autoload.tl</td> <td>Syntax: (doc [function])<br/><br/>  A function to quickly get the documentation string for a function<pre></pre><br/></td>
</tr>
 <tr>
<td>122</td> <td><b>drain</b></td> <td>built-in</td> <td>Syntax: (drain &lt;enumerable&gt; ...)<br/><br/>  This function ignores any non-enumerable arguments and returns null. Any enumerable arguments are run to completion i.e. they are drained. This is particularly important with lazy functions like range or lazy-map which must be specifically enumerated to have any effect. In contrast, if you used &#39;void&#39; instead of &#39;drain&#39;, the enumerables will not be run.<br><br> <pre>Examples:
    ; the following will print each value then return null.
    (range 10 | lazy-map (fn x -&gt; (info x) (* x x)) | drain)
    ; in contrast, the same expression but with void will print nothing
    (range 10 | lazy-map (fn x -&gt; (info x) (* x x)) | void)</pre><br/><i>See also: void lazy-map lazy-filter</i></td>
</tr>
 <tr>
<td>123</td> <td><b>dump-error</b></td> <td>powershell</td> <td>Syntax: (dump-error)<br/><br/>  Dump the contents of the last PowerShell/.NET exception that occurred. This will give you the .NET stack trace for the error instead of the Braid stack trace. This is implemented using the PowerShell $error[0] variable.<br><br><pre></pre><br/><i>See also: show-callstack</i></td>
</tr>
 <tr>
<td>124</td> <td><b>each</b></td> <td>built-in</td> <td>Syntax: (each list function)<br/><br/>  Like &#39;map&#39;, the &#39;each&#39; function is usually used in pipelines to process items from the input sequence. It takes a list of values and a function to apply to each value Functions can either be predefined functions, property functions or lambdas. However, unlike &#39;map&#39;, the &#39;each&#39; function always returns a singke null so its primary use case is in side effects.<br><br> <pre>Examples:
    (map &lt;list&gt; &lt;function&gt;) or (&lt;list&gt; | map &lt;function&gt;)
    (range 10 | each println)   ; maps the &#39;println&#39; onto each number in the range
                                ; then returns null.</pre><br/><i>See also: map flatmap lazy-map filter reduce</i></td>
</tr>
 <tr>
<td>125</td> <td><b>echo</b></td> <td>built-in</td> <td>Syntax: (echo args...)<br/><br/>  The &#39;echo&#39; is the &#39;identity function&#39; and simply returns it&#39;s arguments unmodified. If multiple arguments are specified then a collection is returned. If only a single value is provided, then it will be returned as scalar.<br><br> <pre>Examples:
    (echo 123)              ; returns 123
    (echo 1 2 3 4)          ; returns [1 2 3 4]</pre><br/><i>See also: id echo</i></td>
</tr>
 <tr>
<td>126</td> <td><b>edit</b></td> <td>autoload.tl</td> <td>Syntax: (edit [file])<br/><br/>  Launch gvim on the argument file.<pre></pre><br/></td>
</tr>
 <tr>
<td>127</td> <td><b>edit-distance</b></td> <td>built-in</td> <td>Syntax: (edit-distance &lt;string1&gt; &lt;string2&gt;)<br/><br/>  The &#39;edit-distance&#39; function computes the &quot;edit distance&quot; between the two argument strings using the Damerau-Levenshtein algorithm - a metric of similarity based on inserts, removes and replacements.<br><br><pre>Examples:
    (edit-distance &quot;foo&quot; &quot;boo&quot;)     ; returns an edit distance of 1 (&#39;f&#39; -&gt; &#39;b&#39;)</pre><br/></td>
</tr>
 <tr>
<td>128</td> <td><b>env</b></td> <td>autoload.tl</td> <td>Syntax: (env [(^regex? pattern #&quot;.&quot;)])<br/><br/>  Gets all of the defined environment variables. An optional pattern (regex) can be specified to filter the list. An option &#39;-scope:&#39; can be specified to choose whether to dump the process, user or machine environment variables.<br><br> <pre>Examples:
    (env)                           ; get all process-scoped environment variables
    (env #&quot;pro&quot;)                  ; get all process-scoped variables whose name matches &#39;pro&#39;
    (env #&quot;pro&quot; -scope: &#39;machine) ; get all machine-scoped variables matching &#39;pro&#39;</pre><br/><i>See also: get-env set-env</i></td>
</tr>
 <tr>
<td>129</td> <td><b>environment</b></td> <td>built-in</td> <td>Syntax: (environment arg1 arg2)<br/><br/>  Returns the active lexical environment.<br><br><pre></pre><br/><i>See also: bind</i></td>
</tr>
 <tr>
<td>130</td> <td><b>eq?</b></td> <td>built-in</td> <td>Syntax: (eq? arg1 arg2)<br/><br/>  This is the polymorphic equality comparison function (eq?) which works on any types that support comparisons (IComparable). (Note: eq? is actually an  alias for the &#39;==&#39; function.) Value semantics are used for the core braid types of vectors, dictionaries and lists.<br><br> <pre>Examples:
    (eq? 5 5)           ; returns true
    (eq? 5 6)           ; returns false
    (== [1 2] [1 2])    ; returns true
    (== [1 2] [1])      ; returns false
    (== {:a 1} {:a 1})  ; returns true</pre><br/><i>See also: == !=</i></td>
</tr>
 <tr>
<td>131</td> <td><b>error</b></td> <td>built-in</td> <td>Syntax: (error arg1 arg2 arg3 ... argn)<br/><br/>  This function prints an error string to the console in red.<br><br> <pre>Examples:
    (error &quot;This is an information message.&quot;)
    (error &#39;this &#39;is &#39;a &#39;message &#39;in &#39;pieces.)
    (error &quot;The value of 2+2 is&quot; (+ 2 2))</pre><br/><i>See also: println info warn</i></td>
</tr>
 <tr>
<td>132</td> <td><b>eval</b></td> <td>built-in</td> <td>Syntax: (eval &lt;exprList&gt;)<br/><br/>  Evaluate an s-expression as a function in the current scope.<br><br><pre>Examples:
    (eval &#39;(+ 2 3))                                  ; returns 5
    (eval (list &#39;forall &#39;n [1 2 3] &#39;n))              ; returns [1 2 3]
    (eval (cons + (cons (list * 2 3) (cons 4 nil)))) ; returns 10</pre><br/></td>
</tr>
 <tr>
<td>133</td> <td><b>eval-string</b></td> <td>built-in</td> <td>Syntax: (eval-string &lt;stringToEval&gt;)<br/><br/>  Parses a string into an s-expression then evaluate it using &#39;eval&#39;.<br><br> <pre>Examples:
    (eval &quot;(+ 2 3)&quot;)   ; returns 5</pre><br/><i>See also: eval</i></td>
</tr>
 <tr>
<td>134</td> <td><b>even?</b></td> <td>built-in</td> <td>Syntax: (even? argument)<br/><br/>  The &#39;even?&#39; function returns true if its argument is an even number.<br><br> <pre>Examples:
    (even? 4)                       ; returns true
    (even? 5)                       ; returns false</pre><br/><i>See also: none? some? number? number? odd?</i></td>
</tr>
 <tr>
<td>135</td> <td><b>except</b></td> <td>built-in</td> <td>Syntax: (except &lt;list1&gt; &lt;list2&gt;)<br/><br/>  Computes the difference between two list. All of the items in list 1 that aren&#39;t in list 2 are returned.<br><br> <pre>Examples:
    (except [1 2 3 4] [2 4]) ; returns [1 3]</pre><br/><i>See also: union intercection distinct</i></td>
</tr>
 <tr>
<td>136</td> <td><b>extract-min</b></td> <td>autoload.tl</td> <td>Syntax: [ nil _ | _ 0 r | (^vector lst) n (r []) ]<br/><br/>  Extract (remove and return) the n smallest items from a vector.<pre></pre><br/></td>
</tr>
 <tr>
<td>137</td> <td><b>fact</b></td> <td>stdin</td> <td>Syntax: (fact [n])<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>138</td> <td><b>fgrep</b></td> <td>autoload.tl</td> <td>Syntax: (fgrep [args])<br/><br/>  Utility to recursively find files containing the specified regular expression. By default only &#39;*.tl&#39; files are scanned.<pre></pre><br/></td>
</tr>
 <tr>
<td>139</td> <td><b>fib</b></td> <td>autoload.tl</td> <td>Syntax: [ 0 | 1 | number ]<br/><br/>  Compute the fibonocci number for the argument using the naive recursive algorithm and bigints.<pre></pre><br/></td>
</tr>
 <tr>
<td>140</td> <td><b>file/basename</b></td> <td>autoload.tl</td> <td>Syntax: [ ^Io.File | path ]<br/><br/>  Gets the basename part of a file name<pre></pre><br/></td>
</tr>
 <tr>
<td>141</td> <td><b>file/dir-exists</b></td> <td>autoload.tl</td> <td>Syntax: (file/dir-exists [(^string path)])<br/><br/>  Test to see if a directory exists<pre></pre><br/></td>
</tr>
 <tr>
<td>142</td> <td><b>file/dirname</b></td> <td>autoload.tl</td> <td>Syntax: [ ^Io.File | path ]<br/><br/>  Gets the directory part of a file name<pre></pre><br/></td>
</tr>
 <tr>
<td>143</td> <td><b>file/exists</b></td> <td>autoload.tl</td> <td>Syntax: (file/exists [(^string path)])<br/><br/>  Test to see if a file exists<pre></pre><br/></td>
</tr>
 <tr>
<td>144</td> <td><b>file/extension</b></td> <td>autoload.tl</td> <td>Syntax: [ ^Io.File | (^string path) | ^Io.File (^string newExtension) | ^string (^string newExtension) ]<br/><br/>  Gets or sets the extension on a file name<pre></pre><br/></td>
</tr>
 <tr>
<td>145</td> <td><b>file/filename</b></td> <td>autoload.tl</td> <td>Syntax: [ ^Io.File | path ]<br/><br/>  Gets the directory part of a file name<pre></pre><br/></td>
</tr>
 <tr>
<td>146</td> <td><b>file/isRooted</b></td> <td>autoload.tl</td> <td>Syntax: (file/isRooted [(^string path)])<br/><br/>  Test to see if a pathname is absolute<pre></pre><br/></td>
</tr>
 <tr>
<td>147</td> <td><b>file/join-path</b></td> <td>autoload.tl</td> <td>Syntax: (file/join-path [args])<br/><br/>  Join path components into a single string using the system appropriate path separator.<pre></pre><br/></td>
</tr>
 <tr>
<td>148</td> <td><b>file/parse</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>149</td> <td><b>file/read-lines</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>150</td> <td><b>file/setWriteTime</b></td> <td>autoload.tl</td> <td>Syntax: (file/setWriteTime [(^string pathToSet) (targetTime (.datetime/now))])<br/><br/>  Sets the last write time on the file specified to the targetTime. If no time is specified, then the current time is used. (Similar to the &#39;touch&#39; utility.<pre></pre><br/></td>
</tr>
 <tr>
<td>151</td> <td><b>file/tempFileName</b></td> <td>autoload.tl</td> <td>Syntax: (file/tempFileName [(^string extension null)])<br/><br/>  Gets the name of a temporary file, optionally specifying the file extension. When specifying the extension, the leading dot may be omitted.<br><br> <pre>Examples:
    (file/tempfilename)         ; returns a temp file name with &#39;.tmp&#39; extension
    (file/tempfilename &#39;json)   ; returns a temp file name with &#39;.json&#39; extension
    (file/tempfilename &#39;.tl)    ; returns a temp file name with &#39;.tl&#39; extension</pre><br/><i>See also: file/extension file/basename file/dirname file/filename</i></td>
</tr>
 <tr>
<td>152</td> <td><b>files</b></td> <td>autoload.tl</td> <td>Syntax: (files [(^regex? pattern #&quot;.&quot;) (^Callable printFn println)])<br/><br/>  Prints out the &#39;*.tl&#39; files in columns.<pre></pre><br/></td>
</tr>
 <tr>
<td>153</td> <td><b>filter</b></td> <td>built-in</td> <td>Syntax: (filter [-not] &lt;list&gt; &lt;predicate&gt;)<br/><br/> Filters the input collection based on the results of evaluating the predicate function on each item. The predicate can be a lambda literal, a named function, a member accessor, a type literal, a regular expression or a dictionary literal. If a dictionary literal is provided, &#39;filter&#39; will use property pattern matching as the filter criteria. The sense of the comparison can be changed with the &#39;-not&#39; flag. The &#39;lazy-&#39; variant returns an enumerable instead of a collection. Individual values can then be pulled from the enumerable as needed thus only evaluating as much as is necessary.  Either of the forms can use &#39;break&#39; in the predicate function to terminate the search at the current item. You can also use &#39;continue&#39; to skip over the current item in the list and keep searching.<br><br> <pre>Examples:
    (range 10 | filter (fn n -&gt; (== (% n 2) 0))) ; returns [2 4 6 8 10]
    (range 10 | filter even?)                    ; returns [2 4 6 8 10]
    (range 10 | filter -not even?)               ; returns [1 3 5 7 9]
    (range 20 | filter #&quot;2&quot;)                     ; returns [2 12 20]
    (get-process | filter .cpu)                  ; returns all procs that have used CPU
    ; use property patterns to find Error entries whose message matches the regex #&quot;timeout&quot;
    (get-eventlog -log: &quot;system&quot; -newest: 1000 | filter {entrytype &quot;error&quot; message #&quot;timeout&quot;})
    ; find element &#39;99&#39; in the input collection, stopping the search when it&#39;s found
    (range 100000 | filter (fn n -&gt; (if (== n 99) (break))))</pre><br/><i>See also: filter lazy-filter map lazy-map each</i></td>
</tr>
 <tr>
<td>154</td> <td><b>first</b></td> <td>built-in</td> <td>Syntax: (first &lt;collection&gt; [&lt;num&gt;])<br/><br/>  The &#39;first&#39; function returns the first &lt;num&gt; items from the argument collection. If &lt;num&gt; is not specified, it defaults to 1. If the collection is a string, &#39;first&#39; returns the first &lt;num&gt; characters. If the argument is not a collection, then it is simply returned.<br><br> <pre>Examples:
    (first &#39;(1 2 3))  ; returns 1
    (first [4 5 6])   ; returns 4
    (first &quot;abc&quot;)     ; returns &quot;a&quot;
    (first 1)         ; returbs 1</pre><br/><i>See also: car cdr tail last</i></td>
</tr>
 <tr>
<td>155</td> <td><b>fixit</b></td> <td>autoload.tl</td> <td>Syntax: (fixit [])<br/><br/>  Resets the screen colors to white on black.<pre></pre><br/></td>
</tr>
 <tr>
<td>156</td> <td><b>flatmap</b></td> <td>built-in</td> <td>Syntax: (flatmap list function)<br/><br/>  The &#39;flatmap&#39; function is usually used in pipelines to process items in the pipeline.It takes a list of values and a function to apply to each value as in: - (flatmap &lt;list&gt; &lt;function&gt;) or (&lt;list&gt; | flatmap &lt;function&gt;) Functions can either be predefined functions, property functions or lambdas. As opposed to the map function, &#39;flatmap&#39; flattens its result so if the function returns a list, that list will be stiched into the result list rather than appearing as a discrete list. The distinction between &#39;flatmap&#39; and &#39;lazy-flatmap&#39; is that &#39;flatmap&#39; returns the entire result collection whereas &#39;lazy-flatmap&#39; returns an enumerable immediately and te values can be pulled out as needed.<br><br> <pre>Examples:
    (range 10 | flatmap sqr)                  ; maps &#39;sqr&#39; onto each number from the range
    (ls &#39;*.cs | flatmap .length)              ; gets the property .length from each file object
                                           ; through the pipeline
    (range 10 | flatmap (fn x -&gt; [x x]))      ; returns [1 1 2 2 3 3 ...]</pre><br/><i>See also: map filter flatten</i></td>
</tr>
 <tr>
<td>157</td> <td><b>flatten</b></td> <td>built-in</td> <td>Syntax: (flatten args...)<br/><br/>  The &#39;flatten&#39; function recursively flattens all of its arguments into a single collection.<br><br> Example:<br><br><pre>
    (flatten &#39;(1 (2 3) 4 ((5))))    ; returns &#39;(1 2 3 4 5)
    (flatten &#39;(1 2 3) [4 [5 6]] 7)  ; returns &#39;(1 2 3 4 5 6 7)</pre><br/><i>See also: flatmap</i></td>
</tr>
 <tr>
<td>158</td> <td><b>floor</b></td> <td>autoload.tl</td> <td>Syntax: (floor [num])<br/><br/>  Compute the floor of a number.<pre></pre><br/></td>
</tr>
 <tr>
<td>159</td> <td><b>fmt</b></td> <td>autoload.tl</td> <td>Syntax: (fmt [args])<br/><br/>  Utility to format strings (using String.Format)<pre></pre><br/></td>
</tr>
 <tr>
<td>160</td> <td><b>fn</b></td> <td></td> <td>Syntax: (fn [args])<br/><br/>  Macro for creating function literals of the form (fn &lt;args&gt; -&gt; &lt;body&gt;).<br><br><pre>Examples:
    (fn a b c -&gt; (+ a b c))                         ; define a function literal that adds 3 values
    (range 10 | map (fn x -&gt; (* x x)) | sum)        ; use a function literal for squaring numbers
    (range 10 | map (fn x -&gt; (println x) (* x x)))  ; Multiple expressions are allowed
    (def sqr (fn x -&gt; (* x x))) (sqr 4)             ; define a &#39;sqr&#39; function then call it - returns 16
    (fn (^int a) (^int b 1) -&gt; (+ a b)              ; arguments can have type constraints and initializers</pre><br/></td>
</tr>
 <tr>
<td>161</td> <td><b>foldl</b></td> <td>built-in</td> <td>Syntax: (foldl &lt;list&gt; &lt;function&gt; [seed])<br/><br/>  This function iterates through a list applying the function to each of the items and accumulating a result. An optional seed value can be provided.<br><br> <pre>Examples:
    (range 10 | foldl (fn x y -&gt; (+ x y)))               ; sum the numbers from 1 to 10 using a lambda
    (range 10 | foldl (fn x y -&gt; (* x y)))               ; computer 10 factorial
    (range 10 | foldl +)                                 ; sums the numbers 1-10 using the &#39;+&#39; function.
    (ls &#39;*.tl | foldl (fn x y -&gt; (+ x (.length y))) 0)   ; sums the length of the *.tl files</pre><br/><i>See also: reduce foldl foldr unfold</i></td>
</tr>
 <tr>
<td>162</td> <td><b>foldr</b></td> <td>built-in</td> <td>Syntax: (foldr &lt;list&gt; &lt;function&gt; [seed])<br/><br/>  This function iterates through a list applying the function to each pair of the items and accumulating a result. An optional seed value can be provided. Unlike reduce/foldl, which folds from left to right whereas &#39;foldr&#39; folds right-to-left. <br><br> <pre>Examples:
    (range 10 | foldr (fn x y -&gt; (+ x y)))              ; sum the numbers from 1 to 10 using a lambda
    (range 10 | foldr (fn x y -&gt; (* x y)))              ; computer 10 factorial
    (range 10 | foldr +)                                ; sums the numbers 1-10 using the &#39;+&#39; function.
    (range 10 | foldr (fn x y -&gt; (- x y)))              ; returns -5</pre><br/><i>See also: reduce foldl foldr unfold</i></td>
</tr>
 <tr>
<td>163</td> <td><b>for</b></td> <td></td> <td>Syntax: (for [init-expr test-expr incr-expr args])<br/><br/>  Macro implementing the for &quot;statement&quot; built on top of the while function.<br><br><pre>Examples:
    (for (def i 0) (&lt;= i 10) (incr i)
        (println &quot;Hi there&quot;)
        (println &quot;i is&quot; i)
    )</pre><br/></td>
</tr>
 <tr>
<td>164</td> <td><b>forall</b></td> <td>built-in</td> <td>Syntax: (forall var &lt;list&gt; &lt;expr1&gt; &lt;expr2&gt; ... &lt;exprn&gt;)<br/><br/>  The &#39;forall&#39; function iterates over the argument list, binding each value to the supplied variable and then executes all of the body expressions. The &#39;forall&#39; function returns the value of evaluating the last body expression for all iterations.<br><br> <pre>Examples:
    (let x (foreach i (range 5) (* i i))) ; x is set to (1 2 9 16 250</pre><br/><i>See also: foreach map filter</i></td>
</tr>
 <tr>
<td>165</td> <td><b>foreach</b></td> <td>built-in</td> <td>Syntax: (foreach var &lt;list&gt; &lt;expr1&gt; &lt;expr2&gt; ... &lt;exprn&gt;)<br/><br/>  The &#39;foreach&#39; function iterates over the argument list, binding each value to the supplied variable and then executes all of the body expressions.  The &#39;var&#39; specification can be a simple variable e.g. &#39;foo&#39; or a pattern &#39;a:b:c&#39; in which case destructuring is performed on each item or finally, it can be a literal vector of variables in which case multiple items will be pulled from the list. Lite the pipeline &#39;each&#39; function, the standalone &#39;foreach&#39; function returns no value (null).<br><br> <pre>Examples:
    (foreach i (range 1) (println i)) ; print numbers from 1 to 10
    (foreach x:y: [[1 2] [3 4]] (println (+ x y)))
    (foreach [a b] [1 2 3 4] (println (+ a b)))
    (foreach [a:b: c:d:] [[1 2] [3 4]] (println [(+ a b) (+ c d)))</pre><br/><i>See also: forall map filter each</i></td>
</tr>
 <tr>
<td>166</td> <td><b>from</b></td> <td></td> <td>Syntax: (from [(^VectorLiteral vars) args])<br/><br/>  The &#39;from&#39; macro is a list comprehension operator that iterates over multiple lists. It is structurally similar to &#39;let&#39; in that the first argument is a vector composed of variable/list pairs and the remaining args represent the executable body of the &#39;statement&#39;. Implementation-wise, this macro uses &#39;forall -flatten&#39; to maintain a result depth of 1.<br><br>   (from [a [1 2 3] b (range 5) c [10 20 30]]   )<pre>Examples:
      [a b c]</pre><br/></td>
</tr>
 <tr>
<td>167</td> <td><b>function?</b></td> <td>built-in</td> <td>Syntax: (function? &lt;expression&gt;)<br/><br/>  Returns true if the argument expression resolves to a function.<br><br><pre>Examples:
    (function? sqr)     ; returns true
    (function? &quot;sqr&quot;)   ; returns false</pre><br/></td>
</tr>
 <tr>
<td>168</td> <td><b>functions</b></td> <td>built-in</td> <td>Syntax: (functions [&lt;filter-regex&gt;])<br/><br/>  Return a list of all defined functions, special forms and macros. An optional regex can be used to filter the names that are returned. Functions are returned as key/value pairs where the .key is the function name and the .value is the function definition.<pre></pre><br/></td>
</tr>
 <tr>
<td>169</td> <td><b>funcToCheck</b></td> <td>built-in</td> <td>Syntax: (group &lt;collection&gt; &lt;byFunction&gt; &lt;processGroupFn&gt;)<br/><br/>  The &#39;group&#39; function groups members of a collection together in a dictionary by the value returned by the &lt;byFunction&gt;. Once the groups have been created, the &lt;processGroupFn&gt; is applied to each group. This function can be used to do things like rrplace the group with the count of group elements or compute the sum of a property on an element.<br><br><pre>Examples:
    (ls -file | group .extension count)   ; counts the number of files per extension
    ; get the total length of each type of file
    (ls -file | group .extension (fn files -&gt; (sum files .length)))
    ; count the number of times a word appears in a file
    (read-data words.txt | re/split | group echo count)</pre><br/></td>
</tr>
 <tr>
<td>170</td> <td><b>gcd</b></td> <td>autoload.tl</td> <td>Syntax: [ x 0 | x y ]<br/><br/>  Compute the greatest common divisor for two numbers<pre></pre><br/></td>
</tr>
 <tr>
<td>171</td> <td><b>gdv</b></td> <td>built-in</td> <td>Syntax: (gdv &lt;symbol&gt;)<br/><br/>  This function retrieves the ^BraidVariable object associated with the argument symbol looking up the dynamic (runtime) callstack. This is particularly useful in the debugger.<br><br><pre></pre><br/><i>See also: get def let</i></td>
</tr>
 <tr>
<td>172</td> <td><b>gen-symbol</b></td> <td>built-in</td> <td>Syntax: (get-symbol)<br/><br/>  Generates and returns a new unique symbol. This is used in macros to create unique symbols for the generated code.<pre></pre><br/></td>
</tr>
 <tr>
<td>173</td> <td><b>get</b></td> <td>built-in</td> <td>Syntax: (get &lt;expression&gt;)<br/><br/>  Retrieves the value of the symbol identified by the argument expression.<br><br><pre></pre><br/><i>See also: global globalq</i></td>
</tr>
 <tr>
<td>174</td> <td><b>get-args</b></td> <td>built-in</td> <td>Syntax: (get-args)<br/><br/>  Retrieves a vector containing the arguments to the current function. This is typically used when creating error messages in pattern defaults.<br><br><pre>Examples:
    (matchp 1 2 3 | -&gt; (get-args))      ; returns [1 2 3]
    ; the following throws an exception whose string contains the actual args:
    ;    Expected one integer argument, not &lt;&lt;1 2 3&gt;&gt; 
    (matchp 1 2 3
    | (^int x) -&gt; (+ x 2)
    | -&gt; (throw &quot;Expected one integer argument, not &lt;&lt;&gt;&gt;&quot;)
    )</pre><br/></td>
</tr>
 <tr>
<td>175</td> <td><b>Get-Assoc</b></td> <td>built-in</td> <td>Syntax: (get-assoc object [key])<br/><br/>  This function allows you to retrieve tagged data from an arbitrary object. For example, if you tagged the number 1 with a message as follows: you could then retrieve it with<br><br><pre>
    (set-assoc 1 :message &quot;Hi there&quot;)
    (get-assoc 1 :message)</pre><br/><i>See also: set-assoc</i></td>
</tr>
 <tr>
<td>176</td> <td><b>get-dynamic</b></td> <td>built-in</td> <td>Syntax: (get-dynamic &lt;symbol&gt;)<br/><br/>  This function retrieves the ^BraidVariable object associated with the argument symbol looking up the dynamic (runtime) callstack. This is particularly useful in the debugger.<br><br><pre></pre><br/><i>See also: get def let</i></td>
</tr>
 <tr>
<td>177</td> <td><b>get-env</b></td> <td>autoload.tl</td> <td>Syntax: (get-env [(^string? varname) (^EnvironmentVariableTarget scope .EnvironmentVariableTarget/Process)])<br/><br/>  This function gets the named environment variable. The &#39;-scope:&#39; option allows variables to be retrieved at either machine or user scope as well at process scope (the default).<br><br> <pre>Examples:
    (get-env &#39;zork)</pre><br/><i>See also: set-env env</i></td>
</tr>
 <tr>
<td>178</td> <td><b>Get-FileHash</b></td> <td>autoload.tl</td> <td>Syntax: (Get-FileHash [fileToHash])<br/><br/>  The &#39;Get-FileHash&#39; function computes the MD5 hash for the specified file and then returns a vector of the form:<br><br><pre>Examples:
    [ &lt;fileToHash&gt; &lt;md5-hash&gt; ]
    (get-filehash &#39;autoload.tl)</pre><br/></td>
</tr>
 <tr>
<td>179</td> <td><b>getfunc</b></td> <td>built-in</td> <td>Syntax: (getfunc &lt;object&gt; [-caller])<br/><br/>  The &#39;getfunc&#39; function will return a function object corresponding to the object passed in. This includes returning function objects for regular expressions, dictionaries and vectors. If the optional &#39;-caller&#39; switch is specified, the function will be resolved in the caller&#39;s dynamic scope rather than the current scope.<br><br> <pre>Examples:
    (getfunc &#39;+)            ; return the function associated with &#39;+&#39;
    (getfunc {:a 1 :b 2}    ; return a function to look up items in the dictionary.</pre><br/><i>See also: compose partial compliment</i></td>
</tr>
 <tr>
<td>180</td> <td><b>get-help-text</b></td> <td>braidhelp.tl</td> <td>Syntax: (get-help-text [func])<br/><br/>  Get the associated help text for this item<pre></pre><br/></td>
</tr>
 <tr>
<td>181</td> <td><b>getmacro</b></td> <td>autoload.tl</td> <td>Syntax: (getmacro [(^regex? namePattern #&quot;.&quot;)])<br/><br/>  Get the macro associated with the argument symbol. If the argument is null then the entire table is returned.<pre></pre><br/></td>
</tr>
 <tr>
<td>182</td> <td><b>Get-Method</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>183</td> <td><b>get-min</b></td> <td>autoload.tl</td> <td>Syntax: [ nil _ (r []) | _ 0 (r []) | lst n (r []) ]<br/><br/>  Find and return the n smallest items from a list.<pre></pre><br/></td>
</tr>
 <tr>
<td>184</td> <td><b>get-prop</b></td> <td>autoload.tl</td> <td>Syntax: (get-prop [lst (^string property)])<br/><br/>  Get the named property from each of the elements in the argument list. For exampple: which returns a list of the values of the &#39;length&#39; field.<br><br> (Note: probably don&#39;t need this since (... | map .prop | ...) works i.e. the member accessors can be used with map to get the same effect.<pre>
    (ls &#39;*.tl | get-prop &#39;length)</pre><br/></td>
</tr>
 <tr>
<td>185</td> <td><b>get-symbol</b></td> <td>built-in</td> <td>Syntax: (get-symbol &lt;string&gt;)<br/><br/>  Gets the symbol associated with the argument string. This function is most useful in macros.<br><br><pre></pre><br/><i>See also: gen-symbol show-symbols</i></td>
</tr>
 <tr>
<td>186</td> <td><b>get-symbols</b></td> <td>built-in</td> <td>Syntax: (get-symbols)<br/><br/>  Returns all of the symbols in the symbol table.<br><br><pre></pre><br/><i>See also: gen-symbol show-symbols get-symbol</i></td>
</tr>
 <tr>
<td>187</td> <td><b>getvar</b></td> <td>built-in</td> <td>Syntax: (getvar &lt;varname&gt;)<br/><br/>  Get the variable object corresponding to the argument symbol.<br><br> <pre>Examples:
    (getvar &#39;braidhome)</pre><br/><i>See also: get</i></td>
</tr>
 <tr>
<td>188</td> <td><b>get-watch</b></td> <td>powershell</td> <td>Syntax: (get-watch)<br/><br/>  Returns a list of all of the watched scripts that were set up with &#39;add-watch&#39;.<br><br> <pre>Examples:
    (get-watch)</pre><br/><i>See also: add-watch remove-watch</i></td>
</tr>
 <tr>
<td>189</td> <td><b>gh</b></td> <td>powershell</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>190</td> <td><b>global</b></td> <td>built-in</td> <td>Syntax: (global &lt;expression&gt; &lt;value&gt;)<br/><br/>  Binds the variable identified by expression to the specified value in the global scope. Because the function takes an expression to evaluate rather than a symbol to look up, it can be used to do indirect lookups in the global variable table.<br><br> <pre>Examples:
    (global (get-symbol &quot;foo&quot;) 123) ; set the variable &#39;foo&#39; to 13</pre><br/><i>See also: let local def globalq</i></td>
</tr>
 <tr>
<td>191</td> <td><b>globalq</b></td> <td>built-in</td> <td>Syntax: (globalq &lt;symbol&gt; &lt;value&gt;)<br/><br/>  Binds the variable identified by the symbol to the specified value in the global scope.<br><br><pre></pre><br/><i>See also: let local def global</i></td>
</tr>
 <tr>
<td>192</td> <td><b>group</b></td> <td>built-in</td> <td>Syntax: (group &lt;collection&gt; &lt;byFunction&gt; &lt;processGroupFn&gt;)<br/><br/>  The &#39;group&#39; function groups members of a collection together in a dictionary by the value returned by the &lt;byFunction&gt;. Once the groups have been created, the &lt;processGroupFn&gt; is applied to each group. This function can be used to do things like rrplace the group with the count of group elements or compute the sum of a property on an element.<br><br><pre>Examples:
    (ls -file | group .extension count)   ; counts the number of files per extension
    ; get the total length of each type of file
    (ls -file | group .extension (fn files -&gt; (sum files .length)))
    ; count the number of times a word appears in a file
    (read-data words.txt | re/split | group echo count)</pre><br/></td>
</tr>
 <tr>
<td>193</td> <td><b>head</b></td> <td>built-in</td> <td>Syntax: (head listOfObjects)<br/><br/>  The &#39;head&#39; function returns the first item from a sequence, or the item itself if it&#39;s an atom.  (head is an alias for car.) If the argument is a string, the first &#39;word&#39; is returned i.e. all of the text up to the first whitespace character.<br><br> <pre>Examples:
    (head &#39;(1 2 3))         ; returns 1
    (head [4 5 6])          ; returns 4
    (head &quot;abc&quot;)          ; returns &quot;abc&quot;
    (head &quot;abc def ghi&quot;)  ; returns the first word &quot;abc&quot;</pre><br/><i>See also: cdr tail first last</i></td>
</tr>
 <tr>
<td>194</td> <td><b>help</b></td> <td>autoload.tl</td> <td>Syntax: (help [(pattern null)])<br/><br/>  Gets help information about commands. The first argument is unevaluated.<pre></pre><br/></td>
</tr>
 <tr>
<td>195</td> <td><b>hex</b></td> <td>autoload.tl</td> <td>Syntax: (hex [args])<br/><br/>  Function to take numeric arguments and turn them into hex strings. Normally the strings are prefixed with &#39;0x&#39; but if -noprefix is specified, then the &#39;0x&#39; prefix will be omitted. If a single value is converted, then it&#39;s returned a a string. If more than one value is converted, then the results are aggregated into a vector.<pre></pre><br/></td>
</tr>
 <tr>
<td>196</td> <td><b>html/b</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/b [args])<br/><br/>  Bold tag<pre></pre><br/></td>
</tr>
 <tr>
<td>197</td> <td><b>html/doc</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/doc [header body])<br/><br/>  Generate an HTML document<pre></pre><br/></td>
</tr>
 <tr>
<td>198</td> <td><b>html/em</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/em [args])<br/><br/>  Emphasis tag<pre></pre><br/></td>
</tr>
 <tr>
<td>199</td> <td><b>html/encode</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/encode [(^string text)])<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>200</td> <td><b>html/extractLinks</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/extractLinks [text])<br/><br/>  A function to extract all of the links in a piece of HTML text. Currently it doesn&#39;t distinguish between &quot; and \&#39;. It also doesn&#39;t handle relative links because it doesn&#39;t have the original URL.<br><br> <pre>Examples:
    (http/get | html/extractLinks)</pre><br/><i>See also: http/get</i></td>
</tr>
 <tr>
<td>201</td> <td><b>html/form</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/form [(^IDictionary elements) args])<br/><br/>  Insert a form into the html document.<pre></pre><br/></td>
</tr>
 <tr>
<td>202</td> <td><b>html/h1</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/h1 [args])<br/><br/>  Generate a header 1 tag.<pre></pre><br/></td>
</tr>
 <tr>
<td>203</td> <td><b>html/h2</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/h2 [args])<br/><br/>  Generate a header 2 tag.<pre></pre><br/></td>
</tr>
 <tr>
<td>204</td> <td><b>html/h3</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/h3 [args])<br/><br/>  Generate a header 3 tag.<pre></pre><br/></td>
</tr>
 <tr>
<td>205</td> <td><b>html/i</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/i [args])<br/><br/>  Italics tag<pre></pre><br/></td>
</tr>
 <tr>
<td>206</td> <td><b>html/input</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/input [(^IDictionary elements)])<br/><br/>  Insert an input element into the document.<pre></pre><br/></td>
</tr>
 <tr>
<td>207</td> <td><b>html/p</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/p [args])<br/><br/>  Generate a paragraph tag<pre></pre><br/></td>
</tr>
 <tr>
<td>208</td> <td><b>html/string</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/string [args])<br/><br/>  Strong tag<pre></pre><br/></td>
</tr>
 <tr>
<td>209</td> <td><b>html/style</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/style [styleString])<br/><br/>  Insert an HTML CSS style string.<pre></pre><br/></td>
</tr>
 <tr>
<td>210</td> <td><b>html/table</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/table [args])<br/><br/>  Generate a table<pre></pre><br/></td>
</tr>
 <tr>
<td>211</td> <td><b>html/td</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/td [args])<br/><br/>  Generate a table data element.<pre></pre><br/></td>
</tr>
 <tr>
<td>212</td> <td><b>html/th</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/th [args])<br/><br/>  Generate a table header element<pre></pre><br/></td>
</tr>
 <tr>
<td>213</td> <td><b>html/title</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/title [args])<br/><br/>  Insert the document title.<pre></pre><br/></td>
</tr>
 <tr>
<td>214</td> <td><b>html/tr</b></td> <td>htmlutils.tl</td> <td>Syntax: (html/tr [args])<br/><br/>  Generate a table row<pre></pre><br/></td>
</tr>
 <tr>
<td>215</td> <td><b>id</b></td> <td>built-in</td> <td>Syntax: (id args...)<br/><br/>  The &#39;id&#39; is the &#39;identity function&#39; and simply returns it&#39;s arguments unmodified. If multiple arguments are specified then a collection is returned. If only a single value is provided, then it will be returned as scalar.<br><br> <pre>Examples:
    (id 123)              ; returns 123
    (id 1 2 3 4)          ; returns [1 2 3 4]</pre><br/><i>See also: id echo</i></td>
</tr>
 <tr>
<td>216</td> <td><b>if</b></td> <td>built-in</td> <td>Syntax: (if condExpr ifExpr [ elseExpr ])<br/><br/>  The &#39;if&#39; function does branching, taking one (if clause) or two (if and else) clauses.<br><br><pre>Examples:
    (if cond if-clause)
    (if cond if-clause else-clause)</pre><br/></td>
</tr>
 <tr>
<td>217</td> <td><b>ifib</b></td> <td>autoload.tl</td> <td>Syntax: (ifib [(^int number)])<br/><br/>  Compute the Fibonacci number for the argument using iteration.<pre></pre><br/></td>
</tr>
 <tr>
<td>218</td> <td><b>ifmap</b></td> <td>autoload.tl</td> <td>Syntax: (ifmap [lst cond-expr if-part (else-part null)])<br/><br/>  The &#39;ifmap&#39; special form can be used when processing data in a pipeline. The first argument must be a list to process. The second argument is the conditional expression. The third and optional fourth arguments are the &#39;if part&#39; and &#39;else part&#39; which will be evaluated based on the result of the conditional expression. To provide accesss to the current pipeline object, &#39;ifmap&#39; binds that value to the variable &#39;it&#39; in the current scope.<br><br>    (range 10 | ifmap (% it 2) &quot;odd&quot; &quot;even&quot;)<br><br><pre>Examples:</pre><br/><i>See also: if map</i></td>
</tr>
 <tr>
<td>219</td> <td><b>if-not</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>220</td> <td><b>ilist?</b></td> <td>built-in</td> <td>Syntax: (ilist? &lt;object&gt;)<br/><br/>  Returns true if the argument is of type ^System.Collections.IList.<br><br><pre></pre><br/><i>See also: list? atom? pair?</i></td>
</tr>
 <tr>
<td>221</td> <td><b>in?</b></td> <td>autoload.tl</td> <td>Syntax: [ lst | value (^BraidLang.RangeList rangeList) | (^callable value) (^IDictionary dict) | value (^IDictionary dict) | (^callable value) (^HashSet hashset) | value (^HashSet hashset) | (^callable value) (^string str) | value (^string str) | (^Callable value) (^IEnumerable lst) | value (^IEnumerable lst) ]<br/><br/>  Returns true if the argument list contains the specified value or matches the lambda. Does a shallow search. The in? function is the same as the contains? function except the arguments are reversed.<br><br> <pre>Examples:
    (in? :a [:a :b :c])     ; returns true
    (in? :d [:a :b :c])     ; returns false
    (3 | in? [1 2 3 4 5])   ; returns true
    (in? 5 (range 10))      ; returns true</pre><br/><i>See also: contains?</i></td>
</tr>
 <tr>
<td>222</td> <td><b>incr</b></td> <td>built-in</td> <td>Syntax: (incr variable [increment])<br/><br/>  Increment a variable by the desired amount and returns the result. If no increment is specified, then 1 is used. This function can only be used for variables containing integral values (e.g. ^int or ^long)<br><br> <pre>Examples:
    (let a 0)
    (println (incr a))  ; prints 0 on the screen
    (println a)         ; prints 1 on the screen
    (for (let i 0) (&lt; i 10) (incr i) (println i))</pre><br/><i>See also: pincr decr pdecr ++ --</i></td>
</tr>
 <tr>
<td>223</td> <td><b>info</b></td> <td>built-in</td> <td>Syntax: (info arg1 arg2 arg3 ... argn)<br/><br/>  This function prints an informational message to the console in yellow. All of the arguments are turned into strings then joined with a single space between each string.<br><br> <pre>Examples:
    (info &quot;This is an information message.&quot;)
    (info &#39;this &#39;is &#39;a &#39;message &#39;in &#39;pieces.)
    (info &quot;The value of 2+2 is&quot; (+ 2 2))</pre><br/><i>See also: warn error println</i></td>
</tr>
 <tr>
<td>224</td> <td><b>insert-string</b></td> <td>autoload.tl</td> <td>Syntax: (insert-string [(^string source) (^int index) (^string newStr)])<br/><br/>  Inserts a substring into a string at the specified location. If the specified location is negative, it will be treated as the offset from the end of the string instead of from the beginning.<br><br> <pre>Examples:
    (insert-string &quot;bcdef&quot; 3 &quot;123&quot;) ; returns &#39;abc123def&#39;
    (insert-string &quot;abcdef&quot; -4 &quot;123&quot;) ; returns &#39;ad123cdef&#39;</pre><br/><i>See also: str join</i></td>
</tr>
 <tr>
<td>225</td> <td><b>intersect</b></td> <td>built-in</td> <td>Syntax: (intersect &lt;collection1&gt; &lt;collection2&gt;)<br/><br/>  Computes the intersection of two collections and returns the result as a vector.<br><br> <pre>Examples:
    (intersect [1 2 3] [2 3 4]; returns [2 3]</pre><br/><i>See also: distinct union</i></td>
</tr>
 <tr>
<td>226</td> <td><b>Invoke-Method</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>227</td> <td><b>i-rev</b></td> <td>autoload.tl</td> <td>Syntax: (i-rev [lst])<br/><br/>  Reverse a sequence using iteration. A new list is constructed and returned. The original list is not modified.<pre></pre><br/></td>
</tr>
 <tr>
<td>228</td> <td><b>i-revswap</b></td> <td>autoload.tl</td> <td>Syntax: (i-revswap [(^Vector? lst)])<br/><br/>  Iteratively reverse a vector in place using the &#39;swap&#39; function. The updated list is returned.<pre></pre><br/></td>
</tr>
 <tr>
<td>229</td> <td><b>is?</b></td> <td>built-in</td> <td>Syntax: (is? &lt;object&gt; &lt;type&gt;)<br/><br/>  Checks to see if the argument object is of the specified type.<br><br> <pre>Examples:
    (is? 123 ^int)          ; returns true
    (is? 123 ^string)       ; returns false
    (is? &quot;abc&quot; ^string)   ; true</pre><br/><i>See also: isnot?</i></td>
</tr>
 <tr>
<td>230</td> <td><b>isnot?</b></td> <td>built-in</td> <td>Syntax: (isnot? &lt;object&gt; &lt;type&gt;)<br/><br/>  Checks to see if the argument object is not of the specified type.<br><br> <pre>Examples:
    (isnot? 123 ^int)       ; returns false
    (isnot? 123 ^string)    ; returns true</pre><br/><i>See also: is?</i></td>
</tr>
 <tr>
<td>231</td> <td><b>isPrime</b></td> <td>autoload.tl</td> <td>Syntax: [ 3 | n | n ]<br/><br/>  Simple function to determine if a number is prime.<br><br><pre>Examples:
    (isPrime 19) ; returns true
    (isPrime 10) ; returns false</pre><br/></td>
</tr>
 <tr>
<td>232</td> <td><b>iterator</b></td> <td>autoload.tl</td> <td>Syntax: [ func initialValue finalValue | func initialValue | func ]<br/><br/>  The iterator function is a way to produce a (possibly) infinite sequence of values. Each new value in the sequence is computed by taking the current value and passing it to the argument &lt;function&gt;. The result of evaluating that function becomes the new current value. Instead of an array or list, invoking iterator returns a .Net ^IEnumerable. Consumers can then get the enumerator and iterate over that enumerator. If no &#39;max&#39; is provided, the enumerator will produce new values forever on until the consumer stops requesting values. If &#39;max&#39; is specified, values will be produced until &#39;max&#39; is reached.<br><br> (Note: &#39;unfold&#39; is an alias for &#39;iterator&#39;.)<br><br> <pre>Examples:
    (iterator ++ 1 | take 100)        ; get integers from 1-100.
    (iterator (+ 2) 2 10)             ; even numbers from 2-10 inclusive.
    ; the following computes (fib 10)
    (iterator (fn x:y: -&gt; [y (+ x y)]) [1 1] | take 10 | last | last)</pre><br/><i>See also: reduce foldl roldr unfold</i></td>
</tr>
 <tr>
<td>233</td> <td><b>iterfib</b></td> <td>autoload.tl</td> <td>Syntax: (iterfib [n])<br/><br/>  Compute the nth element in the Fibonacci sequence. This is computed lazily using the &#39;unfold&#39; function.<br><br> axamples:<br><br><pre>
    (iterfib 10)    ; returns 89</pre><br/><i>See also: fib rpfib</i></td>
</tr>
 <tr>
<td>234</td> <td><b>join</b></td> <td>built-in</td> <td>Syntax: (join &lt;seq&gt; [&lt;separator])<br/><br/>  The &#39;join&#39; function stringizes the elements of the argument collection then joins them into a single string separated by an optional separator string. If no separator string is provided, &#39;join&#39; will use a single space.<br><br> <pre>Examples:
    (join [1 2 3])      ; results in &quot;1 2 3&quot;
    (join [1 2 3] &quot;+&quot;)  ; results in &quot;1+2+3&quot;
    (join [1 2 3] &quot;, &quot;) ; results in &quot;1, 2, 3&quot;</pre><br/><i>See also: str tostring</i></td>
</tr>
 <tr>
<td>235</td> <td><b>keyword</b></td> <td>built-in</td> <td>Syntax: (keyword &lt;name&gt;)<br/><br/>  Gets or creates a keyword object using the name string. If the keyword already exists, the existing object is returned otherwise a new keyword is created atomically.<br><br><pre></pre><br/><i>See also: symbol</i></td>
</tr>
 <tr>
<td>236</td> <td><b>keyword?</b></td> <td>built-in</td> <td>Syntax: (keyword? argument)<br/><br/>  The &#39;keyword?&#39; function returns true if its argument is a keyword literal.<br><br> <pre>Examples:
    (keyword? :foo)                ; returns true
    (keyword? &quot;hi&quot;)              ; returns true</pre><br/><i>See also: none? some? number? number? even?</i></td>
</tr>
 <tr>
<td>237</td> <td><b>lambda</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>238</td> <td><b>lambda?</b></td> <td>built-in</td> <td>Syntax: (lambda? &lt;object&gt;)<br/><br/>  A predicate function that returns true if the argument object is a lambda function.<br><br> <pre>Examples:
    (lambda? (fn -&gt; 1))     ; returns true
    (lambda? (lambda[] 1))  ; returns true
    (lambda? 1)             ; returns false</pre><br/><i>See also: lambda fn</i></td>
</tr>
 <tr>
<td>239</td> <td><b>last</b></td> <td>built-in</td> <td>Syntax: (last &lt;list&gt; [&lt;number&gt;])<br/><br/>  The &#39;last&#39; function returns a number of items from the end of a list or vector. The number of items specified is optional and, if not specified, defaults to 1. If more items are request than are available in the collecion, as many items as available are returned. If the argument is not an enumerable (i.e. not a scalar), then &#39;last&#39; will simply return the iten as is. If a single item is to be returned, it is returned as a scalar rather than as a vector of 1 element.<br><br> <pre>Examples:
    (range 10 | last)               ; returns 10
    (range 10 | last 1)             ; returns 10 (not [ 10 ])
    (range 10 | last 3)             ; returns [8 9 10]
    (range 5  | last 10)            ; returns [1 2 3 4 5]</pre><br/><i>See also: first take</i></td>
</tr>
 <tr>
<td>240</td> <td><b>last-node</b></td> <td>autoload.tl</td> <td>Syntax: (last-node [(^ISeq lst)])<br/><br/>  Returns the last node in a list. Not to be confused with the &#39;last&#39; function which returns the last *value* in a list. In otherwords, &#39;last-node&#39; returns the &#39;cdr&#39; of the last nde, instead of the last car.<br><br> <pre>Examples:
    (last-node &#39;(1 2 3)) ; returns (3)
    (last &#39;(1 2 3))      ; returns 3</pre><br/><i>See also: flatmap flatten</i></td>
</tr>
 <tr>
<td>241</td> <td><b>lazy-each</b></td> <td></td> <td>Syntax: (lazy-each [args expr])<br/><br/>  A macro to support &#39;lazy each&#39; functionality.<pre></pre><br/></td>
</tr>
 <tr>
<td>242</td> <td><b>lazy-filter</b></td> <td>built-in</td> <td>Syntax: (lazy-filter [-not] &lt;list&gt; &lt;predicate&gt;)<br/><br/> Filters the input collection based on the results of evaluating the predicate function on each item. The predicate can be a lambda literal, a named function, a member accessor, a type literal, a regular expression or a dictionary literal. If a dictionary literal is provided, &#39;lazy-filter&#39; will use property pattern matching as the filter criteria. The sense of the comparison can be changed with the &#39;-not&#39; flag. The &#39;lazy-&#39; variant returns an enumerable instead of a collection. Individual values can then be pulled from the enumerable as needed thus only evaluating as much as is necessary.  Either of the forms can use &#39;break&#39; in the predicate function to terminate the search at the current item. You can also use &#39;continue&#39; to skip over the current item in the list and keep searching.<br><br> <pre>Examples:
    (range 10 | lazy-filter (fn n -&gt; (== (% n 2) 0))) ; returns [2 4 6 8 10]
    (range 10 | lazy-filter even?)                    ; returns [2 4 6 8 10]
    (range 10 | lazy-filter -not even?)               ; returns [1 3 5 7 9]
    (range 20 | lazy-filter #&quot;2&quot;)                     ; returns [2 12 20]
    (get-process | lazy-filter .cpu)                  ; returns all procs that have used CPU
    ; use property patterns to find Error entries whose message matches the regex #&quot;timeout&quot;
    (get-eventlog -log: &quot;system&quot; -newest: 1000 | lazy-filter {entrytype &quot;error&quot; message #&quot;timeout&quot;})
    ; find element &#39;99&#39; in the input collection, stopping the search when it&#39;s found
    (range 100000 | lazy-filter (fn n -&gt; (if (== n 99) (break))))</pre><br/><i>See also: filter lazy-filter map lazy-map each</i></td>
</tr>
 <tr>
<td>243</td> <td><b>lazy-flatmap</b></td> <td>built-in</td> <td>Syntax: (lazy-flatmap list function)<br/><br/>  The &#39;lazy-flatmap&#39; function is usually used in pipelines to process items in the pipeline.It takes a list of values and a function to apply to each value as in: - (lazy-flatmap &lt;list&gt; &lt;function&gt;) or (&lt;list&gt; | lazy-flatmap &lt;function&gt;) Functions can either be predefined functions, property functions or lambdas. As opposed to the map function, &#39;lazy-flatmap&#39; flattens its result so if the function returns a list, that list will be stiched into the result list rather than appearing as a discrete list. The distinction between &#39;flatmap&#39; and &#39;lazy-flatmap&#39; is that &#39;flatmap&#39; returns the entire result collection whereas &#39;lazy-flatmap&#39; returns an enumerable immediately and te values can be pulled out as needed.<br><br> <pre>Examples:
    (range 10 | lazy-flatmap sqr)                  ; maps &#39;sqr&#39; onto each number from the range
    (ls &#39;*.cs | lazy-flatmap .length)              ; gets the property .length from each file object
                                           ; through the pipeline
    (range 10 | lazy-flatmap (fn x -&gt; [x x]))      ; returns [1 1 2 2 3 3 ...]</pre><br/><i>See also: map filter flatten</i></td>
</tr>
 <tr>
<td>244</td> <td><b>lazy-flatten</b></td> <td>built-in</td> <td>Syntax: (lazy-flatten args...)<br/><br/>  The &#39;lazy-flatten&#39; function lazily flattens all of its arguments into a single collection. On execution, it returns an ^IEnumerable immediately. Individual values can then be read from that enumerable as needed.<br><br> Example:<br><br><pre>
    (lazy-flatten &#39;(1 (2 3) 4 ((5))))    ; returns &#39;(1 2 3 4 5)
    (lazy-flatten &#39;(1 2 3) [4 [5 6]] 7)  ; returns &#39;(1 2 3 4 5 6 7)</pre><br/><i>See also: flatmap</i></td>
</tr>
 <tr>
<td>245</td> <td><b>lazy-map</b></td> <td>built-in</td> <td>Syntax: (lazy-map list function)<br/><br/>  The &#39;lazy-map&#39; function is usually used in pipelines to lazily process items in the pipeline. It takes a collection of values plus a transformation function to apply to each value in the input collection e.g. and returns a lazy enumerable which will compute result items one at a time (lazy evaluation). Transformation functions can either be predefined functions, member accessors or lambdas.<br><br> <pre>Examples:
    (lazy-map &lt;collection&gt; &lt;function&gt;) or (&lt;collection&gt; | lazy-map &lt;function&gt;)
    (range 10 | lazy-map sqr)                ; maps &#39;sqr&#39; onto each number in the range
    (ls &#39;*.cs | lazy-map .length)            ; gets the property .length from each file object
                                             ; through the pipeline
    (range 10 | lazy-map (fn x -&gt; (* x x)))  ; maps the lambda function onto each value
    (range 10 | lazy-map (fn x -&gt; (* x x)))  ; same thing but using function literal notation.</pre><br/><i>See also: map map-parallel each filter where lazy-filter</i></td>
</tr>
 <tr>
<td>246</td> <td><b>lazy-sort</b></td> <td>built-in</td> <td>Syntax: lazy-sort [-Descending] listToSort [keyFunction])<br/><br/>  This function sorts a sequence of values. By default, it sorts in ascending order but the &#39;-descending&#39; flag changes this to descending order. You can also specify a &#39;keyFunction&#39; that will be used to select the value to sort on. You can use the &#39;lazy-sort&#39; varient to pull values as needed.<br><br><pre>Examples:
    (random 10 | sort)                      ; sorts 10 random numbers in ascending order
    (random 10 | sort -descending)          ; sorts 10 random numbers in descending order
    (ls -file | sort .length)               ; sort files by length
    (ls &#39;* | sort (fn e -&gt; (.extension e))) ; sort files by extensions</pre><br/></td>
</tr>
 <tr>
<td>247</td> <td><b>lc</b></td> <td>autoload.tl</td> <td>Syntax: (lc [args])<br/><br/>  Count the lines in the argument files.<pre></pre><br/></td>
</tr>
 <tr>
<td>248</td> <td><b>leap-year?</b></td> <td>autoload.tl</td> <td>Syntax: (leap-year? [(^int year)])<br/><br/>  True if the passed argument is a leap year.<pre></pre><br/></td>
</tr>
 <tr>
<td>249</td> <td><b>length</b></td> <td>built-in</td> <td>Syntax: (length object)<br/><br/>  Returns the length of a collection. If the argument is a scalar, then it returns 1. If it&#39;s null, then the function returns 0. This is an alias for the &#39;count&#39; function.<br><br> <pre>Examples:
    (length &quot;abcdef&quot;)     ; returns 5
    (length [1 2 3])        ; returns 3
    (length &#39;(2 4 6 8)      ; returns 4
    (length 13              ; returns 1
    (length null)           ; returns 0</pre><br/><i>See also: count</i></td>
</tr>
 <tr>
<td>250</td> <td><b>let</b></td> <td>built-in</td> <td>Syntax: (let name value)<br/><br/>  Sets the value of a variable in the current scope if a variable with that name exists or creates a new variable in the current scope if it doesn&#39;t. If the name takes the form of v1:v2:v3 then destructuring will be done and the parts assigned.<br><br> <pre>Examples:
    (let foo 123)               ; returns 123
    (let x:y:z [1 2 3 4 5])     ; returns [1 2 3 4 5]</pre><br/><i>See also: vlet def setq local</i></td>
</tr>
 <tr>
<td>251</td> <td><b>let?</b></td> <td></td> <td>Syntax: (let? name value)<br/><br/>  Returns true if a destructuring assignment was successful, false otherwise.<br><br> <pre>Examples:
    (vlet xs [1 2 3]) (while (let? x:xs xs) (println x)) ; print a list</pre><br/><i>See also: let vlet def setq local</i></td>
</tr>
 <tr>
<td>252</td> <td><b>let=</b></td> <td></td> <td>Syntax: (let= [varToSet args])<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>253</td> <td><b>let-default</b></td> <td>autoload.tl</td> <td>Syntax (Pattern Function): (let-default [ (^symbol sym) expr | (^TypeLiteral t) (^symbol sym) expr | (^symbol sym) low high | (^TypeLiteral type) (^symbol sym) low high ])<br/><br/>  This special form sets the value of the identified variable if the variable is unbound or empty or constrains it if it is bound.<br><br> <pre>Examples:
    (let-default foo 123)           ; if foo is null or unbound, sets it to 123.
    (let-default ^int foo 123)      ; if foo is null or unbound, sets it to 123 with a type constraint.
    (let-default foo 10 20)         ; if foo is set, constrain the value to be between 10 and 20.
    (let-default ^int foo 10 20)    ; if foo is set, constrain the value to be between 10 and 20.</pre><br/><i>See also: let let?</i></td>
</tr>
 <tr>
<td>254</td> <td><b>list</b></td> <td>built-in</td> <td>Syntax: (list arg1 arg2 arg3 ... argN)<br/><br/>  Returns a list composed of its evaluated arguments.<br><br> <pre>Examples:
    (list 1 (+ 2 3) 4) ; returns (1 5 4)</pre><br/><i>See also: list? append</i></td>
</tr>
 <tr>
<td>255</td> <td><b>list/all</b></td> <td>autoload.tl</td> <td>Syntax: (list/all [lst func])<br/><br/>  Applies the argument function to each element of the list. If the function evaluates to true for all elements, then this function returns true.<br><br> <pre>Examples:
    (all [1 2 3 4] (fn x  -&gt; x (&gt; x 0))) ; returns true</pre><br/><i>See also: any</i></td>
</tr>
 <tr>
<td>256</td> <td><b>list/any</b></td> <td>autoload.tl</td> <td>Syntax: (list/any [lst func])<br/><br/>  Applies the argument function to each element of the list. If the function evaluates to true for any of the elements, then this function returns true.<br><br> <pre>Examples:
    (all [0 9 1 0] (fn x  -&gt; x (&gt; x 0))) ; returns true</pre><br/><i>See also: any</i></td>
</tr>
 <tr>
<td>257</td> <td><b>list/monotonic</b></td> <td>autoload.tl</td> <td>Syntax: (list/monotonic [lst])<br/><br/>  Returns true if the members of the argument collection increase monotonically in size, If the &#39;-descending&#39; flag is specified, it will return true if the list is decreasing monotonically in size. The expression (list/monotonic [1 2 3]) is effectively equivalent to (&lt;= 1 2 3).<br><br> <pre>Examples:
    (list/monotonic [1 2 3 4])              ; returns true
    (list/monotonic [2 1 3])                ; returns false
    (list/monotonic [3 2 1])                ; returns false
    (list/monotonic -descending [3 2 1])    ; returns true</pre><br/><i>See also: &lt;= &gt;= list/any list/all</i></td>
</tr>
 <tr>
<td>258</td> <td><b>list/partition</b></td> <td>autoload.tl</td> <td>Syntax: (list/partition [(^ISeq lst) (^int partitionSize)])<br/><br/>  Partition a list or vector into argument-sized pieces.<br><br> <pre>Examples:
    (list/partition [1 2 3 4] 2)    ; returns [[1 2] [3 4]]
    (list/partition [1 2 3 4] 1)    ; returns [[1] [2] [3] [4]]</pre><br/><i>See also: list/split</i></td>
</tr>
 <tr>
<td>259</td> <td><b>list/split</b></td> <td>built-in</td> <td>Syntax: (list/split &lt;list&gt; &lt;value or predicate&gt;)<br/><br/>  The &#39;list/split&#39; function splits a list into two pieces based on a either a provided value or a predicate function. If a value is specified the list is split at the first occurance of that item in the list. Note that the value to split on is not included in either result list and subsequent instances are not treated specially. Also note that if the item is not found an empty second list is returned.<br><br> If a predicate function is specified, elements for which the function is true are placed in the first result list and the rest are placed in the second result list.<br><br><pre>Examples:
    (list/split [1 2 3 4 5] odd?)   ; returns [[1 3 5] [2 4]]
    (list/split [1 2 3 4 5] (&lt; 4)   ; returns [[1 2 3] [4 5]]
    (list/split [1 2 3 4 5] 3)      ; returns [[1 2] [4 5]]</pre><br/></td>
</tr>
 <tr>
<td>260</td> <td><b>list/wrapprint</b></td> <td>autoload.tl</td> <td>Syntax: (list/wrapprint [(^ISeq lst) (^Callable? printFn null)])<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>261</td> <td><b>list?</b></td> <td>built-in</td> <td>Syntax: (list? &lt;object&gt;)<br/><br/>  Returns true if the argument object is a list.<br><br><pre>Examples:
    (list? &#39;(1 2 3))        ; returns true
    (list? (list 1 2 3))    ; returns true
    (list? [1 2 3])         ; returns false</pre><br/></td>
</tr>
 <tr>
<td>262</td> <td><b>list-add</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>263</td> <td><b>load</b></td> <td>built-in</td> <td>Syntax: (load &lt;fileName&gt;)<br/><br/>  Loads a braid file into the current scope (like PowerShell&#39;s &#39;dot sourcing&#39;.)<br><br> <pre>Examples:
    (load &#39;foo.tl)      ; load the file &#39;foo.tl&#39;
    (load &quot;foo.tl&quot;)   ; load the file &#39;foo.tl&#39;
    (let fileToLoad &quot;foo.tl&quot;)
    (load fileToLoad)   ; load the file &#39;foo.tl&#39;</pre><br/><i>See also: using-module using-assembly</i></td>
</tr>
 <tr>
<td>264</td> <td><b>loaded-files</b></td> <td>autoload.tl</td> <td>Syntax: (loaded-files [])<br/><br/>  Find all of the loaded source files.<br><br> <pre>Examples:
    (loaded-files)</pre><br/><i>See also: loaded-types loaded-functions</i></td>
</tr>
 <tr>
<td>265</td> <td><b>loaded-functions</b></td> <td>autoload.tl</td> <td>Syntax: (loaded-functions [(^regex? pattern #&quot;.&quot;)])<br/><br/>  Find the functions loaded from the file matching the argument pattern.<br><br> <pre>Examples:
    (loaded-functions)</pre><br/><i>See also: loaded-files loaded-types</i></td>
</tr>
 <tr>
<td>266</td> <td><b>loaded-types</b></td> <td>autoload.tl</td> <td>Syntax: (loaded-types [])<br/><br/>  Find all of the Braid-based types that have been loaded.<br><br> <pre>Examples:
    (loaded-types)</pre><br/><i>See also: loaded-files loaded-functions</i></td>
</tr>
 <tr>
<td>267</td> <td><b>local</b></td> <td>stdin</td> <td>Syntax: (local name value)<br/><br/>  Sets the value of a variable in the current scope if a variable with that name exists or creates a new variable in the current scope if it doesn&#39;t. If the name takes the form of v1:v2:v3 then destructuring will be done and the parts assigned.<br><br><pre>
    (local foo 123)
    (local x:y:z [1 2 3 4 5])</pre><br/><i>See also: def setq let</i></td>
</tr>
 <tr>
<td>268</td> <td><b>log</b></td> <td>autoload.tl</td> <td>Syntax: [ (^double? n) (^double? m) | (^double? n) 10 | (^double? n) ]<br/><br/>  Compute the log of two values e.g. (log n m)<pre></pre><br/></td>
</tr>
 <tr>
<td>269</td> <td><b>loop</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>270</td> <td><b>Make-Counter</b></td> <td>stdin</td> <td>Syntax: (Make-Counter [n])<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>271</td> <td><b>map</b></td> <td>built-in</td> <td>Syntax: (map &lt;collection&gt; &lt;function&gt;)<br/><br/>  The &#39;map&#39; function is usually used in pipelines to process items in the pipeline. It takes a collection of values and a function to apply to each value as in: (map &lt;collection&gt; &lt;function&gt;) or: (&lt;list&gt; | map &lt;function&gt;) Functions can either be predefined functions, property functions or lambdas. The function is applied to each inbound element, returning the new element to the output vector.<br><br> <pre>Examples:
    (range 10 | map sqr)                ; maps &#39;sqr&#39; onto each number in the range
    (ls &#39;*.cs | map .length)            ; gets the property .length from each file object
                                        ; through the pipeline
    (range 10 | map (fn x -&gt; (* x x)))  ; maps the lambda function onto each value
    (range 10 | map (fn x -&gt; (* x x)))  ; same thing but using function literal notation.</pre><br/><i>See also: map-parallel lazy-map each filter where lazy-filter</i></td>
</tr>
 <tr>
<td>272</td> <td><b>mapcat</b></td> <td>autoload.tl</td> <td>Syntax: (mapcat [f colls])<br/><br/>  For each argument collection, map a function onto the elements of the collection then concatenate the results into a single flat collection.<br><br> <pre>Examples:
    (mapcat ++ [1 2] [3 4] [5 6])   ; returns [2 3 4 5 6 7]</pre><br/><i>See also: map concat</i></td>
</tr>
 <tr>
<td>273</td> <td><b>map-parallel</b></td> <td>built-in</td> <td>Syntax: (map-parallel list function)<br/><br/>  The &#39;map-parallel&#39; function is used in pipelines like &#39;map&#39; to the process items in the pipeline.  It takes a list of values and a function to apply to each value Functions can either be predefined functions, property functions or lambdas. The difference betweenthis function and regular &#39;map&#39; is that this function runs it&#39;s lambda as a Task. In otherwords,the work for all pipeline items is done concurrently (subject to processor limitations). As a consequence, the lambda is executed in an isolated space that starts with a snapshot of the caller&#39;s space but, because it&#39;s just a copy, changes the function makes are not reflected in the caller&#39;s environment. Using this function over &#39;map&#39; can make your program run faster but be aware that the operation of creating a task is fairly expensive so if your lambda is trivial, &#39;map-parallel&#39; is probably not the best choice.<br><br> <pre>Examples:
    (map-parallel &lt;list&gt; &lt;function&gt;) or (&lt;list&gt; | map-parallel &lt;function&gt;)
    (range 10 | map-parallel sqr)                  ; maps the function &#39;sqr&#39; onto each number from the range
    (ls &#39;*.cs | map-parallel .length)              ; gets the property .length from each pipeline object
    (range 10 | map-parallel (lambda [x] (* x x))) ; maps the lambda function onto each value
    (range 10 | map-parallel (fn x -&gt; (* x x)))    ; same thing but using function literal notation.</pre><br/><i>See also: map flatmap each</i></td>
</tr>
 <tr>
<td>274</td> <td><b>matchp</b></td> <td></td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>275</td> <td><b>max</b></td> <td>autoload.tl</td> <td>Syntax: [ x y | x y func | x y func | x ]<br/><br/>  Return the max of two items.<pre></pre><br/></td>
</tr>
 <tr>
<td>276</td> <td><b>max-list</b></td> <td>autoload.tl</td> <td>Syntax: [ %none? | x | (^ISeq lst) | scalar | %none? func | x] func | (^ISeq lst) func | scalar func ]<br/><br/>  The &#39;max-list&#39; function returns the maximum-valued element from a sequence. An optional &#39;accessor&#39; function can be specified which provides the value of the property to be compared. Note that &#39;max-list&#39; returns the original value from the list, not the value returned from the accessor function. The accessor function is only used in comparisons and is never returned. If a scalar value is passed instead of a sequence, that value will simply be returned and no error will be raised.<br><br> <pre>Examples:
    (max-list [3 2 6 7 5 4 1 9])        ; returns 9
    (max-list [3 2 6 7 5 4 1 9] neg)    ; returns 1 since -1 is the largest value.
    (ls -file | max-list .length)       ; returns the FileInfo object for the largest file
    (ls -file | map .length | max-list) ; returns the length of the largest file.</pre><br/><i>See also: min max min-list smaller bigger</i></td>
</tr>
 <tr>
<td>277</td> <td><b>max-list-index</b></td> <td>autoload.tl</td> <td>Syntax: [ x: | x:xs | s x:xs i is | s x:xs i is | s nil _ is ]<br/><br/>  Find the first index of the maximum element in a list.<pre></pre><br/></td>
</tr>
 <tr>
<td>278</td> <td><b>median</b></td> <td>autoload.tl</td> <td>Syntax: [ %none? (func null) | lst (func null) ]<br/><br/>  Compute the median value of a list of numbers.<pre></pre><br/></td>
</tr>
 <tr>
<td>279</td> <td><b>members-of</b></td> <td>autoload.tl</td> <td>Syntax: (members-of [obj (^string? pattern &quot;.&quot;)])<br/><br/>  By default, the &#39;members-of&#39; function displays all of the public members on a type. This function has one optional positional parameter: you can specify a regular expression used to filter the members. If &#39;members-of&#39; is applied to an instance rather than a type, it will get the type of the argument object and use that for the type to examine.<br><br> Switches:<br><br> -raw By default &#39;members-of&#39; returns the memberinfo as string &#39;signatures&#39; however if &#39;-raw&#39; is specified, the raw MemberInfo object will be returned.<br><br> -private If -private is specified, then all members, both public and private will be returned.<br><br> -all Normally the getter/setter methods for properties are filtered out however if -all is specified, no filtering is done.<br><br> <pre>Examples:
    (members-of ^string)             ; get all of the members on ^string
    (members-of ^string #&quot;sub&quot;)    ; get the members matching the pattern argument
    (members-of &quot;hi&quot;)              ; gets the type of the argument and returns that type&#39;s members
    (members ^string -all -private)  ; gets all members, public &amp; private, will be returned,
    (members ^int -raw)              ; returns MemberInfo objects instead of strings.</pre><br/><i>See also: type-of base-of</i></td>
</tr>
 <tr>
<td>280</td> <td><b>memoize</b></td> <td>autoload.tl</td> <td>Syntax: (memoize [fnToMemoize])<br/><br/>  This function wraps a single argument function in a memoization closure by doing (let fib (memoize fib)) which replaces the current &#39;fib&#39; binding in the variable table with a memoized version.  A memoized function will remember each input/output pair and return the result if it has already been calculated. This makes the naive recursive fib function many time faster.<br><br><pre>Examples: (let fib (memoize fib))</pre><br/></td>
</tr>
 <tr>
<td>281</td> <td><b>min</b></td> <td>autoload.tl</td> <td>Syntax: [ x y func | x y | x ]<br/><br/>  Return the smaller of two items.<pre></pre><br/></td>
</tr>
 <tr>
<td>282</td> <td><b>min-list</b></td> <td>autoload.tl</td> <td>Syntax: [ x: (func nil) | (^ISeq lst) | (^ISeq lst) func | scalar (func nil) ]<br/><br/>  The &#39;min-list&#39; function returns the minimum-valued element from a sequence. An optional &#39;accessor&#39; function can be specified which provides the value of the property to be compared. Note that &#39;min-list&#39; returns the original value from the list. The accessor function is only used in comparisons and is never returned. If a scalar value is passed instead of a sequence, that value will simply be returned and no error will be raised.<br><br> <pre>Examples:
    (min-list [3 2 6 7 5 4 1 9])        ; returns 1
    (min-list [3 2 6 7 5 4 1 9] neg)    ; returns 9 since -9 is the smallest value.
    (ls -file | min-list .length)       ; returns the FileInfo object for the smallest file
    (ls -file | map .length | min-list) ; returns the length of the smallest file.</pre><br/><i>See also: min max max-list smaller bigger</i></td>
</tr>
 <tr>
<td>283</td> <td><b>min-list-index</b></td> <td>autoload.tl</td> <td>Syntax: [ x: | x:xs | s x:xs i is | s x:xs i is | s nil _ is ]<br/><br/>  Find the first index of the minimum element in a list.<pre></pre><br/></td>
</tr>
 <tr>
<td>284</td> <td><b>modified</b></td> <td>autoload.tl</td> <td>Syntax: (modified [])<br/><br/>  The &#39;modified&#39; function returns a list of the nanes of the modified files in the current Git workspace.<br><br><pre>Examples:
    (git :add @(modified))</pre><br/></td>
</tr>
 <tr>
<td>285</td> <td><b>my</b></td> <td>autoload.tl</td> <td>Syntax: [ path ]<br/><br/>  Changes directory relative to the user&#39;s document directory<pre></pre><br/></td>
</tr>
 <tr>
<td>286</td> <td><b>nconc</b></td> <td>built-in</td> <td>Syntax: (nconc &lt;value&gt; &lt;vector&gt;)<br/><br/>  The &#39;nconc&#39; function adds its first argument to the end of the vector provided in the second argument then returns the modified vector. If the first argument is also a vector, it is added as a single element to the end of the second argument. If the second argument is null, then a new empty vector will be created first then the first argument will be added to that new vector.<br><br> <pre>Examples:
    (nconc 4 [1 2 3])       ; returns [1 2 3 4]
    (nconc [4 5] [1 2 3]]   ; returns [1 2 3 [4 5]]
    (nconc 1 null)          ; returns [1]
    (nconc [1 2 3] null)    ; returns [[1 2 3]]</pre><br/><i>See also: vcons concat</i></td>
</tr>
 <tr>
<td>287</td> <td><b>neg</b></td> <td>built-in</td> <td>Syntax: (neg &lt;number&gt;)<br/><br/>  Inverts the sign on a number.<br><br><pre>Examples:
    (neg 2)     ; returns -2
    (neg -3)    ; returns 3</pre><br/></td>
</tr>
 <tr>
<td>288</td> <td><b>neg?</b></td> <td>built-in</td> <td>Syntax: (neg? &lt;number&gt;)<br/><br/>  Returns true if the argument number is negative.<br><br><pre>Examples:
    (neg? 1)                ; returns false
    (neg? -1)               ; returns true
    (numbers | filter neg?) ; returns only the negative numbers from &#39;numbers&#39;</pre><br/></td>
</tr>
 <tr>
<td>289</td> <td><b>new</b></td> <td>built-in</td> <td>Syntax: (new &lt;type&gt; [args...] [-properties: &lt;dictionary&gt;])<br/><br/>  Create a new instance of a class passing arguments as appropriate. If &#39;-properties:&#39; is specified along with a dictionary argument, the properties corresponding to each pair in the dictionary will be set to the dictionary value.<br><br> <pre>Examples:
    (new ^foo)          ; returns a new instance of ^foo with default values.
    (new ^foo 1 2 3)    ; returns an instance using a constructor with arguments.
    (new ^foo -properties: {:a 1 :b 2} ; sets the properties &#39;a&#39; and &#39;b&#39;.</pre><br/><i>See also: defmethod definterface</i></td>
</tr>
 <tr>
<td>290</td> <td><b>new-array</b></td> <td>built-in</td> <td>Syntax: (new-array &lt;type&gt; &lt;size&gt; members...)<br/><br/>  The &#39;new-array&#39; function returns an initialized array with the specified type and size.<br><br> <pre>Examples:
    (new-array ^int 5)      ; returns a new integer array with 5 elements
    (new-array ^int 3)      ; returns an integer array containing [1 2 3]</pre><br/><i>See also: new</i></td>
</tr>
 <tr>
<td>291</td> <td><b>new-dict</b></td> <td>built-in</td> <td>Syntax: (new-dict &lt;keytype&gt; &lt;valueType&gt; key1 value1 key2 value2 ... keyN valueN)<br/><br/>  Create a new generic dictionary with the keys and values constrained to the specified types. The type can be followed by an optional list of keys and values that will be used to populate the dictionary.<br><br> <pre>Examples:
    (new-dict ^string ^int &quot;one&quot; 1 &quot;two&quot; 2) ; creates Dictionary&lt;string,int&gt; with 2 pairs.</pre><br/><i>See also: dict?</i></td>
</tr>
 <tr>
<td>292</td> <td><b>new-stopwatch</b></td> <td>autoload.tl</td> <td>Syntax: (new-stopwatch [])<br/><br/>  The &#39;new-stopwatch&#39; function returns a .NET ^System.Diagnostics.Stopwatch object which can be used to time operations. The returned object has members .start, .stop, .elapsed, .reset.<br><br> <pre>Examples:
    (let sw (new-stopwatch))            ; create the mobject
    (.start sw)                         ; start timing
    (.stop sw)                          ; stop timing
    (.elapsed sw | totalmilliseconds)   ; get elapsed time.
    (.reset sw)                         ; reset the stopwatch.</pre><br/><i>See also: time</i></td>
</tr>
 <tr>
<td>293</td> <td><b>new-vector</b></td> <td>built-in</td> <td>Syntax: (new-vector [&lt;args&gt;...])<br/><br/>  The &#39;new-vector&#39; function constructs new vector objects. If no arguments are provided, an empty vector wil be constructed. If arguments are provided, they will be added to the new vector.<br><br> <pre>Examples:
    (new-vector)            ; construct a new empty vector
    (new-vector 1 &quot;two&quot;)  ; construct a 2 element vector
    (apply new-vector (list 1 2 3 4))</pre><br/><i>See also: to-vector vector? vector</i></td>
</tr>
 <tr>
<td>294</td> <td><b>nil?</b></td> <td>built-in</td> <td>Syntax: (nil? &lt;object&gt;)<br/><br/>  Returns true if the argument object is null. &#39;null?&#39; and &#39;nil?&#39; are aliases.<br><br><pre></pre><br/><i>See also: nil? null? nil null notnull? notnil?</i></td>
</tr>
 <tr>
<td>295</td> <td><b>none?</b></td> <td>built-in</td> <td>Syntax: (none? argument)<br/><br/>  The &#39;none?&#39; function returns true if its argument has a value i.e. it is not null, &quot;&quot; or [].<br><br> <pre>Examples:
    (none? 1)                ; returns false
    (none? 0)                ; returns false
    (none? null)             ; returns true
    (none? &quot;&quot;)             ; returns true
    (none? [])               ; returns true
    (none? [ null ])         ; returns false</pre><br/><i>See also: some? null?</i></td>
</tr>
 <tr>
<td>296</td> <td><b>normalize-string</b></td> <td>autoload.tl</td> <td>Syntax: (normalize-string [args])<br/><br/>  Concatenates all arguments into a string, reduces multiple whitespace chars to a single space then returns the result.<br><br><pre></pre><br/><i>See also: + join qstr</i></td>
</tr>
 <tr>
<td>297</td> <td><b>not</b></td> <td>built-in</td> <td>Syntax: (not &lt;object&gt;)<br/><br/>  Is the boolean complement function. If the argument object is interpreted as true, then the function returns false and vise versa. Since all objects have a boolean interpretation this function can be applied to anything.<pre></pre><br/></td>
</tr>
 <tr>
<td>298</td> <td><b>notnil?</b></td> <td>built-in</td> <td>Syntax: (notnil? &lt;object&gt;)<br/><br/>  Returns true if the argument object is not null. &#39;notnull?&#39; and &#39;notnil?&#39; are aliases.<br><br><pre></pre><br/><i>See also: nil? null? nil null</i></td>
</tr>
 <tr>
<td>299</td> <td><b>notnull?</b></td> <td>built-in</td> <td>Syntax: (notnull? &lt;object&gt;)<br/><br/>  Returns true if the argument object is not null. &#39;notnull?&#39; and &#39;notnil?&#39; are aliases.<br><br><pre></pre><br/><i>See also: nil? null? nil null</i></td>
</tr>
 <tr>
<td>300</td> <td><b>null?</b></td> <td>built-in</td> <td>Syntax: (null? &lt;object&gt;)<br/><br/>  Returns true if the argument object is null. &#39;null?&#39; and &#39;nil?&#39; are aliases.<br><br><pre></pre><br/><i>See also: nil? null? nil null notnull? notnil?</i></td>
</tr>
 <tr>
<td>301</td> <td><b>number?</b></td> <td>built-in</td> <td>Syntax: (number? &lt;object&gt;)<br/><br/>  Returns true if the argument object is any of the numeric types.<br><br><pre>Examples:
    (number? 1)     ; returns true
    (number? 1.0)   ; returns true
    (number? &quot;1&quot;)   ; returns false
    (number? :abc)  ; returns false</pre><br/></td>
</tr>
 <tr>
<td>302</td> <td><b>odd?</b></td> <td>built-in</td> <td>Syntax: (odd? argument)<br/><br/>  The &#39;odd?&#39; function returns true if its argument is an odd number.<br><br> <pre>Examples:
    (odd? 4)                       ; returns false
    (odd? 5)                       ; returns true</pre><br/><i>See also: none? some? number? number? even?</i></td>
</tr>
 <tr>
<td>303</td> <td><b>or</b></td> <td>built-in</td> <td>Syntax: (or arg1 arg2 arg3 ... argn)<br/><br/>  The &#39;or&#39; function returns a true value if any of its arguments evaluate to a true value. Lazy evaluation is used so the first argument that evaluates to true halts execution and that value is returned.<br><br>  AutoCurry: true<pre>Examples:
    (or true true true)    ; returns true
    (or true false true)   ; returns true
    (or 1 2)               ; returns 1
    (or 0 2)               ; returns 2</pre><br/><i>See also: and not xor</i></td>
</tr>
 <tr>
<td>304</td> <td><b>or$</b></td> <td>autoload.tl</td> <td>Syntax: (or$ [args])<br/><br/>  The &#39;or$&#39; (&#39;or compose&#39;) function takes a list of functions and returns a new function composed of the individual functions with the results or&#39;ed together. The argument to the outer function is passed to each of the inner functions. The results of these functions are or&#39;ed together to produce a final result.<br><br> <br><br><pre>Examples:
    ; the following returns all members of the range divisible by 3 or 5
    (range 20 | filter (or$ ($ (% 3) not) ($ (% 5) not) false))
    ; define a function that returns true for numbers &gt; 10 or &lt; 5
    (let f (or$ (&gt; 10) (&lt; 5)))
    (f 12)                      ; returns true
    (f 7)                       ; returns false
    (f 3)                       ; returns true</pre><br/><i>See also: partial compliment compose</i></td>
</tr>
 <tr>
<td>305</td> <td><b>out-list</b></td> <td>autoload.tl</td> <td>Syntax: (out-list [obj])<br/><br/>  A function to format the argument object using PowerShell&#39;s Format-List. It returns a list of strings.<br><br><pre>Examples:
    (get-childitem | out-list)                  ; format the output of get-childitem 
    (out-list (get-childitem))
    ({:a 1 :b 2 :c 3} | out-list)               ; format a dictionary</pre><br/></td>
</tr>
 <tr>
<td>306</td> <td><b>p</b></td> <td>unittests.tl</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>307</td> <td><b>pair?</b></td> <td>built-in</td> <td>Syntax: (pair? &lt;object&gt;)<br/><br/>  Returns true if the argument is a list (dotted-pair).<br><br><pre></pre><br/><i>See also: list? atom?</i></td>
</tr>
 <tr>
<td>308</td> <td><b>parse-file</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>309</td> <td><b>parse-text</b></td> <td>autoload.tl</td> <td>Syntax: (parse-text [text])<br/><br/>  Parses a string into s-Expressions. This can be useful to see what a macro expands to.<br><br> <pre>Examples:
    (.BraidLang.Braid/parse &quot;(for (let i 0) (&lt; i 10) (incr i))&quot;)
    ; after macro expansion, resolves to:
    ((do (local i 0) (while (&lt; i 10) (incr i))))
    ; with the macro fully expanded.</pre><br/><i>See also: file/parse eval</i></td>
</tr>
 <tr>
<td>310</td> <td><b>partial</b></td> <td>autoload.tl</td> <td>Syntax: (partial [func-to-call value args])<br/><br/>  The &#39;partial&#39; function takes a function of n-arguments and returns a new function of n-1 arguments. The signature of the function is: (partial function value &amp;args) The first argument is the function to be curried, the second and remaining arguments will be passed to that function by default when the new function is applied. For example, consider the following definition: (let +1 (partial + 1)) This takes the plus function which takes 2 arguments and returns a new function &#39;+1&#39; which takes 1 argument. This new function can be applied as follows.<br><br> <pre>Examples:
    (+1 1)      ; returns 2
    (+1 (+1 1)) ; returns 3</pre><br/><i>See also: compliment compose</i></td>
</tr>
 <tr>
<td>311</td> <td><b>path</b></td> <td>autoload.tl</td> <td>Syntax: (path [])<br/><br/>  Get the current value of the PATH environment variable.<pre></pre><br/></td>
</tr>
 <tr>
<td>312</td> <td><b>pattern-peg</b></td> <td>autoload.tl</td> <td>Syntax: (pattern-peg [str offset elements])<br/><br/>  Defines a PEG pattern<pre></pre><br/></td>
</tr>
 <tr>
<td>313</td> <td><b>pdecr</b></td> <td>built-in</td> <td>Syntax: (pdecr variableToDecrement)<br/><br/>  This function decrements the value in the named variable, returning the original value. The value in the variable must be of an integral type.<br><br> <pre>Examples:
    (let a 5)
    (pdecr a) ; returns 4 and the value of &#39;a&#39; is now 4.</pre><br/><i>See also: decr incr pincr</i></td>
</tr>
 <tr>
<td>314</td> <td><b>permute</b></td> <td>autoload.tl</td> <td>Syntax: [ x: | x:xs ]<br/><br/>  Generate the all of the permutations of a sequence of items.<br><br><pre></pre><br/><i>See also: choose combinations</i></td>
</tr>
 <tr>
<td>315</td> <td><b>PID</b></td> <td>autoload.tl</td> <td>Syntax: (PID [])<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>316</td> <td><b>pincr</b></td> <td>built-in</td> <td>Syntax: (pincr variable [increment])<br/><br/>  Increment a variable by the desired amount, returning the original un-incremented value. If no increment is specified, the 1 is used. This function can only be used for variables containing integral values (e.g. ^int or ^long)<br><br> <pre>Examples:
    (let a 0)
    (println (pincr a)) ; prints 1 on the screen
    (println a)         ; prints 1 on the screen (a is 1)
    (let i 0) (while (pincr i | &lt; 10) (println i))</pre><br/><i>See also: incr decr pdecr ++ --</i></td>
</tr>
 <tr>
<td>317</td> <td><b>pipe</b></td> <td>built-in</td> <td>Syntax: (pipe &lt;value&gt; (expr1) (expr2) ... (exprN))<br/><br/>  This function implements the logic for the form (a | b | c) which is translated at compile time into (pipe a (b) (c)) There&#39;s not a lot of reason to use this function directly.<br><br><pre>Examples:
    (pipe (range 10) (where (% 2)) (sum))   ; same as  (range 10 | where (% 2) | sum)</pre><br/></td>
</tr>
 <tr>
<td>318</td> <td><b>pos?</b></td> <td>built-in</td> <td>Syntax: (pos? &lt;number&gt;)<br/><br/>  Returns true if the argument number is positive.<br><br><pre>Examples:
    (pos? 1)                ; returns true
    (pos? -1)               ; returns false
    (numbers | filter pos?) ; returns only the positive numbers from &#39;numbers&#39;</pre><br/></td>
</tr>
 <tr>
<td>319</td> <td><b>print</b></td> <td>built-in</td> <td>Syntax: (print arg1 arg2 arg3 ... argN)<br/><br/>  Print a string made out of the tostring&#39;s of each of the argument to the console without adding a newline at the end.<br><br><pre></pre><br/><i>See also: println alert info error</i></td>
</tr>
 <tr>
<td>320</td> <td><b>printat</b></td> <td>built-in</td> <td>Syntax: (printat [-foreground: color] [-background: color] x y msg)<br/><br/>  Print a string at the specified location, optionally specifying the foreground and background colors.<br><br><pre>Examples:
    (printat 40 40 &quot;Amessage&quot;)</pre><br/></td>
</tr>
 <tr>
<td>321</td> <td><b>println</b></td> <td>built-in</td> <td>Syntax: (println arg1 arg2 arg3 ... argN)<br/><br/>  Print a string made out of the tostring&#39;s of each of the argument to the console adding a newline at the end.<br><br><pre></pre><br/><i>See also: print alert info error</i></td>
</tr>
 <tr>
<td>322</td> <td><b>println-color</b></td> <td>built-in</td> <td>Syntax: (println-color &lt;foreground&gt; &lt;background&gt; arg3 arg4 ... argn)<br/><br/>  The first two arguments are treated as the colors to uese and the remaining arguments are contcatenated into a string to be displayed. Spaces are placed between each value in the resulting string. Cooersion on the color arguments is used so they can be specified as strings rather than ^System.ConsoleColor values.<br><br><pre>Examples:
    (println-color &quot;red&quot; &quot;black&quot; &quot;2+2 = &quot;  (+ 2 2) &#39;so there!)</pre><br/></td>
</tr>
 <tr>
<td>323</td> <td><b>prod</b></td> <td>autoload.tl</td> <td>Syntax: [ (^ISeq listOfNumbers) | (^ISeq listOfNumbers) accessor | %none? (accessor null) | n (accessor echo) | args ]<br/><br/>  Compute the product of the numbers in the argument list.<pre></pre><br/></td>
</tr>
 <tr>
<td>324</td> <td><b>project</b></td> <td>autoload.tl</td> <td>Syntax: (project [data args])<br/><br/>  This function &quot;projects&quot; a subset of the properties on an object (or elements of a dictionary) onto a new anonymously-typed object. The anonymous types are generated on an on-demand basis.<br><br> If the first object is a Dictionary, rather than enumerating the object, a new anonymously-typed object is returned where the object properties correspond to the dictionary keys.<br><br> Note: Anonymous types are unified based on the type&#39;s property names (but not types). A dictionary of the currently defined anonymous types is available in the variable *anonymous-types*. So they&#39;re not really anonymous.<br><br> <pre>Examples:
    (project {:a 1 :b 2 :c 3})                       ; turns the dictionary into an anonymously typed object.
    (gps | project :name :id :ws)                    ; returns object with properties name,id and ws.
    ([{:a 1 :b 2} {:a 2 :b 4 :c 5}] | project :a :b) ; return objects with only props a &amp; b
    ([{:a 1 :b 2} {:a 2 :b 4 :c 5}] | project)       ; return different kinds of objects with all props</pre><br/><i>See also: deftype defobject</i></td>
</tr>
 <tr>
<td>325</td> <td><b>psvar</b></td> <td>powershell</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>326</td> <td><b>pwd</b></td> <td>autoload.tl</td> <td>Syntax: (pwd [])<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>327</td> <td><b>python</b></td> <td>autoload.tl</td> <td>Syntax: (python [args])<br/><br/>  Start the python 3.7 interpreter. If there are args, exec the binary directly passing the arguments. if there are no arguments then use &#39;start&#39; to launch an interactive session.<pre></pre><br/></td>
</tr>
 <tr>
<td>328</td> <td><b>qsort</b></td> <td>autoload.tl</td> <td>Syntax: [ %none? | pivot:xs ]<br/><br/>  Recursive &#39;quicksort&#39; (after the Haskell equivalent). Uses list/split to avoid double filtering.<br><br> <pre>Examples:
    (qsort [5 2 6 9 1 3 4 8 7])     ; returns [1 2 3 4 5 6 7 8 9]</pre><br/><i>See also: sort</i></td>
</tr>
 <tr>
<td>329</td> <td><b>qstr</b></td> <td>autoload.tl</td> <td>Syntax: (qstr [args])<br/><br/>  Concatenates all unevaluated arguments into a string. Unquoted elements are evaluated.<br><br> returns the string<br><br><pre>Examples:
     (let 1) (let y 2)
     (qstr this is a test x is ~x y is ~y)
    &quot;this is a test x is 1 y is 2&quot;</pre><br/><i>See also: + join str</i></td>
</tr>
 <tr>
<td>330</td> <td><b>quit</b></td> <td>built-in</td> <td>Syntax: (quit)<br/><br/>  Quits the current braid session. If in a nested (debug) session, this will return you to the parent session.<pre></pre><br/></td>
</tr>
 <tr>
<td>331</td> <td><b>quote?</b></td> <td>built-in</td> <td>Syntax: (quote? argument)<br/><br/>  The &#39;quote?&#39; function returns true if its argument is quoted.<br><br> <pre>Examples:</pre><br/><i>See also: quote</i></td>
</tr>
 <tr>
<td>332</td> <td><b>random</b></td> <td>built-in</td> <td>Syntax: (random &lt;number&gt;) or (random &lt;min&gt; &lt;max&gt;) or (random &lt;number&gt; &lt;min&gt; &lt;max&gt;)<br/><br/>  This function generates a sequence of random numbers. If a single argument is specified, that argument is used as the number of numbers to generate, ranging from 0 to the number. If two arguments are specified, they represent the min and max of the range and the difference (max-min) is the number of numbers to generate. Finally if three numbers are specified, the first is the number of numbers to generate and the second and third represent the range into which the numbers should be generated.<br><br> <pre>Examples:
    (random 10)      ; generates 10 random numbers
    (random 5 10)    ; generates 5 random numbers between 5 and 10
    (random 5 10 20) ; generates 5 numbers between 10 and 20
    (random 100 | qsort) ; generates 100 numbers then sorts them</pre><br/><i>See also: range</i></td>
</tr>
 <tr>
<td>333</td> <td><b>range</b></td> <td>built-in</td> <td>Syntax: (range upper) or (range lower upper) or (range lower upper increment)<br/><br/>  Generates a range of numbers. If omly one number is provided, the range will be from 1 to that number. If two numbers are provided, they represent the bounds of the range. If the first number is larger than the second, the range will be counted down.  You can also specify a third argument  the increment, which sets the step count.  Note - stepping is always done so the larger number will converge with the smaller.<br><br><pre>Examples:
    (range 10)      ; returns 1-10.
    (range 10 1)    ; returns 10-1
    (range 0 10 2)  ; returns [0 2 4 6 8 10]</pre><br/></td>
</tr>
 <tr>
<td>334</td> <td><b>re/match</b></td> <td>autoload.tl</td> <td>Syntax: (re/match [(^string? targetString) (^regex? regex) (func nil)])<br/><br/>  Match a single string against a regular expression.<pre></pre><br/></td>
</tr>
 <tr>
<td>335</td> <td><b>re/match-all</b></td> <td>autoload.tl</td> <td>Syntax: (re/match-all [listOfStrings (^regex? pattern)])<br/><br/>  Return all of the elements from a list that match the argument regex.<pre></pre><br/></td>
</tr>
 <tr>
<td>336</td> <td><b>re/not-match</b></td> <td>autoload.tl</td> <td>Syntax: (re/not-match [(^string? targetString) (^regex? regex)])<br/><br/>  Match a single string that doesn&#39;t match a regular expression.<pre></pre><br/></td>
</tr>
 <tr>
<td>337</td> <td><b>re/not-match-all</b></td> <td>autoload.tl</td> <td>Syntax: (re/not-match-all [listOfStrings (^regex? pattern)])<br/><br/>  Return all of the elements from a list that don&#39;t match the argument regex.<pre></pre><br/></td>
</tr>
 <tr>
<td>338</td> <td><b>re/replace</b></td> <td>autoload.tl</td> <td>Syntax: [ (^string? string) (^regex? regex) (^string? replaceStr) | (^string? string) (^regex regex) ]<br/><br/>  Replace all occurances of a substring in a string with an optional replacement string. If the replacement string is not provided then the empty string will be used.<br><br> <pre>Examples:
    (re/replace &quot;abcd&quot; #&quot;[bd]+&quot;)            ; returns &quot;ab&quot;
    (re/replace &quot;abcd&quot; #&quot;[bd]+&quot; &quot;---&quot;)    ; returns &quot;a---d&quot;</pre><br/><i>See also: re/replace-all</i></td>
</tr>
 <tr>
<td>339</td> <td><b>re/replace-all</b></td> <td>autoload.tl</td> <td>Syntax: (re/replace-all [lst (^regex? regexToReplace) (^string? replaceStr &quot;&quot;)])<br/><br/>  Process a list of strings, replacing all occurances of the target string in each list item with the provided replacement string. If no replacement string has been provided, the empty string will be used.<br><br> <pre>Examples:
    (ls | .name | re/replace-add #&quot;\.tl&quot;)     ; remove the .tl extension
    (ls | .name | re/replace-add #&quot;\.tl&quot; &quot;.br&quot;) ; replace the .tl extension with .br</pre><br/><i>See also: re/replace</i></td>
</tr>
 <tr>
<td>340</td> <td><b>re/split</b></td> <td>autoload.tl</td> <td>Syntax: [ stringToSplit (^symbol by) | stringToSplit (^regex? by) | stringToSplit (^char? by) | stringToSplit (^string? by) | stringToSplit ]<br/><br/>  The &#39;split&#39; function will split a string into a number of pieces based on a provided regular expression or using the default expression which is #&quot; +&quot;. If the pattern is empty i.e. #&quot;&quot;, the string will be split into individual 1-character strings.<br><br> <pre>Examples:
    (re/split &quot;a,b,c&quot; #&quot;,&quot;)    ; returns [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
    (re/split &quot;a,b,c&quot; , #&quot;&quot;)   ; An empty pattern will split the string into individual characters.</pre><br/><i>See also: re/split-all</i></td>
</tr>
 <tr>
<td>341</td> <td><b>re/split-all</b></td> <td>autoload.tl</td> <td>Syntax: (re/split-all [lst (^regex? by &quot; +&quot;)])<br/><br/>  Splits each string in the argument list, flattens the result then returns the new vector containing all of the individual strings. An optional regular expression can be provided to use during the splits. The default split pattern is 1 or more whitespaces.<pre></pre><br/></td>
</tr>
 <tr>
<td>342</td> <td><b>read-data</b></td> <td>autoload.tl</td> <td>Syntax: (read-data [(^string path)])<br/><br/>  Read binary data from a file.<pre></pre><br/></td>
</tr>
 <tr>
<td>343</td> <td><b>read-file</b></td> <td>built-in</td> <td>Syntax: (read-file &lt;fileNames&gt; [&lt;regex&gt; [lambda]])<br/><br/>  This function reads files line by line, returning a vector of lines. If a regular expression is specified then only lines matching that regular expression will be returned. You can also specify a lambda which will be invoked on each matched item and the result of the invocation will be returned. The lambda receives 2-4 arguments which are, in order: - the text of the matching line - an array of the regex submatches in the line - the number of the matching line - the name of the current file The &#39;read-file&#39; function takes one named parameter &#39;-not&#39; which changes the regex processing from match to not match.<br><br> <pre>Examples:
    (read-file &#39;foo.txt)                 ; returns a vector of the lines in the file
    (read-file &#39;foo.txt #&quot;bar&quot;)        ; only returns the lines matching the regex
    ; Return the names of braid functions defined in a file i.e. &#39; ... defn &lt;name&gt; ...&#39;
    (read-file &#39;autoload.tl  #&quot;defn +([^ ]+)&quot; (fn l m -&gt; (!! m 1)))a
    ; Read all of the *.tl files and return strings of the form &quot;fileName:lineno functionName&quot;.
    (read-file &#39;*.tl #&quot;defn +([^ ]+)&quot; (fn l m n f -&gt; (str f &#39;: n &quot; &quot; (m 1))))</pre><br/><i>See also: read-text read-data</i></td>
</tr>
 <tr>
<td>344</td> <td><b>read-lines</b></td> <td>built-in</td> <td>Syntax: (read-file &lt;fileNames&gt; [&lt;regex&gt; [lambda]])<br/><br/>  This function reads files line by line, returning a vector of lines. If a regular expression is specified then only lines matching that regular expression will be returned. You can also specify a lambda which will be invoked on each matched item and the result of the invocation will be returned. The lambda receives 2-4 arguments which are, in order: - the text of the matching line - an array of the regex submatches in the line - the number of the matching line - the name of the current file The &#39;read-file&#39; function takes one named parameter &#39;-not&#39; which changes the regex processing from match to not match.<br><br> <pre>Examples:
    (read-lines &#39;foo.txt)                 ; returns a vector of the lines in the file
    (read-lines &#39;foo.txt #&quot;bar&quot;)        ; only returns the lines matching the regex
    ; Return the names of braid functions defined in a file i.e. &#39; ... defn &lt;name&gt; ...&#39;
    (read-lines &#39;autoload.tl  #&quot;defn +([^ ]+)&quot; (fn l m -&gt; (!! m 1)))a
    ; Read all of the *.tl files and return strings of the form &quot;fileName:lineno functionName&quot;.
    (read-lines &#39;*.tl #&quot;defn +([^ ]+)&quot; (fn l m n f -&gt; (str f &#39;: n &quot; &quot; (m 1))))</pre><br/><i>See also: read-text read-data</i></td>
</tr>
 <tr>
<td>345</td> <td><b>read-text</b></td> <td>autoload.tl</td> <td>Syntax: (read-text [(^string? path)])<br/><br/>  This function reads all of the text in a file and returns it as a single string.<br><br> <pre>Examples:
    (read-text foo.txt)</pre><br/><i>See also: read-file write-text write-data write-lines</i></td>
</tr>
 <tr>
<td>346</td> <td><b>recur</b></td> <td>built-in</td> <td>Syntax: (recur arglist...)<br/><br/>  The &#39;recur&#39; function allows you to write tail-recursive programs in braid. When invoked, it transfers control to the nearest function or loop context. You can pass arguments to &#39;recur&#39; which must match the arity of the enclosing function.<br><br><pre>Examples:
    (loop [x 10] (if x (do (println x) (recur (-- x))) &#39;done))
    (defn sum | x:xs -&gt; (println x) (recur xs) | -&gt; &#39;done)</pre><br/><i>See also: loop recur-to defn fn lambda</i></td>
</tr>
 <tr>
<td>347</td> <td><b>recur-to</b></td> <td>built-in</td> <td>Syntax: (recur-to targetFunc arglist...)<br/><br/>  The &#39;recur-to&#39; function allows you to write tail-recursive programs in Braid when you need to recur to a specific function. When invoked, it transfers control to the identified function context. You must pass arguments to &#39;recur-to&#39; with the same arity of the target function. Note: the target function is identified by the functions value, not its name.<br><br> <pre>Examples:
    (defn outer [x y] (if (== x 1) (recur-to outer 0 10) y)     ; (outer 1 0) returns 10
    (defn outer [x y] ((fn -&gt; (if (== x 1) (recur-to outer 0 10) y)))) ; recur to outer function</pre><br/><i>See also: loop recur defn fn lambda</i></td>
</tr>
 <tr>
<td>348</td> <td><b>reduce</b></td> <td>built-in</td> <td>Syntax: (reduce &lt;list&gt; &lt;function&gt; [seed])<br/><br/>  This function iterates through a list applying the function to each of the items and accumulating a result. An optional seed value can be provided.<br><br> <pre>Examples:
    (range 10 | reduce (fn x y -&gt; (+ x y)))               ; sum the numbers from 1 to 10 using a lambda
    (range 10 | reduce (fn x y -&gt; (* x y)))               ; computer 10 factorial
    (range 10 | reduce +)                                 ; sums the numbers 1-10 using the &#39;+&#39; function.
    (ls &#39;*.tl | reduce (fn x y -&gt; (+ x (.length y))) 0)   ; sums the length of the *.tl files</pre><br/><i>See also: reduce foldl foldr unfold</i></td>
</tr>
 <tr>
<td>349</td> <td><b>reduce-with-seed</b></td> <td>built-in</td> <td>Syntax: (reduce-with-seed &lt;list&gt; &lt;function&gt; &lt;seedValue&gt;)<br/><br/>  This function iterates through a list applying the function to each of the items and accumulating a result. The accumulator is initialized with the seed value.<br><br>    (ls &#39;*.tl | reduce-with-seed (fn x y -&gt; (+ x (.length y))) 0)<br><br><pre>Examples:
    ; compute the total size of the &#39;*.tl files in the current directory</pre><br/><i>See also: reduce foldl foldr unfold</i></td>
</tr>
 <tr>
<td>350</td> <td><b>remove-watch</b></td> <td>powershell</td> <td>Syntax: (remove-watch)<br/><br/>  Removes a script watch that was set up with &#39;add-watch&#39;.<br><br> <pre>Examples:
    (get-watch)</pre><br/><i>See also: add-watch get-watch</i></td>
</tr>
 <tr>
<td>351</td> <td><b>repeat</b></td> <td>built-in</td> <td>Syntax: (repeat &lt;number&gt; clause1 clause2 clause3 ... clauseN)<br/><br/>  Evaluates each of the clause arguments in sequence, repeating the evaluation the specified number of times. This function always returns null.<br><br> <pre>Examples:
    (repeat 10 (println &#39;Hi)) ; print hi 10 times</pre><br/><i>See also: repeat-all do</i></td>
</tr>
 <tr>
<td>352</td> <td><b>repeat-all</b></td> <td>built-in</td> <td>Syntax: (repeat-all &lt;number&gt; clause1 clause2 clause3 ... clauseN)<br/><br/>  Evaluates each of the clause arguments in sequence, repeating the evaluation the specified number of times. This function a vector of the results of evaluating the last clause from each iteration.<br><br> <pre>Examples:
    (repeat-all 10 (.datetime/now)) ; get the date 10 times, returning 10 values</pre><br/><i>See also: repeat-all do</i></td>
</tr>
 <tr>
<td>353</td> <td><b>resolve</b></td> <td>built-in</td> <td>Syntax: (resolve &lt;listOfTasks&gt;)<br/><br/>  The resolve function waits for all argument tasks to complete and then returns a collection containing the values returned by the tasks. Note that even in the simple case of a single task, the result will still be returned as a collection of one element. &#39;resolve&#39; is an alias for &#39;await&#39;.<br><br><pre></pre><br/><i>See also: async task map-parallel</i></td>
</tr>
 <tr>
<td>354</td> <td><b>rest</b></td> <td>built-in</td> <td>Syntax: (rest listOfObjects)<br/><br/>  The &#39;rest&#39; function skips the first item in a sequence and returns the rest, or it returns the item itself if it&#39;s an atom. Note that for sequences, cdr always returns an s_Expr regardless of the original type of the sequence. This is for performance reasons. Getting the cdr of a Vector is slow. Getting the cdr of an s_Expr, is very fast. (Commands tail and rest are aliases for cdr.)<br><br> <pre>Examples:
    (car &#39;(1 2 3))  ; returns &#39;(2 3)
    (car [4 5 6])   ; returns [5 6[
    (car &quot;abc&quot;)     ; returns &quot;abc&quot;</pre><br/><i>See also: car head first tail rest</i></td>
</tr>
 <tr>
<td>355</td> <td><b>return</b></td> <td>built-in</td> <td>Syntax: (return [value])<br/><br/>  Returns from a function returning a value. Null is returned if the value is not specified.<br><br> <pre>Examples:
    (defn foo [] (return &quot;foo&quot;)</pre><br/><i>See also: break continue</i></td>
</tr>
 <tr>
<td>356</td> <td><b>reverse</b></td> <td>built-in</td> <td>Syntax: (reverse list)<br/><br/>  Reverses a list or vector, returning a new reversed list.<br><br><pre>Examples:
    (reverse [1 2 3])   ; returns [3 2 1]
    (reverse &#39;(1 2 3))  ; returns [3 2 1]
    (chars &quot;hello&quot; | reverse | join &quot;&quot;) ; returns &#39;olleh&#39;</pre><br/></td>
</tr>
 <tr>
<td>357</td> <td><b>rfact</b></td> <td>autoload.tl</td> <td>Syntax: [ 0 (result 1i) | number (result 1i) ]<br/><br/>  Computes the factorial of the argument recursively. Big integers are used.<br><br><pre>Examples:
    (fact 1)    ; reults in 1
    (fact 10)   ; results in 3628800</pre><br/></td>
</tr>
 <tr>
<td>358</td> <td><b>rfib</b></td> <td>autoload.tl</td> <td>Syntax: (rfib [number (prev 0i) (current 1i)])<br/><br/>  Implementation of &#39;fib&#39; that uses recur to implement a tail-recursive &#39;fib&#39; function<pre></pre><br/></td>
</tr>
 <tr>
<td>359</td> <td><b>rflatten</b></td> <td>autoload.tl</td> <td>Syntax: [ x:xs | x ]<br/><br/>  Flattens a sequence using patterns, destructuring and naive recursion.<br><br> <pre>Examples:
    (rflatten [[1 2] 4 4]       ; returns [1 2 3 4]
    (rflatten [[[1]] [2]]       ; returns [1 2]</pre><br/><i>See also: flatten</i></td>
</tr>
 <tr>
<td>360</td> <td><b>roll</b></td> <td>autoload.tl</td> <td>Syntax: (roll [r (^int n 1)])<br/><br/>  Roll the argument integer left by the specified number of bits<br><br> <pre>Examples:
    (roll 0xDEADBEEF 4)  ; will return 0xEADBEEFD
    (roll 0xDEADBEEF 16) ; will return 0xBEEFDEAD</pre><br/><i>See also: roll band bor bxor bnot</i></td>
</tr>
 <tr>
<td>361</td> <td><b>rolr</b></td> <td>autoload.tl</td> <td>Syntax: (rolr [r (^int n 1)])<br/><br/>  Roll the argument integer right by the specified number of bits<br><br> <pre>Examples:
    (rolr 0xDEADBEEF 4)  ; will return 0xFDEADBEE
    (rolr 0xDEADBEEF 8)  ; will return 0xEFDEADBE
    (rolr 0xDEADBEEF 16) ; will return 0xBEEFDEAD</pre><br/><i>See also: roll band bor bxor bnot</i></td>
</tr>
 <tr>
<td>362</td> <td><b>round</b></td> <td>autoload.tl</td> <td>Syntax: (round [num (places 0)])<br/><br/>  Round the argument value. An option number of places to round to can be specified. By default, the number is rounded with 0 decimal places.<br><br><pre>Examples:
    (round 3.1415)      ; returns 3
    (round 3.1415 2)    ; returns 3.14</pre><br/></td>
</tr>
 <tr>
<td>363</td> <td><b>rpfib</b></td> <td>autoload.tl</td> <td>Syntax: [ 0 _ (current 0i) | number (prev 0i) (current 1i) ]<br/><br/>  A pattern function implementation of &#39;fib&#39; that uses &#39;recur&#39; and patterns.<pre></pre><br/></td>
</tr>
 <tr>
<td>364</td> <td><b>rprg</b></td> <td>autoload.tl</td> <td>Syntax: (rprg [(^string program) args])<br/><br/>  This function is used to run an executable directly on the console. In Braid, while an executable can be run simply by putting it&#39;s name in the function position, the output of these executables is always redirected. Consequently, &#39;rprg&#39; should be used to run any program that do direct console manipulation such as interactive programs (e.g. editors) or use console control sequences in output e.g. git.<br><br> <pre>Examples:
    (rprg :vi &quot;foo.txt&quot;)    ; run an interactive VI session
    (rprg :git :diff)         ; run git diff with console coloring</pre><br/><i>See also: Start-Process</i></td>
</tr>
 <tr>
<td>365</td> <td><b>r-rev</b></td> <td>autoload.tl</td> <td>Syntax: [ x:xs | x ]<br/><br/>  Reverse a sequence recursively using pattern matching and naive recursion.<pre></pre><br/></td>
</tr>
 <tr>
<td>366</td> <td><b>scalarize</b></td> <td>autoload.tl</td> <td>Syntax: [ (^iseq lst) | lst | nil ]<br/><br/>  If the argument is a collection of 1 element, extract it and return it as a scalar<pre></pre><br/></td>
</tr>
 <tr>
<td>367</td> <td><b>scs</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>368</td> <td><b>second</b></td> <td>autoload.tl</td> <td>Syntax: (second [lst])<br/><br/>  Returns the second item in a sequence<pre></pre><br/></td>
</tr>
 <tr>
<td>369</td> <td><b>Select-Type</b></td> <td>autoload.tl</td> <td>Syntax: (Select-Type [(^regex? pattern #&quot;.&quot;)])<br/><br/>  Look for types based on a regular expression.<pre></pre><br/></td>
</tr>
 <tr>
<td>370</td> <td><b>seq?</b></td> <td>built-in</td> <td>Syntax: (seq? object)<br/><br/>  The &#39;seq?&#39; function returns true if it&#39;s argument is a sequence type (list or vector).<br><br><pre>Examples:
    (seq? &#39;(1 2 3)) ; returns true
    (seq? [1 2 3])  ; returns true
    (seq? 123)      ; returns false</pre><br/></td>
</tr>
 <tr>
<td>371</td> <td><b>set</b></td> <td>built-in</td> <td>Syntax: (set &lt;varNameExpr&gt; &lt;value&gt;)<br/><br/>  Sets the value of the variable named by the result of evaluating &lt;varNameExpression&gt;. This allows you to do indirect sets of variables.<br><br> <pre>Examples:
    (def n &#39;x) (set n 123)  ; sets the variable &#39;x&#39; to 123
    (set &#39;foo 123)          ; equivalent to (setq foo 123)</pre><br/><i>See also: setq def let get</i></td>
</tr>
 <tr>
<td>372</td> <td><b>Set-Assoc</b></td> <td>built-in</td> <td>Syntax: (set-assoc object key value)<br/><br/>  This function allows you to associate tagged data with an arbitrary object. For example, you could tag the number 1 with a message as follows: and then retrieve it with<br><br><pre>
    (set-assoc 1 :message &quot;Hi there&quot;)
    (get-assoc 1 :message)</pre><br/><i>See also: get-assoc</i></td>
</tr>
 <tr>
<td>373</td> <td><b>set-env</b></td> <td>autoload.tl</td> <td>Syntax: (set-env [(^string? varname) (^string? value) (^EnvironmentVariableTarget scope .EnvironmentVariableTarget/Process)])<br/><br/>  This function sets an environment variable. The &#39;-scope:&#39; option allows variables to be set at either machine or user scope as well at process scope (the default).<br><br> <pre>Examples:
    (set-env &#39;zork 13)</pre><br/><i>See also: get-env env</i></td>
</tr>
 <tr>
<td>374</td> <td><b>setq</b></td> <td>built-in</td> <td>Syntax: (setq name value)<br/><br/>  Set the value of the named variable if a variable with that name already exists or create a new variable in the current scope if it doesn&#39;t.<br><br> Note: If the name takes the form &#39;v1:v2:v3&#39; then destructuring will be done and the parts of the argument collection will be assigned to the variables.<br><br> <pre>Examples:
    (setq foo 123)
    (setq x:y:z [1 2 3 4 5])</pre><br/><i>See also: let defn &gt;def def setq</i></td>
</tr>
 <tr>
<td>375</td> <td><b>shell</b></td> <td>built-in</td> <td>Syntax: (shell cmds...)<br/><br/>  The &#39;shell&#39; function concatenates its arguments and then runs the resulting string as a PowerShell script.<br><br> <pre>Examples:
    (shell &quot;Get-ChildItem&quot; &quot;-File&quot;)
    (shell &quot;foreach ($i in 1..10) {$i}&quot;)</pre><br/><i>See also: psvar</i></td>
</tr>
 <tr>
<td>376</td> <td><b>shiftl</b></td> <td>built-in</td> <td>Syntax: (shiftl value numberOfBitsToShift)<br/><br/>  Shifts a value the specified number of bits to the left.<br><br><pre></pre><br/><i>See also: shiftr band bor bxor</i></td>
</tr>
 <tr>
<td>377</td> <td><b>shiftr</b></td> <td>built-in</td> <td>Syntax: (shiftr value numberOfBitsToShift)<br/><br/>  Shifts a value the specified number of bits to the right.<br><br><pre></pre><br/><i>See also: shiftl band bor bxor</i></td>
</tr>
 <tr>
<td>378</td> <td><b>show-callstack</b></td> <td>built-in</td> <td>Syntax: (show-callstack)<br/><br/>  This function dumps all of the current bindings in the variable table across all of the dynamic scopes. It takes no arguments and any provided arguments will be ignored. &#39;scs&#39; is an alias for show-callstack.<br><br><pre>Examples:
    (show-callstack)</pre><br/></td>
</tr>
 <tr>
<td>379</td> <td><b>show-symbols</b></td> <td>built-in</td> <td>Syntax: (show-symbols)<br/><br/>  This function returns all of the symbols currently in the symbol table. It takes no arguments and any provided arguments will be ignored.<pre></pre><br/></td>
</tr>
 <tr>
<td>380</td> <td><b>sieve</b></td> <td>autoload.tl</td> <td>Syntax: [ x:xs r | _ r | n ]<br/><br/>  Find all primes in the range 1 to n using a &#39;Sieve of Eratosthenes&#39;-like algorithm.<pre></pre><br/></td>
</tr>
 <tr>
<td>381</td> <td><b>sign</b></td> <td>autoload.tl</td> <td>Syntax: (sign [num])<br/><br/>  The &#39;sign&#39; function returns the &#39;sign&#39; of its argument: -1 if negative; 1 if it&#39;s positive. An error will be returned if the argument is not numeric.<br><br> <pre>Examples:
    (sign -5) ; returns -1
    (sign 5)	 ; returns 1</pre><br/><i>See also: abs round ceiling floor</i></td>
</tr>
 <tr>
<td>382</td> <td><b>sin</b></td> <td>autoload.tl</td> <td>Syntax: (sin [num])<br/><br/>  Compute the sine of a number<pre></pre><br/></td>
</tr>
 <tr>
<td>383</td> <td><b>skip</b></td> <td>built-in</td> <td>Syntax: (skip &lt;coll&gt; &lt;number)<br/><br/>  This function skips the first &lt;number&gt; items in collection &lt;coll&gt;. If the collection is too short, then an empty collection will be returned. If &lt;coll&gt; is an ^IList, skip will return an immutable ^Slice addressing the remainder of &lt;coll&gt;. If &lt;coll&gt; is an ^IEnumerable, skip will return a lazy enumerable for the rest of &lt;coll&gt;.<br><br> <pre>Examples:
    (skip [1 2 3 4 5] 3) ; returns (4 5)</pre><br/><i>See also: skip-while</i></td>
</tr>
 <tr>
<td>384</td> <td><b>skip-while</b></td> <td>built-in</td> <td>Syntax: (skip-while &lt;list&gt; &lt;predicate&gt;)<br/><br/>  The &#39;skip-while&#39; function skips items in a list while the provided predicate evaluates to true. For example &#39;(range 100 | skip-while (fn n -&gt; (&lt; n 90)))&#39; will skip the numbers 1-89 returning 90-100.<br><br> <pre>Examples:
    (range 10 | skip-while (&lt; 8))   ; returns [8 9 10]</pre><br/><i>See also: skip</i></td>
</tr>
 <tr>
<td>385</td> <td><b>sleep</b></td> <td>autoload.tl</td> <td>Syntax: (sleep [(^int duration-ms)])<br/><br/>  This function sleeps for the specified number of milliseconds. Note that it sleeps in chunks so it can be interrupted with ctrl-C.<br><br><pre>Examples:
    (sleep 1000)        ; sleep 1 second
    (sleep (* 1000 60)) ; sleep 1 minute</pre><br/></td>
</tr>
 <tr>
<td>386</td> <td><b>slice</b></td> <td>autoload.tl</td> <td>Syntax: (slice [(^IEnumerable vec) (^int start 0) (^int length (pipe (length vec) (- start)))])<br/><br/>  The &#39;slice&#39; function returns a ^Slice of an indexable collection (e.g a ^Vector or ^Array). A ^Slice object is essentially a &quot;window&quot; into the underlying collection. Slice takes two arguments - the offset into the collection to index from and the length of the collection. Note that slices are immutable which means that you can&#39;t change the underlying collection using the slice object. On the other hand, changes to the underlying collection will be reflected in the slice.<br><br> <pre>Examples:
    (range 10 | slice 2 3)          ; returns [3 4 5]</pre><br/><i>See also: to-vector vector asarray</i></td>
</tr>
 <tr>
<td>387</td> <td><b>sls</b></td> <td>autoload.tl</td> <td>Syntax: (sls [(path (quote . *.tl))])<br/><br/>  A function to print directory lstings in columns<pre></pre><br/></td>
</tr>
 <tr>
<td>388</td> <td><b>smaller</b></td> <td>built-in</td> <td>Syntax: (smaller args...)<br/><br/>  This function returns the smallest member of its argument list.<br><br><pre>Examples:
    (smaller 3 1 4 2)   ; returns 1</pre><br/></td>
</tr>
 <tr>
<td>389</td> <td><b>some?</b></td> <td>built-in</td> <td>Syntax: (some? argument)<br/><br/>  The &#39;some?&#39; function returns true if its argument has a value i.e. it is not null, &quot;&quot; or [].<br><br> <pre>Examples:
    (some? 1)                ; returns true
    (some? 0)                ; returns true
    (some? null)             ; returns false
    (some? &quot;&quot;)             ; returns false
    (some? [])               ; returns false
    (some? [ null ])         ; returns true</pre><br/><i>See also: some? null?</i></td>
</tr>
 <tr>
<td>390</td> <td><b>sort</b></td> <td>built-in</td> <td>Syntax: sort [-Descending] listToSort [keyFunction])<br/><br/>  This function sorts a sequence of values. By default, it sorts in ascending order but the &#39;-descending&#39; flag changes this to descending order. You can also specify a &#39;keyFunction&#39; that will be used to select the value to sort on. You can use the &#39;lazy-sort&#39; varient to pull values as needed.<br><br><pre>Examples:
    (random 10 | sort)                      ; sorts 10 random numbers in ascending order
    (random 10 | sort -descending)          ; sorts 10 random numbers in descending order
    (ls -file | sort .length)               ; sort files by length
    (ls &#39;* | sort (fn e -&gt; (.extension e))) ; sort files by extensions</pre><br/></td>
</tr>
 <tr>
<td>391</td> <td><b>spaces-peg</b></td> <td>autoload.tl</td> <td>Syntax: [ targ offset ]<br/><br/>  Skip over spaces in a string starting at offset<pre></pre><br/></td>
</tr>
 <tr>
<td>392</td> <td><b>splice</b></td> <td>built-in</td> <td>Syntax: (splice &lt;list1&gt; &lt;list2&gt;)<br/><br/>  Splices two lists together so that list2 becomes the &#39;cdr&#39; of list1, mutating list 1.<br><br><pre>Examples:
    (splice &#39;(1 2 3) &#39;(4 5 6)) ; returns (1 2 3 4 5 6)
    (do (let a &#39;(1 2 3)) (splice a &#39;(4 5 6)) a) ; returns (1 2 3 4 5 6)</pre><br/></td>
</tr>
 <tr>
<td>393</td> <td><b>sqr</b></td> <td>autoload.tl</td> <td>Syntax: (sqr [number])<br/><br/>  Squares a number.<br><br> <pre>Examples:
    (sqr 3) ; returns 9</pre><br/><i>See also: sqrt</i></td>
</tr>
 <tr>
<td>394</td> <td><b>sqrt</b></td> <td>autoload.tl</td> <td>Syntax: (sqrt [(^double? num)])<br/><br/>  Computes the sqrt of the argument value.<br><br> <pre>Examples:
    (sqrt 16 ; returns 4</pre><br/><i>See also: sqr</i></td>
</tr>
 <tr>
<td>395</td> <td><b>star-peg</b></td> <td>autoload.tl</td> <td>Syntax: (star-peg [(^string? targ) (^int offset) (^List? instructions)])<br/><br/>  Repeat a portion of a peg grammar<pre></pre><br/></td>
</tr>
 <tr>
<td>396</td> <td><b>str</b></td> <td>built-in</td> <td>Syntax: (str args...)<br/><br/>  The &#39;str&#39; function converts its arguments to strings the concatenates the individual strings with no intervening spaces. This function is similar to join but is varargs and doesn&#39;t allow a seperator.<br><br> <pre>Examples:
    (str 1 2 3)         ; returns &quot;123&quot;</pre><br/><i>See also: join</i></td>
</tr>
 <tr>
<td>397</td> <td><b>str/reverse</b></td> <td>autoload.tl</td> <td>Syntax: (str/reverse [(^string? argstr)])<br/><br/>  Turns it&#39;s argument into a string then reverses that string.<pre></pre><br/></td>
</tr>
 <tr>
<td>398</td> <td><b>str/startsWith</b></td> <td>autoload.tl</td> <td>Syntax: (str/startsWith [(^string? str) (^string? frag)])<br/><br/>  The &#39;str/startswith&#39; function returns true if that argument string starts with the string fragment in the second argument. The comparison is done case-insensitively by default. Use -case to specify case-sensitive comparisons.<br><br><pre>Examples:
    (str/startswith &quot;abcd&quot; &quot;ab&quot;)        ; returns true
    (str/startswith &quot;ABCD&quot; &quot;ab&quot;)        ; returns true
    (str/startswith -case &quot;ABCD&quot; &quot;ab&quot;)  ; returns false
    (str/startswith &quot;123abcd&quot; &quot;ab&quot;)     ; returns false</pre><br/></td>
</tr>
 <tr>
<td>399</td> <td><b>str/truncate</b></td> <td>autoload.tl</td> <td>Syntax: (str/truncate [args])<br/><br/>  Truncate a string for printing to the console or a file. This function returns a single string that will fit on one line on the console.<pre></pre><br/></td>
</tr>
 <tr>
<td>400</td> <td><b>string?</b></td> <td>built-in</td> <td>Syntax: (string? &lt;obj&gt;)<br/><br/>  The &#39;string?&#39; function returns true if it&#39;s argument is a string.<br><br><pre>Examples:
    (string? &quot;hi&quot;)    ; returns true
    (string? 123)       ; returns false</pre><br/></td>
</tr>
 <tr>
<td>401</td> <td><b>str-peg</b></td> <td>autoload.tl</td> <td>Syntax: [ targ pat | targ offset pat ]<br/><br/>  Test to see if the substring at &#39;offset&#39; matches the pattern string. This function returns an array of two values: a boolean containing success or failure of the match and the updated offset that point to the end of the matched portion of the string.<br><br><pre>Examples:
    (begin-string &quot;abcdef&quot; 0 &quot;abc&quot;) ; returns [true 3]
    (begin-string &quot;abcdef&quot; 3 &quot;de&quot;) ; returns [true 5]
    (begin-string &quot;abcdef&quot; 3 &quot;xyz&quot;) ; returns [false 5]</pre><br/></td>
</tr>
 <tr>
<td>402</td> <td><b>Str-To-Lower</b></td> <td>autoload.tl</td> <td>Syntax: (Str-To-Lower [(^string? stringToProcess)])<br/><br/>  Makes the first character in a string a lowercase letter.<pre></pre><br/></td>
</tr>
 <tr>
<td>403</td> <td><b>Str-To-Lower-All</b></td> <td>autoload.tl</td> <td>Syntax: (Str-To-Lower-All [(^string? stringToProcess)])<br/><br/>  Make all the characters in a string uppercase.<pre></pre><br/></td>
</tr>
 <tr>
<td>404</td> <td><b>Str-To-Upper</b></td> <td>autoload.tl</td> <td>Syntax: (Str-To-Upper [(^string? stringToProcess)])<br/><br/>  Make the first character in a string into an uppercase letter.<pre></pre><br/></td>
</tr>
 <tr>
<td>405</td> <td><b>Str-To-Upper-All</b></td> <td>autoload.tl</td> <td>Syntax: (Str-To-Upper-All [(^string? stringToProcess)])<br/><br/>  Make all the characters in a string uppercase.<pre></pre><br/></td>
</tr>
 <tr>
<td>406</td> <td><b>subseq</b></td> <td>autoload.tl</td> <td>Syntax: (subseq [lst start (^int end -1)])<br/><br/>  Return a subsequence of a Seq. The sequence starts at &#39;start&#39;. If &#39;end&#39; is not specified, the rest of the sequence is returned. If &#39;end&#39; is provided, the sequence that is returned includes the item at the &#39;end&#39; position.<pre></pre><br/></td>
</tr>
 <tr>
<td>407</td> <td><b>sum</b></td> <td>autoload.tl</td> <td>Syntax: [ (^IEnumerable listOfNumbers) accessor | (^IEnumerable listOfNumbers) | %none? (accessor null) | n (accessor echo) | args ]<br/><br/>  Sum all of the values in the argument list. An optional accessor function can be provided to select the property on the input objects to sum.<br><br> <pre>Examples:
    (range 10 | sum)
    (sum (range 10))
    (ls -file | sum .length)    ; get the total length of all the files in the current directory</pre><br/><i>See also: prod + reduce</i></td>
</tr>
 <tr>
<td>408</td> <td><b>swap</b></td> <td>built-in</td> <td>Syntax: (swap var1 var2 [function]) or (swap var1 index1 var2 index2 [function])<br/><br/>  This function swaps the values in variables or alternately, the values of vectors stored in variables. In both cases, a comparer function can be provided. This function is evaluated with the two values and the result is true, the values are swapped.<br><br><pre>Examples:
    (swap a b)        ; swaps the values in &#39;a&#39; and &#39;b&#39;.
    (swap a b &gt;)      ; swap if &#39;a&#39; is greater than &#39;b&#39;
    (swap a 0 a 1)    ; swaps the first and second elements in the vector stored in &#39;a&#39;.
    (swap a 0 a 1 &gt; ) ; swaps if the first element is greated that the second element
    (swap a b (fn x y -&gt; (&gt; x y))) ; swap with user function</pre><br/></td>
</tr>
 <tr>
<td>409</td> <td><b>symbol</b></td> <td>built-in</td> <td>Syntax: (symbol &lt;symname&gt;)<br/><br/>  Gets or creates the named symbol. If the symbol exists, it is simply returned otherwise a new symbol is created atomically.<br><br><pre></pre><br/><i>See also: symbol get-symbol gen-symbol show-symbols</i></td>
</tr>
 <tr>
<td>410</td> <td><b>symbol?</b></td> <td>built-in</td> <td>Syntax: (symbol? &lt;object&gt;)<br/><br/>  Returns true if the argument object is a symbol.<br><br><pre>Examples:
    (symbol? &#39;foo)  ; returns true.
    (symbol? 123)   ; returns false.</pre><br/></td>
</tr>
 <tr>
<td>411</td> <td><b>tail</b></td> <td>built-in</td> <td>Syntax: (tail listOfObjects)<br/><br/>  The &#39;tail&#39; function skips the first item in a sequence and returns the rest, or it returns the item itself if it&#39;s an atom. Note that for sequences, cdr always returns an s_Expr regardless of the original type of the sequence. This is for performance reasons. Getting the cdr of a Vector is slow. Getting the cdr of an s_Expr, is very fast. (Commands tail and rest are aliases for cdr.)<br><br> <pre>Examples:
    (car &#39;(1 2 3))  ; returns &#39;(2 3)
    (car [4 5 6])   ; returns [5 6[
    (car &quot;abc&quot;)     ; returns &quot;abc&quot;</pre><br/><i>See also: car head first tail rest</i></td>
</tr>
 <tr>
<td>412</td> <td><b>take</b></td> <td>built-in</td> <td>Syntax: (take &lt;list&gt; &lt;count&gt;)<br/><br/>  Takes &lt;count&gt; objects from the front of the argument list. If the count specified is larger than the number of items in the list, the entire list is returned. Negative indexing is also supported. For example &#39;(take lst -1)&#39; returns all but the last element from &#39;lst&#39;. (Note: while negative indexing will work on an ^IEnumerable, it can be slow as it must count the number of elements to determine how many to take.) If an ^IList is passed, an immutable ^Slice of that ^IList will be returned.<br><br> <pre>Examples:
    (take [1 2 3 4] 2) ; returns [1 2]
    (take [1 2 3] 10)  ; returns [1 2 3]
    (take [1 2 3] -1)  ; returns [1 2]</pre><br/><i>See also: take-after take-until skip</i></td>
</tr>
 <tr>
<td>413</td> <td><b>take-after</b></td> <td>built-in</td> <td>Syntax: (take-after &lt;list&gt; &lt;item&gt;) or (take-after &lt;list&gt; &lt;function&gt;)<br/><br/>  Takes items from a list after the specified item is found or the specified function returns true.<br><br> <pre>Examples:
    (range 5 | take-after 3) ; returns [4 5]
    (range 4 | take-after (fn n -&gt; (== (% n 2) 0))))  ; returns [3 4]</pre><br/><i>See also: take take-until skip</i></td>
</tr>
 <tr>
<td>414</td> <td><b>take-until</b></td> <td>built-in</td> <td>Syntax: (take-until &lt;list&gt; &lt;item&gt;) or (take-until &lt;list&gt; &lt;function&gt;)<br/><br/>  Takes items from a list untils the specified item is found or the specified function returns true.<br><br> <pre>Examples:
    (range 5 | take-until 3) ; returns [1 2]
    (range 4 | take-until (fn n -&gt; (== (% n 2) 0))))  ; returns [1]</pre><br/><i>See also: take take-after skip</i></td>
</tr>
 <tr>
<td>415</td> <td><b>tan</b></td> <td>autoload.tl</td> <td>Syntax: (tan [num])<br/><br/>  Compute the tangent of a number.<pre></pre><br/></td>
</tr>
 <tr>
<td>416</td> <td><b>task</b></td> <td>built-in</td> <td>Syntax: (task &lt;lambda&gt; [&lt;argToLambda&gt;])<br/><br/>  Starts a new background task using the .NET Task Parallel Library with the lambda as the ^Task procedure. An optional argument may be passed in though most things will be passed through the closure. Tasks can be composed with the subsequent task receiving the result of the previous task.<br><br> <pre>Examples:
    (await (task (fn -&gt; (println &#39;hello))))           ; starts and then waits for a task that prints &#39;hello&#39;.
    (task (fn -&gt; 123) | await)                        ; returns [123]
    (task (fn -&gt; 2) | task (fn n -&gt; (* n 2)) | await) ; returns [4]</pre><br/><i>See also: resolve map-parallel await</i></td>
</tr>
 <tr>
<td>417</td> <td><b>taskid</b></td> <td>autoload.tl</td> <td>Syntax: (taskid [])<br/><br/>  Get the current Task id. In the main context, this will be null.<pre></pre><br/></td>
</tr>
 <tr>
<td>418</td> <td><b>thenSort</b></td> <td>built-in</td> <td>Syntax: (thenSort &lt;output-of-sort&gt; [&lt;accessor&gt;])<br/><br/>  This function performs a secondary sort on the enumerator returned by &#39;sort&#39;. It can be applied multiple times to perform very complex sortings. Note that this is a lazy function and returns an IEnumerable.<br><br> <pre>Examples:
    (sort [[2 :a] [1 :a] [2 :b]] car | thenSort second) ; returns [[1 :a] [2 :a] [2 :b]]</pre><br/><i>See also: sort</i></td>
</tr>
 <tr>
<td>419</td> <td><b>third</b></td> <td>autoload.tl</td> <td>Syntax: (third [lst])<br/><br/>  Returns the third item in a sequence<pre></pre><br/></td>
</tr>
 <tr>
<td>420</td> <td><b>throw</b></td> <td>built-in</td> <td>Syntax: (throw &lt;messageString&gt;)<br/><br/>  Throws a generic exception with a custom message.<br><br> <pre>Examples:
    (throw &quot;An error notification&quot;)</pre><br/><i>See also: try error</i></td>
</tr>
 <tr>
<td>421</td> <td><b>tid</b></td> <td>autoload.tl</td> <td>Syntax: (tid [])<br/><br/>  Get the managed thread ID of the current thread.<pre></pre><br/></td>
</tr>
 <tr>
<td>422</td> <td><b>time</b></td> <td>built-in</td> <td>Syntax: (time [&lt;count&gt;] &lt;expression&gt;)<br/><br/>  Times the duration of the execution of an expression. If the optional count is specified then the expression will be executed that number of times, then printing both the total and average times for all runs.<br><br><pre>Examples:
    (time (fib 25))     ; times how long it takes to compute the factorial of 25
    (time 100 (range 100 | !! 50))  ; times indexing into a range 100 times</pre><br/></td>
</tr>
 <tr>
<td>423</td> <td><b>ToHash</b></td> <td>autoload.tl</td> <td>Syntax: (ToHash [lst])<br/><br/>  Convert a list of items into a dictionary where the keys are the items and the values are item counts. By default, case-insensitive string comparisons are used but you can specify case-sensitive comparisons with the &#39;-case&#39; flag.<br><br> <pre>Examples:
    ; get the 10 most common words in a file
    (read-text &#39;foo.txt | re/split | tohash | sort -descending .value | take 10)
    ; get the 10 most common words in a file, case-sensitive
    (read-text &#39;foo.txt | re/split | tohash -case | sort -descending .value | take 10)</pre><br/><i>See also: group</i></td>
</tr>
 <tr>
<td>424</td> <td><b>tokenize-file</b></td> <td>autoload.tl</td> <td>Syntax: (tokenize-file [filename])<br/><br/>  Parses the contents of a file and returns the tokens it contains<br><br><pre></pre><br/><i>See also: parse-text file/parse eval</i></td>
</tr>
 <tr>
<td>425</td> <td><b>tokenize-text</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>426</td> <td><b>toSourceString</b></td> <td>autoload.tl</td> <td>Syntax: (toSourceString [data])<br/><br/>  Convert an object to a source-formatted string (i.e. escapes are included in the strings, etc.)<br><br><pre>Examples:
    (toSourceString &quot;abc&quot;)      ; returns &#39;&quot;abc&quot;&#39; not &#39;abc&#39;
    (toSourceString 3.0)        ; returns &#39;3.0&#39; not &#39;3&#39;
    (toSourceString #&quot;[a-z]&quot;)   ; returns &#39;#&quot;[a-z]&quot;&#39; not &#39;[a-z]&#39;</pre><br/></td>
</tr>
 <tr>
<td>427</td> <td><b>tostring</b></td> <td>built-in</td> <td>Syntax: (tostring &lt;object&gt;)<br/><br/>  Converts it&#39;s argument into a string.<br><br>  ee also: str<pre>Examples:
    (tostring 3.14)     ; returns &quot;3.14&quot;
    (toostring &quot;hi&quot;)    ; just returns the string</pre><br/></td>
</tr>
 <tr>
<td>428</td> <td><b>tostring-all</b></td> <td>autoload.tl</td> <td>Syntax: (tostring-all [data])<br/><br/>  Turn all of the elements in a list into individual strings.<pre></pre><br/></td>
</tr>
 <tr>
<td>429</td> <td><b>to-vector</b></td> <td>built-in</td> <td>Syntax: (to-vector &lt;IEnumerable&gt;)<br/><br/>  The &#39;to-vector&#39; function takes an enumerable value as an argument. If the argument is already a vector, it will be returned unchainged. All other types will be copied into a new vector.<br><br> <pre>Examples:
    (list 1 2 3 4 | to-vector)</pre><br/><i>See also: vector vector? ^vector</i></td>
</tr>
 <tr>
<td>430</td> <td><b>trace</b></td> <td>built-in</td> <td>Syntax: (trace true/false) or (trace [-Exceptions] &lt;expression&gt;)<br/><br/>  Trace the execution of the interpreter. Tracing can be enabled globaly with (trace true) disable with (trace false). You can also trace the evaluation of an expression. If the &#39;-exceptions&#39; flag is specified, then runtime exceptions will trop you into a nested listener level (repl) where you can example and mutate the state of the system with functions like &#39;show-callstack&#39; and &#39;get-dynamic&#39;.<br><br><pre>Examples:
    (trace true) (+ 2 3) (trace false)  ; try global tracing
    (trace -exceptions (+ 2 3))         ; trace a specific expression.</pre><br/></td>
</tr>
 <tr>
<td>431</td> <td><b>trampoline</b></td> <td>autoload.tl</td> <td>Syntax: (trampoline [func arg])<br/><br/>  A &#39;trampoline&#39; function for Braid. This takes a function of one argument that will either return a new function of no arguments or a value. If a function is returned, it&#39;s called it with no arguments. This is repeated until a non-function value is returned.<br><br><pre>Examples:
    (defn foo [x] (if x (do (info :x x) #(foo (-- x))) &quot;All Done&quot;))  ; function to trampoline
    (trampoline foo 10)                                                ; trampoline it.</pre><br/></td>
</tr>
 <tr>
<td>432</td> <td><b>t-rev</b></td> <td>autoload.tl</td> <td>Syntax: [ x:xs (r nil) | nil (r nil) ]<br/><br/>  Reverse a sequence using pattermatching and tail-recursively<pre></pre><br/></td>
</tr>
 <tr>
<td>433</td> <td><b>truncate-number</b></td> <td>autoload.tl</td> <td>Syntax: (truncate-number [num])<br/><br/>  Truncate a floating-point number returning an integer (^int).<pre></pre><br/></td>
</tr>
 <tr>
<td>434</td> <td><b>try</b></td> <td>built-in</td> <td>Syntax: (try [-catch: &lt;catchExpr&gt;] [-finally: &lt;finallyExpr&gt;] &lt;bodyExpressions...&gt;)<br/><br/>  This function implements try/catch semantics. It executes all of the body expressions in order. If any of thoese expressions raises an exception, transfer is made to the -catch: expression where the exception is available as %0. Finally, before leaving the control of the function, if there was a -catch: expressions specified, it will be executed.<br><br> <pre>Examples:
    (try -catch: (echo &quot;caught it&quot;)  (nosuchcommand))  ; returns &quot;caught it&quot;</pre><br/><i>See also: throw</i></td>
</tr>
 <tr>
<td>435</td> <td><b>tuple</b></td> <td>built-in</td> <td>Syntax: (tuple &lt;arg1&gt; &lt;arg2&gt; ... &lt;arg5&gt;)<br/><br/>  Create and return an immutable tuple using the values of the arguments. A maximum of 5 arguments is supported.<br><br><pre>Examples:
    (let tup (tuple 1 2 &quot;Hello&quot; (.datetime/now))  ; returns a tuple (1 2 &quot;hello&quot; &lt;datetime&gt;)
    (.item1 tup)                                    ; returns 1</pre><br/></td>
</tr>
 <tr>
<td>436</td> <td><b>type-alias</b></td> <td>built-in</td> <td>Syntax: (type-alias &lt;alias&gt; [&lt;type&gt;])<br/><br/>  If no arguments are provided, returns the current list of type aliases. If just the alias is provided the existing alias binding will be deleted. If both an alias and type are provided then the type alias will be created or updated if it already exists.<br><br> <pre>Examples:
    (type-alias)            ; list all existing type aliases
    (type-alias :foo)       ; delete the type alias for :foo
    (type-alias :foo ^int)  ; establish that ^foo is a type alias for ^int</pre><br/><i>See also: deftype</i></td>
</tr>
 <tr>
<td>437</td> <td><b>type-of</b></td> <td>built-in</td> <td>Syntax: (type-of &lt;object&gt;)<br/><br/> Returns the type of the argument object.<br><br> <pre>Examples:
    (type-of 123) ; returns ^int</pre><br/><i>See also: members-of</i></td>
</tr>
 <tr>
<td>438</td> <td><b>undef</b></td> <td>built-in</td> <td>Syntax: (undef symbolToUnbind)<br/><br/> Removes the binding to the specified symbol from the variable table.<br><br> <pre>Examples:
    (undef foo)</pre><br/><i>See also: let def global</i></td>
</tr>
 <tr>
<td>439</td> <td><b>undeftype</b></td> <td>built-in</td> <td>Syntax: (undeftype ^typeToUndefine)<br/><br/>  The &#39;undeftype&#39; removes a typename from the type lookup table.<br><br><pre>Examples:
    (undeftype ^sometype)  ; returns true if the type was undefined, if the type didn&#39;t exist.</pre><br/></td>
</tr>
 <tr>
<td>440</td> <td><b>unfold</b></td> <td>autoload.tl</td> <td>Syntax: [ func initialValue finalValue | func initialValue | func ]<br/><br/>  The iterator function is a way to produce a (possibly) infinite sequence of values. Each new value in the sequence is computed by taking the current value and passing it to the argument &lt;function&gt;. The result of evaluating that function becomes the new current value. Instead of an array or list, invoking iterator returns a .Net ^IEnumerable. Consumers can then get the enumerator and iterate over that enumerator. If no &#39;max&#39; is provided, the enumerator will produce new values forever on until the consumer stops requesting values. If &#39;max&#39; is specified, values will be produced until &#39;max&#39; is reached.<br><br> (Note: &#39;unfold&#39; is an alias for &#39;iterator&#39;.)<br><br> <pre>Examples:
    (iterator ++ 1 | take 100)        ; get integers from 1-100.
    (iterator (+ 2) 2 10)             ; even numbers from 2-10 inclusive.
    ; the following computes (fib 10)
    (iterator (fn x:y: -&gt; [y (+ x y)]) [1 1] | take 10 | last | last)</pre><br/><i>See also: reduce foldl roldr unfold</i></td>
</tr>
 <tr>
<td>441</td> <td><b>union</b></td> <td>built-in</td> <td>Syntax: (union &lt;list1&gt; &lt;list2&gt;)<br/><br/> Computes the union of the two argument sets.<br><br> <pre>Examples:
    (union [1 2 3] [2 3 4]) ; returns [1 2 3 4]</pre><br/><i>See also: except intersect</i></td>
</tr>
 <tr>
<td>442</td> <td><b>unless</b></td> <td></td> <td>Syntax: (unless &lt;cond&gt; &lt;expr1&gt; &lt;expr2&gt; ... &lt;exprn&gt;)<br/><br/>  A control structure that evaluates all of the body exprs if the cond expr evaluates to false. This is a macro that is implemented in terms of the &#39;if&#39; and &#39;do&#39; functions.<br><br><pre></pre><br/><i>See also: when if do</i></td>
</tr>
 <tr>
<td>443</td> <td><b>upDo</b></td> <td>built-in</td> <td>Syntax: (upDo &lt;expression&gt;)<br/><br/>  The &#39;upDo&#39; function is similar to the &#39;eval&#39; function except it evaluates its argument in the caller&#39;s (parent) context. This function is typically used in special forms created with defspecial.<br><br> <pre>Examples:
    ; function to set x to 1 in the caller&#39;s context.
    (defn set-x-to-1 [] (upDo &#39;(let x 1)))
    (let x 10)      ; set x to 10
    (set-x-to-1)
    x               ; returns 1</pre><br/><i>See also: defspecial upvar upDo</i></td>
</tr>
 <tr>
<td>444</td> <td><b>upvar</b></td> <td>built-in</td> <td>Syntax: (upvar &lt;parentSymbol&gt; &lt;localSymbol&gt;)<br/><br/>  The &#39;upvar&#39; function allows you to bind a variable from the caller&#39;s scope onto a variable in the current (local) scope i.e. it binds a variable &#39;up&#39; one level. Once this binding is established, setting the local variable actually sets the variable in the caller&#39;s scope. When the binding is being established, if there is no variable corresponding to &lt;parentSymbol&gt; in the caller&#39;s context, a new variable will be created in the caller&#39;s context. This function is usually used in special forms defined with &#39;defspecial&#39;.<br><br> <pre>Examples:
    ; Define a function like &#39;incr&#39; that increments the named variable by 2
    (defspecial incr-by-2 [(^symbol varToIncrement)]
        (upvar varToIncrement &#39;localVar)
        (incr localvar 2)
    )
    ; try it out
    (incr-by-2 foo)
    foo                 ; returns 2</pre><br/><i>See also: defspecial upDo</i></td>
</tr>
 <tr>
<td>445</td> <td><b>using-assembly</b></td> <td></td> <td>Syntax: (using-assembly [args])<br/><br/>  A macro for loading a .NET assembly at compile time.<br><br> <pre>Examples:
    (using-assembly winforms)</pre><br/><i>See also: load using-module</i></td>
</tr>
 <tr>
<td>446</td> <td><b>using-module</b></td> <td></td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>447</td> <td><b>vars</b></td> <td>autoload.tl</td> <td>Syntax: (vars [(^regex? varname #&quot;&quot;)])<br/><br/>  Function to print out the variables in the current scope. An optional regular expression can be specified to filter the results.<pre></pre><br/></td>
</tr>
 <tr>
<td>448</td> <td><b>vcons</b></td> <td>built-in</td> <td>Syntax: (vcons &lt;object&gt; &lt;vector&gt;)<br/><br/>  Inserts the first argument at the start of the second argument vector and returns the updated vector. This is similar to &#39;cons&#39; but &#39;cons&#39; returns a new list and &#39;vcons&#39; returns a mutated vector. Note - if the second argument is null, then a new vector will be created that contains the first argument.<br><br> <pre>Examples:
    (vcons 1 [2 3 4])       ; returns [1 2 3 4]
    (vcons [1 2 3] [4 5])   ; returns [[1 2 3] 4 5]
    (vcons 3 null)          ; returns [3]
    (vcons [1 2 3] null)    ; returns [[1 2 3]]</pre><br/><i>See also: concat nconc</i></td>
</tr>
 <tr>
<td>449</td> <td><b>vector</b></td> <td>built-in</td> <td>Syntax: (vector [&lt;args&gt;...])<br/><br/>  The &#39;vector&#39; function constructs new vector objects. If no arguments are provided, an empty vector wil be constructed. If arguments are provided, they will be added to the new vector.<br><br> <pre>Examples:
    (vector)                      ; construct a new empty vector
    (vector 1 &quot;two&quot;)            ; construct a 2 elenent vector
    (apply vector (list 1 2 3 4)) ; applies the vector to a list
                                  ; returning a new vector</pre><br/><i>See also: to-vector vector?</i></td>
</tr>
 <tr>
<td>450</td> <td><b>vector?</b></td> <td>built-in</td> <td>Syntax: (vector? &lt;object&gt;)<br/><br/>  Returns true if the argument object is a vector.<br><br> <pre>Examples:
    (vector? [1 2 3])   ; returns true
    (vector? &#39;(1 2 3))  ; returns false becuase a list is not a vector</pre><br/><i>See also: vector to-vector</i></td>
</tr>
 <tr>
<td>451</td> <td><b>vlet</b></td> <td>autoload.tl</td> <td>Syntax: (vlet name value)<br/><br/>  Sets the value of a variable in the current scope if a variable with that name exists or creates a new variable in the current scope if it doesn&#39;t. If the name takes the form of v1:v2:v3 then destructuring will be done and the parts assigned. The only difference between &#39;let&#39; and &#39;vlet&#39; is that &#39;vlet&#39; always returns null instead of the assigned value. This function is primarily intebder fot interactive use.<br><br> <pre>Examples:
    (let foo 123)
    (let x:y:z [1 2 3 4 5])</pre><br/><i>See also: let def setq local</i></td>
</tr>
 <tr>
<td>452</td> <td><b>void</b></td> <td>built-in</td> <td>Syntax: (void &lt;object&gt; ...)<br/><br/>  This function ignores its arguments and simply returns null. Casting to ^void has a similar effect.<br><br> <pre>Examples:
    (range 10 | map (fn x -&gt; (* x x)) | void) ; returns null</pre><br/><i>See also: drain</i></td>
</tr>
 <tr>
<td>453</td> <td><b>walk-tree</b></td> <td>autoload.tl</td> <td>Syntax: [ (^ISeq t) action | (^iseq t) ]<br/><br/>  Walks a parsed tree applying an action to each subtree.<br><br> <pre>Examples:
    (walk-tree &#39;(do (+ 1 2) (* 3 4) (% (- c a) b)) (fn n -&gt; (info n)))</pre><br/><i>See also: file/parse parse-text tokenize-file tokenize-text</i></td>
</tr>
 <tr>
<td>454</td> <td><b>warn</b></td> <td>built-in</td> <td>Syntax: (warn arg1 arg2 arg3 ... argn)<br/><br/>  This function prints a warning string to the console in magenta. All of the arguments are converted to strings then joined to a single string seperated by spaces then printed.<br><br> <pre>Examples:
    (warn &quot;This is an warning message.&quot;)
    (warn &#39;this &#39;is &#39;a &#39;message &#39;in &#39;pieces.)
    (warn &quot;The value of 2+2 is&quot; (+ 2 2))</pre><br/><i>See also: alert info error println</i></td>
</tr>
 <tr>
<td>455</td> <td><b>wf/button</b></td> <td>winforms.tl</td> <td>Syntax: (wf/button [args])<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>456</td> <td><b>wf/button-stack</b></td> <td>winforms.tl</td> <td>Syntax: (wf/button-stack [windowTitle args])<br/><br/>  A function to create a vertical stack of menu buttons. The form size is adjusted to fit the content. Actions should be zero-arity functions (callbacks). A &#39;Quit&#39; button is automatically added to the bottom of the button stack.<br><br><pre>Examples:
    (wf/button-stack &quot;My Stack&quot; &quot;button 1&quot; #(println &#39;hi) &quot;button 2&quot; #(println &#39;bye))</pre><br/></td>
</tr>
 <tr>
<td>457</td> <td><b>wf/control</b></td> <td>winforms.tl</td> <td>Syntax: (wf/control [controlType args])<br/><br/>  This is a &#39;generic&#39; function for creating WinForm controls. It allows you to create the control, set all of the properties bind events as well as creating child controls in a &#39;DSL&#39;. A simple example is as follows:  This example creates a simple form object, sets the text and color and then shows it. A more complex example is: This creates a form object containing one child control - a button - that prints &quot;hi there&quot; to the console when pressed. To display this form you would do:<br><br><pre>
    (wf/control :form {:Text &quot;My Control&quot; :BackColor &quot;red&quot;} | .showdialog)
    (let main (wf/control :form
            :Text &quot;My Control&quot;
            :BackColor &quot;red&quot; 
            :Controls [
                (wf/button
                    :Text &quot;Push Me&quot;
                    :Font (wf/font &quot;Courier New&quot; 20)
                    :Dock :fill
                    :ForeColor &quot;white&quot;
                    :Onclick (fn e o -&gt; (println &quot;Hi there&quot;))
                )
            ]
        )
    )
    (.showdialog main)</pre><br/><i>See also: wf/MenuStrip wf/Menu wf/MenuItem</i></td>
</tr>
 <tr>
<td>458</td> <td><b>wf/datagrid</b></td> <td>winforms.tl</td> <td>Syntax: (wf/datagrid [source (title &quot;Data Grid View&quot;)])<br/><br/>  Show the source data in a grid.<br><br><pre>Examples:
    (ls -file | map baseobject | wf/datagrid &quot;Files&quot;)</pre><br/></td>
</tr>
 <tr>
<td>459</td> <td><b>wf/editor</b></td> <td>winforms.tl</td> <td>Syntax: (wf/editor [title inputValue (^IDictionary highlights {}) (menus nil) (owner null)])<br/><br/>  Form to display or edit text.<pre></pre><br/></td>
</tr>
 <tr>
<td>460</td> <td><b>wf/font</b></td> <td>winforms.tl</td> <td>Syntax: (wf/font [(^string? family) (^int? size)])<br/><br/>  Creates a font object from the specified family and size.<br><br><pre>Examples:
    (wf/font :Consolas 16)</pre><br/></td>
</tr>
 <tr>
<td>461</td> <td><b>wf/form</b></td> <td>winforms.tl</td> <td>Syntax: (wf/form [args])<br/><br/><pre></pre><br/></td>
</tr>
 <tr>
<td>462</td> <td><b>wf/highlightEditBox</b></td> <td>winforms.tl</td> <td>Syntax: (wf/highlightEditBox [editbox selectline highlights])<br/><br/>  A function to text do highlighting in a RichTextBox<pre></pre><br/></td>
</tr>
 <tr>
<td>463</td> <td><b>wf/listbox</b></td> <td>winforms.tl</td> <td>Syntax: (wf/listbox [title])<br/><br/>  Function that displays a listbox of options from which the user must select 1 (or more) items.    (wf/listbox &quot;Choose a file&quot; -source: #(ls &#39;*.tl) -selectaction: #(gvim %0))    ; select and stop a process    (wf/listbox &quot;Processes&quot;<pre>Examples:
    
        -source: #(get-process | project :id :name :ws | out-string -stream | skip 3)
        -selectaction: #(stop-process -id: (car (.trim (!! %0 0)))))</pre><br/></td>
</tr>
 <tr>
<td>464</td> <td><b>wf/Menu</b></td> <td>winforms.tl</td> <td>Syntax: (wf/Menu [name menuItems])<br/><br/>  Create a menu with a specific list of items.<br><br><pre>Examples:
    (wf/menu :File
        [
            (wf/menuitem &quot;New Game&quot; (fn e o -&gt; (NewGame)))
            (wf/menuitem :Quit        (fn e o -&gt; (.Close MainForm)))
        ]
    )</pre><br/></td>
</tr>
 <tr>
<td>465</td> <td><b>wf/MenuItem</b></td> <td>winforms.tl</td> <td>Syntax: (wf/MenuItem [(^string? name) (^Callable? action)])<br/><br/>  Create an individual item to add to a menu. The first argument is the name of the menu item to create and the second is the lambda that acts as the event handler for the menu item. The result of this function should be added to the items on the menu itself.<br><br> <pre>Examples:
    (wf/menuitem :Quit  (fn e o -&gt; (.Close MainForm)))</pre><br/><i>See also: wf/Menu wf/MenuStrip</i></td>
</tr>
 <tr>
<td>466</td> <td><b>wf/menustrip</b></td> <td>winforms.tl</td> <td>Syntax: (wf/menustrip [(^System.Windows.Forms.Form form) (^Vector menuItems)])<br/><br/>  Create a menu strip for a Windows form. The first argument is the form to add the menu strip to. The second argument is a list of menus to add to the menu strip.<br><br> <pre>Examples:
    (wf/menustrip MainForm [
            (wf/menu &quot;File&quot;
                [
                    (wf/menuitem &quot;New Game&quot; (lambda [e o] (NewGame)))
                    (wf/menuitem &quot;Quit&quot;     (lambda [e o] (.Close MainForm)))
                ]
            )
        ]
    )</pre><br/><i>See also: wf/menu wf/menuitem</i></td>
</tr>
 <tr>
<td>467</td> <td><b>wf/messagebox</b></td> <td>winforms.tl</td> <td>Syntax: (wf/messagebox [messageText (title &quot;MessageBox&quot;) (buttons &quot;OK&quot;)])<br/><br/>  Shows a message box on the screen. The default button is OK but can also be OK, OKCancel, AbortRetryIgnore, YesNoCancel, YesNo or RetryCancel<br><br><pre>Examples:
    (wf/message &quot;The message&quot; &quot;The Title&quot; :OkCancel)</pre><br/></td>
</tr>
 <tr>
<td>468</td> <td><b>wf/next-color</b></td> <td>winforms.tl</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>469</td> <td><b>wf/point</b></td> <td>winforms.tl</td> <td>Syntax: (wf/point [(^int? x) (^int? y)])<br/><br/>  Creates a new WinForms point object.<br><br><pre>Examples:
    (wf/Point 15 20)</pre><br/></td>
</tr>
 <tr>
<td>470</td> <td><b>wf/QuestionBox</b></td> <td>winforms.tl</td> <td>Syntax: (wf/QuestionBox [message (title &quot;QuestionBox Box&quot;) (initialText &quot;&quot;) (owner null)])<br/><br/>  This function displays a question dialog box containing the question text and an input field for the user to enter their answer. The last &quot;owner&quot; parameter is optional but can be used to specify the parent form for the question box.<br><br><pre>Examples:
    (wf/QuestionBox &quot;My Title&quot; &quot;initial text&quot;)</pre><br/></td>
</tr>
 <tr>
<td>471</td> <td><b>wf/show</b></td> <td>winforms.tl</td> <td>Syntax: (wf/show [Control])<br/><br/>  A utility function to display a form.<pre></pre><br/></td>
</tr>
 <tr>
<td>472</td> <td><b>wf/size</b></td> <td>winforms.tl</td> <td>Syntax: (wf/size [(^int? x) (^int? y)])<br/><br/>  Creates a WinForms size object.<br><br><pre>Examples:
    (wf/size 10 20)</pre><br/></td>
</tr>
 <tr>
<td>473</td> <td><b>when</b></td> <td></td> <td>Syntax: (when &lt;cond&gt; &lt;expr1&gt; &lt;expr2&gt; ... &lt;exprn&gt;)<br/><br/>  A control structure that evaluates all of the body exprs if the cond expr evaluates to true. This is a macro that is implemented in terms of the &#39;if&#39; and &#39;do&#39; functions.<br><br><pre></pre><br/><i>See also: unless if do</i></td>
</tr>
 <tr>
<td>474</td> <td><b>where</b></td> <td>built-in</td> <td>Syntax: (where [-not] &lt;list&gt; &lt;predicate&gt;)<br/><br/> Filters the input collection based on the results of evaluating the predicate function on each item. The predicate can be a lambda literal, a named function, a member accessor, a type literal, a regular expression or a dictionary literal. If a dictionary literal is provided, &#39;where&#39; will use property pattern matching as the filter criteria. The sense of the comparison can be changed with the &#39;-not&#39; flag. The &#39;lazy-&#39; variant returns an enumerable instead of a collection. Individual values can then be pulled from the enumerable as needed thus only evaluating as much as is necessary.  Either of the forms can use &#39;break&#39; in the predicate function to terminate the search at the current item. You can also use &#39;continue&#39; to skip over the current item in the list and keep searching.<br><br> <pre>Examples:
    (range 10 | where (fn n -&gt; (== (% n 2) 0))) ; returns [2 4 6 8 10]
    (range 10 | where even?)                    ; returns [2 4 6 8 10]
    (range 10 | where -not even?)               ; returns [1 3 5 7 9]
    (range 20 | where #&quot;2&quot;)                     ; returns [2 12 20]
    (get-process | where .cpu)                  ; returns all procs that have used CPU
    ; use property patterns to find Error entries whose message matches the regex #&quot;timeout&quot;
    (get-eventlog -log: &quot;system&quot; -newest: 1000 | where {entrytype &quot;error&quot; message #&quot;timeout&quot;})
    ; find element &#39;99&#39; in the input collection, stopping the search when it&#39;s found
    (range 100000 | where (fn n -&gt; (if (== n 99) (break))))</pre><br/><i>See also: filter lazy-filter map lazy-map each</i></td>
</tr>
 <tr>
<td>475</td> <td><b>where-defined</b></td> <td>autoload.tl</td> <td>Syntax: [ ^Callable | ^CommandInfo | ^ScriptBlock ]<br/><br/>  Function to figure out where a function was defined (i.e. what source file.)<pre></pre><br/></td>
</tr>
 <tr>
<td>476</td> <td><b>while</b></td> <td>built-in</td> <td>Syntax: (while condExpr bodyExprs...)<br/><br/>  The basic while loop. It loops evaluating the bodyExprs in sequence until the condExpre evaluates to false following Braid&#39;s truthiness rules.<br><br> <pre>Examples:
    ; print number from 1 to 10
    (let n 1)
    (while (&lt;= n 10)
        (println n) (incr n)
    )
    ; print a vector
    (let l [1 2 3 4])
    (while (let? x:xs l)
        (print x)
    )</pre><br/><i>See also: foreach forall map each</i></td>
</tr>
 <tr>
<td>477</td> <td><b>while-all</b></td> <td>built-in</td> <td><br/><br/> <pre></pre><br/></td>
</tr>
 <tr>
<td>478</td> <td><b>write-data</b></td> <td>autoload.tl</td> <td>Syntax: (write-data [data (^string path)])<br/><br/>  Write binary data to a file.<pre></pre><br/></td>
</tr>
 <tr>
<td>479</td> <td><b>write-lines</b></td> <td>autoload.tl</td> <td>Syntax: (write-lines [(^string[]? text) (^string? path)])<br/><br/>  write an array of strings to a file.<pre></pre><br/></td>
</tr>
 <tr>
<td>480</td> <td><b>write-source</b></td> <td>autoload.tl</td> <td>Syntax: (write-source [text (^string path)])<br/><br/>  Write an object formatted as Braid/JSON source to a text file. This means embedded escapable characters in strings will be turned back into escapes.<br><br> If the object is already a string, no changes are made.<br><br><pre></pre><br/><i>See also: read-text read-data write-data read-file write-lines</i></td>
</tr>
 <tr>
<td>481</td> <td><b>write-text</b></td> <td>autoload.tl</td> <td>Syntax: (write-text [text (^string? path)])<br/><br/>  Write an object to a text file. If the object is a string, just write it as is.<br><br> <pre>Examples:
    (write-file &quot;Hello.&quot; &#39;file.txt)           ; write &#39;Hello.&#39; to file.txt
    (read-text &#39;foo.txt | write-text &#39;bar.txt)  ; copies the contents from foo.txt to bar.txt.</pre><br/><i>See also: read-text read-data write-data read-file write-lines write-source</i></td>
</tr>
 <tr>
<td>482</td> <td><b>xor</b></td> <td>built-in</td> <td>Syntax: (xor arg1 arg2)<br/><br/> The &#39;xor&#39; function, which takes exactly 2 arguments, converts it&#39;s arguments into boolean values then computes the boolean xor of those values.<br><br> AutoCurry: true<pre>Examples:
    (xor false false)   ; returns false
    (xor true false)    ; returns true
    (xor false true)    ; returns true
    (xor true true)     ; returns false</pre><br/><i>See Also: or not and</i></td>
</tr>
 <tr>
<td>483</td> <td><b>zero?</b></td> <td>built-in</td> <td>Syntax: (zero? argument)<br/><br/>  The &#39;zero?&#39; function returns true if its argument is zero.<br><br> <pre>Examples:
    (zero? 0)                       ; returns true
    (zero? 1)                       ; returns false
    (defn f [n] (if (zero? n) 1 (* n (f (-- n)))))</pre><br/><i>See also: none? some? number? null?</i></td>
</tr>
 <tr>
<td>484</td> <td><b>zip</b></td> <td>built-in</td> <td>Syntax (zip &lt;list1&gt; &lt;list2&gt; [&lt;zipFunction&gt;])<br/><br/>  This function zips two lists together so returns An optional function can be used to compute the &#39;zip&#39; results. The examples section shows code that sums the zip&#39;ed elements using a lambda.<br><br> Note: the &#39;break&#39; and &#39;continue&#39; functions can be used in the lambda passed to &#39;zip&#39; to, for example, early terminate the &#39;zip&#39; process.<br><br> <pre>Examples:
    (zip [1 2 3] [10 20 30])
    [[1 10] [2 20] [3 30]]
    (zip [1 2 3] [10 20 30] (fn x y -&gt; (+ y x))) ; returns [11 22 33]
    (zip [1 2 3] [10 20 30] +)                   ; simpler but still returns [11 22 33]
    (defn dotprod [l1 l2] (zip l1 l2 * | sum))   ; function to compute the dot
                                                 ; product of 2 lists.</pre><br/><i>See also: map filter break</i></td>
</tr>
 <tr>
<td>485</td> <td><b>zzzzz</b></td> <td></td> <td>Syntax: (zzzzz [a b])<br/><br/><pre></pre><br/></td>
</tr>

</table>

</body>
</html>
